/**
 * (C) Copyright IBM Corp. 2022.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package catalogmanagementv1_test

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"net/http"
	"net/http/httptest"
	"os"
	"time"

	"github.com/IBM/go-sdk-core/v5/core"
	"github.com/IBM/platform-services-go-sdk/catalogmanagementv1"
	"github.com/go-openapi/strfmt"
	. "github.com/onsi/ginkgo"
	. "github.com/onsi/gomega"
)

var _ = Describe(`CatalogManagementV1`, func() {
	var testServer *httptest.Server
	Describe(`Service constructor tests`, func() {
		It(`Instantiate service client`, func() {
			catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
				Authenticator: &core.NoAuthAuthenticator{},
			})
			Expect(catalogManagementService).ToNot(BeNil())
			Expect(serviceErr).To(BeNil())
		})
		It(`Instantiate service client with error: Invalid URL`, func() {
			catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
				URL: "{BAD_URL_STRING",
			})
			Expect(catalogManagementService).To(BeNil())
			Expect(serviceErr).ToNot(BeNil())
		})
		It(`Instantiate service client with error: Invalid Auth`, func() {
			catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
				URL: "https://catalogmanagementv1/api",
				Authenticator: &core.BasicAuthenticator{
					Username: "",
					Password: "",
				},
			})
			Expect(catalogManagementService).To(BeNil())
			Expect(serviceErr).ToNot(BeNil())
		})
	})
	Describe(`Service constructor tests using external config`, func() {
		Context(`Using external config, construct service client instances`, func() {
			// Map containing environment variables used in testing.
			var testEnvironment = map[string]string{
				"CATALOG_MANAGEMENT_URL": "https://catalogmanagementv1/api",
				"CATALOG_MANAGEMENT_AUTH_TYPE": "noauth",
			}

			It(`Create service client using external config successfully`, func() {
				SetTestEnvironment(testEnvironment)
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1UsingExternalConfig(&catalogmanagementv1.CatalogManagementV1Options{
				})
				Expect(catalogManagementService).ToNot(BeNil())
				Expect(serviceErr).To(BeNil())
				ClearTestEnvironment(testEnvironment)

				clone := catalogManagementService.Clone()
				Expect(clone).ToNot(BeNil())
				Expect(clone.Service != catalogManagementService.Service).To(BeTrue())
				Expect(clone.GetServiceURL()).To(Equal(catalogManagementService.GetServiceURL()))
				Expect(clone.Service.Options.Authenticator).To(Equal(catalogManagementService.Service.Options.Authenticator))
			})
			It(`Create service client using external config and set url from constructor successfully`, func() {
				SetTestEnvironment(testEnvironment)
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1UsingExternalConfig(&catalogmanagementv1.CatalogManagementV1Options{
					URL: "https://testService/api",
				})
				Expect(catalogManagementService).ToNot(BeNil())
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService.Service.GetServiceURL()).To(Equal("https://testService/api"))
				ClearTestEnvironment(testEnvironment)

				clone := catalogManagementService.Clone()
				Expect(clone).ToNot(BeNil())
				Expect(clone.Service != catalogManagementService.Service).To(BeTrue())
				Expect(clone.GetServiceURL()).To(Equal(catalogManagementService.GetServiceURL()))
				Expect(clone.Service.Options.Authenticator).To(Equal(catalogManagementService.Service.Options.Authenticator))
			})
			It(`Create service client using external config and set url programatically successfully`, func() {
				SetTestEnvironment(testEnvironment)
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1UsingExternalConfig(&catalogmanagementv1.CatalogManagementV1Options{
				})
				err := catalogManagementService.SetServiceURL("https://testService/api")
				Expect(err).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService.Service.GetServiceURL()).To(Equal("https://testService/api"))
				ClearTestEnvironment(testEnvironment)

				clone := catalogManagementService.Clone()
				Expect(clone).ToNot(BeNil())
				Expect(clone.Service != catalogManagementService.Service).To(BeTrue())
				Expect(clone.GetServiceURL()).To(Equal(catalogManagementService.GetServiceURL()))
				Expect(clone.Service.Options.Authenticator).To(Equal(catalogManagementService.Service.Options.Authenticator))
			})
		})
		Context(`Using external config, construct service client instances with error: Invalid Auth`, func() {
			// Map containing environment variables used in testing.
			var testEnvironment = map[string]string{
				"CATALOG_MANAGEMENT_URL": "https://catalogmanagementv1/api",
				"CATALOG_MANAGEMENT_AUTH_TYPE": "someOtherAuth",
			}

			SetTestEnvironment(testEnvironment)
			catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1UsingExternalConfig(&catalogmanagementv1.CatalogManagementV1Options{
			})

			It(`Instantiate service client with error`, func() {
				Expect(catalogManagementService).To(BeNil())
				Expect(serviceErr).ToNot(BeNil())
				ClearTestEnvironment(testEnvironment)
			})
		})
		Context(`Using external config, construct service client instances with error: Invalid URL`, func() {
			// Map containing environment variables used in testing.
			var testEnvironment = map[string]string{
				"CATALOG_MANAGEMENT_AUTH_TYPE":   "NOAuth",
			}

			SetTestEnvironment(testEnvironment)
			catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1UsingExternalConfig(&catalogmanagementv1.CatalogManagementV1Options{
				URL: "{BAD_URL_STRING",
			})

			It(`Instantiate service client with error`, func() {
				Expect(catalogManagementService).To(BeNil())
				Expect(serviceErr).ToNot(BeNil())
				ClearTestEnvironment(testEnvironment)
			})
		})
	})
	Describe(`Regional endpoint tests`, func() {
		It(`GetServiceURLForRegion(region string)`, func() {
			var url string
			var err error
			url, err = catalogmanagementv1.GetServiceURLForRegion("INVALID_REGION")
			Expect(url).To(BeEmpty())
			Expect(err).ToNot(BeNil())
			fmt.Fprintf(GinkgoWriter, "Expected error: %s\n", err.Error())
		})
	})
	Describe(`GetCatalogAccount(getCatalogAccountOptions *GetCatalogAccountOptions) - Operation response error`, func() {
		getCatalogAccountPath := "/catalogaccount"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getCatalogAccountPath))
					Expect(req.Method).To(Equal("GET"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetCatalogAccount with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetCatalogAccountOptions model
				getCatalogAccountOptionsModel := new(catalogmanagementv1.GetCatalogAccountOptions)
				getCatalogAccountOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetCatalogAccount(getCatalogAccountOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetCatalogAccount(getCatalogAccountOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetCatalogAccount(getCatalogAccountOptions *GetCatalogAccountOptions)`, func() {
		getCatalogAccountPath := "/catalogaccount"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getCatalogAccountPath))
					Expect(req.Method).To(Equal("GET"))

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "hide_IBM_cloud_catalog": false, "account_filters": {"include_all": true, "category_filters": {"mapKey": {"include": false, "filter": {"filter_terms": ["FilterTerms"]}}}, "id_filters": {"include": {"filter_terms": ["FilterTerms"]}, "exclude": {"filter_terms": ["FilterTerms"]}}}}`)
				}))
			})
			It(`Invoke GetCatalogAccount successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetCatalogAccountOptions model
				getCatalogAccountOptionsModel := new(catalogmanagementv1.GetCatalogAccountOptions)
				getCatalogAccountOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetCatalogAccountWithContext(ctx, getCatalogAccountOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetCatalogAccount(getCatalogAccountOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetCatalogAccountWithContext(ctx, getCatalogAccountOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getCatalogAccountPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "hide_IBM_cloud_catalog": false, "account_filters": {"include_all": true, "category_filters": {"mapKey": {"include": false, "filter": {"filter_terms": ["FilterTerms"]}}}, "id_filters": {"include": {"filter_terms": ["FilterTerms"]}, "exclude": {"filter_terms": ["FilterTerms"]}}}}`)
				}))
			})
			It(`Invoke GetCatalogAccount successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetCatalogAccount(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetCatalogAccountOptions model
				getCatalogAccountOptionsModel := new(catalogmanagementv1.GetCatalogAccountOptions)
				getCatalogAccountOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetCatalogAccount(getCatalogAccountOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetCatalogAccount with error: Operation request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetCatalogAccountOptions model
				getCatalogAccountOptionsModel := new(catalogmanagementv1.GetCatalogAccountOptions)
				getCatalogAccountOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetCatalogAccount(getCatalogAccountOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetCatalogAccount successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetCatalogAccountOptions model
				getCatalogAccountOptionsModel := new(catalogmanagementv1.GetCatalogAccountOptions)
				getCatalogAccountOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetCatalogAccount(getCatalogAccountOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateCatalogAccount(updateCatalogAccountOptions *UpdateCatalogAccountOptions) - Operation response error`, func() {
		updateCatalogAccountPath := "/catalogaccount"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateCatalogAccountPath))
					Expect(req.Method).To(Equal("PUT"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke UpdateCatalogAccount with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the FilterTerms model
				filterTermsModel := new(catalogmanagementv1.FilterTerms)
				filterTermsModel.FilterTerms = []string{"testString"}

				// Construct an instance of the CategoryFilter model
				categoryFilterModel := new(catalogmanagementv1.CategoryFilter)
				categoryFilterModel.Include = core.BoolPtr(true)
				categoryFilterModel.Filter = filterTermsModel

				// Construct an instance of the IDFilter model
				idFilterModel := new(catalogmanagementv1.IDFilter)
				idFilterModel.Include = filterTermsModel
				idFilterModel.Exclude = filterTermsModel

				// Construct an instance of the Filters model
				filtersModel := new(catalogmanagementv1.Filters)
				filtersModel.IncludeAll = core.BoolPtr(true)
				filtersModel.CategoryFilters = make(map[string]catalogmanagementv1.CategoryFilter)
				filtersModel.IDFilters = idFilterModel
				filtersModel.CategoryFilters["foo"] = *categoryFilterModel

				// Construct an instance of the UpdateCatalogAccountOptions model
				updateCatalogAccountOptionsModel := new(catalogmanagementv1.UpdateCatalogAccountOptions)
				updateCatalogAccountOptionsModel.ID = core.StringPtr("testString")
				updateCatalogAccountOptionsModel.Rev = core.StringPtr("testString")
				updateCatalogAccountOptionsModel.HideIBMCloudCatalog = core.BoolPtr(true)
				updateCatalogAccountOptionsModel.AccountFilters = filtersModel
				updateCatalogAccountOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.UpdateCatalogAccount(updateCatalogAccountOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.UpdateCatalogAccount(updateCatalogAccountOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateCatalogAccount(updateCatalogAccountOptions *UpdateCatalogAccountOptions)`, func() {
		updateCatalogAccountPath := "/catalogaccount"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateCatalogAccountPath))
					Expect(req.Method).To(Equal("PUT"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "hide_IBM_cloud_catalog": false, "account_filters": {"include_all": true, "category_filters": {"mapKey": {"include": false, "filter": {"filter_terms": ["FilterTerms"]}}}, "id_filters": {"include": {"filter_terms": ["FilterTerms"]}, "exclude": {"filter_terms": ["FilterTerms"]}}}}`)
				}))
			})
			It(`Invoke UpdateCatalogAccount successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the FilterTerms model
				filterTermsModel := new(catalogmanagementv1.FilterTerms)
				filterTermsModel.FilterTerms = []string{"testString"}

				// Construct an instance of the CategoryFilter model
				categoryFilterModel := new(catalogmanagementv1.CategoryFilter)
				categoryFilterModel.Include = core.BoolPtr(true)
				categoryFilterModel.Filter = filterTermsModel

				// Construct an instance of the IDFilter model
				idFilterModel := new(catalogmanagementv1.IDFilter)
				idFilterModel.Include = filterTermsModel
				idFilterModel.Exclude = filterTermsModel

				// Construct an instance of the Filters model
				filtersModel := new(catalogmanagementv1.Filters)
				filtersModel.IncludeAll = core.BoolPtr(true)
				filtersModel.CategoryFilters = make(map[string]catalogmanagementv1.CategoryFilter)
				filtersModel.IDFilters = idFilterModel
				filtersModel.CategoryFilters["foo"] = *categoryFilterModel

				// Construct an instance of the UpdateCatalogAccountOptions model
				updateCatalogAccountOptionsModel := new(catalogmanagementv1.UpdateCatalogAccountOptions)
				updateCatalogAccountOptionsModel.ID = core.StringPtr("testString")
				updateCatalogAccountOptionsModel.Rev = core.StringPtr("testString")
				updateCatalogAccountOptionsModel.HideIBMCloudCatalog = core.BoolPtr(true)
				updateCatalogAccountOptionsModel.AccountFilters = filtersModel
				updateCatalogAccountOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.UpdateCatalogAccountWithContext(ctx, updateCatalogAccountOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.UpdateCatalogAccount(updateCatalogAccountOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.UpdateCatalogAccountWithContext(ctx, updateCatalogAccountOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateCatalogAccountPath))
					Expect(req.Method).To(Equal("PUT"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "hide_IBM_cloud_catalog": false, "account_filters": {"include_all": true, "category_filters": {"mapKey": {"include": false, "filter": {"filter_terms": ["FilterTerms"]}}}, "id_filters": {"include": {"filter_terms": ["FilterTerms"]}, "exclude": {"filter_terms": ["FilterTerms"]}}}}`)
				}))
			})
			It(`Invoke UpdateCatalogAccount successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.UpdateCatalogAccount(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the FilterTerms model
				filterTermsModel := new(catalogmanagementv1.FilterTerms)
				filterTermsModel.FilterTerms = []string{"testString"}

				// Construct an instance of the CategoryFilter model
				categoryFilterModel := new(catalogmanagementv1.CategoryFilter)
				categoryFilterModel.Include = core.BoolPtr(true)
				categoryFilterModel.Filter = filterTermsModel

				// Construct an instance of the IDFilter model
				idFilterModel := new(catalogmanagementv1.IDFilter)
				idFilterModel.Include = filterTermsModel
				idFilterModel.Exclude = filterTermsModel

				// Construct an instance of the Filters model
				filtersModel := new(catalogmanagementv1.Filters)
				filtersModel.IncludeAll = core.BoolPtr(true)
				filtersModel.CategoryFilters = make(map[string]catalogmanagementv1.CategoryFilter)
				filtersModel.IDFilters = idFilterModel
				filtersModel.CategoryFilters["foo"] = *categoryFilterModel

				// Construct an instance of the UpdateCatalogAccountOptions model
				updateCatalogAccountOptionsModel := new(catalogmanagementv1.UpdateCatalogAccountOptions)
				updateCatalogAccountOptionsModel.ID = core.StringPtr("testString")
				updateCatalogAccountOptionsModel.Rev = core.StringPtr("testString")
				updateCatalogAccountOptionsModel.HideIBMCloudCatalog = core.BoolPtr(true)
				updateCatalogAccountOptionsModel.AccountFilters = filtersModel
				updateCatalogAccountOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.UpdateCatalogAccount(updateCatalogAccountOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke UpdateCatalogAccount with error: Operation request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the FilterTerms model
				filterTermsModel := new(catalogmanagementv1.FilterTerms)
				filterTermsModel.FilterTerms = []string{"testString"}

				// Construct an instance of the CategoryFilter model
				categoryFilterModel := new(catalogmanagementv1.CategoryFilter)
				categoryFilterModel.Include = core.BoolPtr(true)
				categoryFilterModel.Filter = filterTermsModel

				// Construct an instance of the IDFilter model
				idFilterModel := new(catalogmanagementv1.IDFilter)
				idFilterModel.Include = filterTermsModel
				idFilterModel.Exclude = filterTermsModel

				// Construct an instance of the Filters model
				filtersModel := new(catalogmanagementv1.Filters)
				filtersModel.IncludeAll = core.BoolPtr(true)
				filtersModel.CategoryFilters = make(map[string]catalogmanagementv1.CategoryFilter)
				filtersModel.IDFilters = idFilterModel
				filtersModel.CategoryFilters["foo"] = *categoryFilterModel

				// Construct an instance of the UpdateCatalogAccountOptions model
				updateCatalogAccountOptionsModel := new(catalogmanagementv1.UpdateCatalogAccountOptions)
				updateCatalogAccountOptionsModel.ID = core.StringPtr("testString")
				updateCatalogAccountOptionsModel.Rev = core.StringPtr("testString")
				updateCatalogAccountOptionsModel.HideIBMCloudCatalog = core.BoolPtr(true)
				updateCatalogAccountOptionsModel.AccountFilters = filtersModel
				updateCatalogAccountOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.UpdateCatalogAccount(updateCatalogAccountOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke UpdateCatalogAccount successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the FilterTerms model
				filterTermsModel := new(catalogmanagementv1.FilterTerms)
				filterTermsModel.FilterTerms = []string{"testString"}

				// Construct an instance of the CategoryFilter model
				categoryFilterModel := new(catalogmanagementv1.CategoryFilter)
				categoryFilterModel.Include = core.BoolPtr(true)
				categoryFilterModel.Filter = filterTermsModel

				// Construct an instance of the IDFilter model
				idFilterModel := new(catalogmanagementv1.IDFilter)
				idFilterModel.Include = filterTermsModel
				idFilterModel.Exclude = filterTermsModel

				// Construct an instance of the Filters model
				filtersModel := new(catalogmanagementv1.Filters)
				filtersModel.IncludeAll = core.BoolPtr(true)
				filtersModel.CategoryFilters = make(map[string]catalogmanagementv1.CategoryFilter)
				filtersModel.IDFilters = idFilterModel
				filtersModel.CategoryFilters["foo"] = *categoryFilterModel

				// Construct an instance of the UpdateCatalogAccountOptions model
				updateCatalogAccountOptionsModel := new(catalogmanagementv1.UpdateCatalogAccountOptions)
				updateCatalogAccountOptionsModel.ID = core.StringPtr("testString")
				updateCatalogAccountOptionsModel.Rev = core.StringPtr("testString")
				updateCatalogAccountOptionsModel.HideIBMCloudCatalog = core.BoolPtr(true)
				updateCatalogAccountOptionsModel.AccountFilters = filtersModel
				updateCatalogAccountOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.UpdateCatalogAccount(updateCatalogAccountOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListCatalogAccountAudits(listCatalogAccountAuditsOptions *ListCatalogAccountAuditsOptions) - Operation response error`, func() {
		listCatalogAccountAuditsPath := "/catalogaccount/audits"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listCatalogAccountAuditsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// TODO: Add check for lookupnames query parameter
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListCatalogAccountAudits with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListCatalogAccountAuditsOptions model
				listCatalogAccountAuditsOptionsModel := new(catalogmanagementv1.ListCatalogAccountAuditsOptions)
				listCatalogAccountAuditsOptionsModel.Start = core.StringPtr("testString")
				listCatalogAccountAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listCatalogAccountAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listCatalogAccountAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.ListCatalogAccountAudits(listCatalogAccountAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.ListCatalogAccountAudits(listCatalogAccountAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListCatalogAccountAudits(listCatalogAccountAuditsOptions *ListCatalogAccountAuditsOptions)`, func() {
		listCatalogAccountAuditsPath := "/catalogaccount/audits"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listCatalogAccountAuditsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// TODO: Add check for lookupnames query parameter
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"start": "Start", "limit": 5, "total_count": 10, "resource_count": 13, "first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}, "prev": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}, "audits": [{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message"}]}`)
				}))
			})
			It(`Invoke ListCatalogAccountAudits successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the ListCatalogAccountAuditsOptions model
				listCatalogAccountAuditsOptionsModel := new(catalogmanagementv1.ListCatalogAccountAuditsOptions)
				listCatalogAccountAuditsOptionsModel.Start = core.StringPtr("testString")
				listCatalogAccountAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listCatalogAccountAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listCatalogAccountAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.ListCatalogAccountAuditsWithContext(ctx, listCatalogAccountAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.ListCatalogAccountAudits(listCatalogAccountAuditsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.ListCatalogAccountAuditsWithContext(ctx, listCatalogAccountAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listCatalogAccountAuditsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// TODO: Add check for lookupnames query parameter
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"start": "Start", "limit": 5, "total_count": 10, "resource_count": 13, "first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}, "prev": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}, "audits": [{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message"}]}`)
				}))
			})
			It(`Invoke ListCatalogAccountAudits successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.ListCatalogAccountAudits(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListCatalogAccountAuditsOptions model
				listCatalogAccountAuditsOptionsModel := new(catalogmanagementv1.ListCatalogAccountAuditsOptions)
				listCatalogAccountAuditsOptionsModel.Start = core.StringPtr("testString")
				listCatalogAccountAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listCatalogAccountAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listCatalogAccountAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.ListCatalogAccountAudits(listCatalogAccountAuditsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListCatalogAccountAudits with error: Operation request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListCatalogAccountAuditsOptions model
				listCatalogAccountAuditsOptionsModel := new(catalogmanagementv1.ListCatalogAccountAuditsOptions)
				listCatalogAccountAuditsOptionsModel.Start = core.StringPtr("testString")
				listCatalogAccountAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listCatalogAccountAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listCatalogAccountAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.ListCatalogAccountAudits(listCatalogAccountAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListCatalogAccountAudits successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListCatalogAccountAuditsOptions model
				listCatalogAccountAuditsOptionsModel := new(catalogmanagementv1.ListCatalogAccountAuditsOptions)
				listCatalogAccountAuditsOptionsModel.Start = core.StringPtr("testString")
				listCatalogAccountAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listCatalogAccountAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listCatalogAccountAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.ListCatalogAccountAudits(listCatalogAccountAuditsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Test pagination helper method on response`, func() {
			It(`Invoke GetNextStart successfully`, func() {
				responseObject := new(catalogmanagementv1.AuditLogs)
				nextObject := new(catalogmanagementv1.PaginationTokenLink)
				nextObject.Start = core.StringPtr("abc-123")
				responseObject.Next = nextObject
	
				value, err := responseObject.GetNextStart()
				Expect(err).To(BeNil())
				Expect(value).To(Equal(core.StringPtr("abc-123")))
			})
			It(`Invoke GetNextStart without a "Next" property in the response`, func() {
				responseObject := new(catalogmanagementv1.AuditLogs)
	
				value, err := responseObject.GetNextStart()
				Expect(err).To(BeNil())
				Expect(value).To(BeNil())
			})
		})
		Context(`Using mock server endpoint - paginated response`, func() {
			BeforeEach(func() {
				var requestNumber int = 0
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listCatalogAccountAuditsPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					requestNumber++
					if requestNumber == 1 {
						fmt.Fprintf(res, "%s", `{"next":{"start":"1"},"total_count":2,"limit":1,"audits":[{"id":"ID","_rev":"Rev","created":"2019-01-01T12:00:00.000Z","change_type":"ChangeType","target_type":"TargetType","target_id":"TargetID","who_email":"WhoEmail","who_delegate_email":"WhoDelegateEmail","message":"Message"}]}`)
					} else if requestNumber == 2 {
						fmt.Fprintf(res, "%s", `{"total_count":2,"limit":1,"audits":[{"id":"ID","_rev":"Rev","created":"2019-01-01T12:00:00.000Z","change_type":"ChangeType","target_type":"TargetType","target_id":"TargetID","who_email":"WhoEmail","who_delegate_email":"WhoDelegateEmail","message":"Message"}]}`)
					} else {
						res.WriteHeader(400)
					}
				}))
			})
			It(`Use CatalogAccountAuditsPager.GetNext successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				listCatalogAccountAuditsOptionsModel := &catalogmanagementv1.ListCatalogAccountAuditsOptions{
					Limit: core.Int64Ptr(int64(10)),
					Lookupnames: core.BoolPtr(true),
				}

				pager, err := catalogManagementService.NewCatalogAccountAuditsPager(listCatalogAccountAuditsOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				var allResults []catalogmanagementv1.AuditLogDigest
				for pager.HasNext() {
					nextPage, err := pager.GetNext()
					Expect(err).To(BeNil())
					Expect(nextPage).ToNot(BeNil())
					allResults = append(allResults, nextPage...)
				}
				Expect(len(allResults)).To(Equal(2))
			})
			It(`Use CatalogAccountAuditsPager.GetAll successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				listCatalogAccountAuditsOptionsModel := &catalogmanagementv1.ListCatalogAccountAuditsOptions{
					Limit: core.Int64Ptr(int64(10)),
					Lookupnames: core.BoolPtr(true),
				}

				pager, err := catalogManagementService.NewCatalogAccountAuditsPager(listCatalogAccountAuditsOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				allResults, err := pager.GetAll()
				Expect(err).To(BeNil())
				Expect(allResults).ToNot(BeNil())
				Expect(len(allResults)).To(Equal(2))
			})
		})
	})
	Describe(`GetCatalogAccountAudit(getCatalogAccountAuditOptions *GetCatalogAccountAuditOptions) - Operation response error`, func() {
		getCatalogAccountAuditPath := "/catalogaccount/audits/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getCatalogAccountAuditPath))
					Expect(req.Method).To(Equal("GET"))
					// TODO: Add check for lookupnames query parameter
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetCatalogAccountAudit with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetCatalogAccountAuditOptions model
				getCatalogAccountAuditOptionsModel := new(catalogmanagementv1.GetCatalogAccountAuditOptions)
				getCatalogAccountAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getCatalogAccountAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getCatalogAccountAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetCatalogAccountAudit(getCatalogAccountAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetCatalogAccountAudit(getCatalogAccountAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetCatalogAccountAudit(getCatalogAccountAuditOptions *GetCatalogAccountAuditOptions)`, func() {
		getCatalogAccountAuditPath := "/catalogaccount/audits/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getCatalogAccountAuditPath))
					Expect(req.Method).To(Equal("GET"))

					// TODO: Add check for lookupnames query parameter
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message", "gid": "Gid", "who_id": "WhoID", "who_name": "WhoName", "who_delegate_id": "WhoDelegateID", "who_delegate_name": "WhoDelegateName", "data": "anyValue"}`)
				}))
			})
			It(`Invoke GetCatalogAccountAudit successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetCatalogAccountAuditOptions model
				getCatalogAccountAuditOptionsModel := new(catalogmanagementv1.GetCatalogAccountAuditOptions)
				getCatalogAccountAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getCatalogAccountAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getCatalogAccountAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetCatalogAccountAuditWithContext(ctx, getCatalogAccountAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetCatalogAccountAudit(getCatalogAccountAuditOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetCatalogAccountAuditWithContext(ctx, getCatalogAccountAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getCatalogAccountAuditPath))
					Expect(req.Method).To(Equal("GET"))

					// TODO: Add check for lookupnames query parameter
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message", "gid": "Gid", "who_id": "WhoID", "who_name": "WhoName", "who_delegate_id": "WhoDelegateID", "who_delegate_name": "WhoDelegateName", "data": "anyValue"}`)
				}))
			})
			It(`Invoke GetCatalogAccountAudit successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetCatalogAccountAudit(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetCatalogAccountAuditOptions model
				getCatalogAccountAuditOptionsModel := new(catalogmanagementv1.GetCatalogAccountAuditOptions)
				getCatalogAccountAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getCatalogAccountAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getCatalogAccountAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetCatalogAccountAudit(getCatalogAccountAuditOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetCatalogAccountAudit with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetCatalogAccountAuditOptions model
				getCatalogAccountAuditOptionsModel := new(catalogmanagementv1.GetCatalogAccountAuditOptions)
				getCatalogAccountAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getCatalogAccountAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getCatalogAccountAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetCatalogAccountAudit(getCatalogAccountAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetCatalogAccountAuditOptions model with no property values
				getCatalogAccountAuditOptionsModelNew := new(catalogmanagementv1.GetCatalogAccountAuditOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetCatalogAccountAudit(getCatalogAccountAuditOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetCatalogAccountAudit successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetCatalogAccountAuditOptions model
				getCatalogAccountAuditOptionsModel := new(catalogmanagementv1.GetCatalogAccountAuditOptions)
				getCatalogAccountAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getCatalogAccountAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getCatalogAccountAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetCatalogAccountAudit(getCatalogAccountAuditOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetCatalogAccountFilters(getCatalogAccountFiltersOptions *GetCatalogAccountFiltersOptions) - Operation response error`, func() {
		getCatalogAccountFiltersPath := "/catalogaccount/filters"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getCatalogAccountFiltersPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.URL.Query()["catalog"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetCatalogAccountFilters with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetCatalogAccountFiltersOptions model
				getCatalogAccountFiltersOptionsModel := new(catalogmanagementv1.GetCatalogAccountFiltersOptions)
				getCatalogAccountFiltersOptionsModel.Catalog = core.StringPtr("testString")
				getCatalogAccountFiltersOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetCatalogAccountFilters(getCatalogAccountFiltersOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetCatalogAccountFilters(getCatalogAccountFiltersOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetCatalogAccountFilters(getCatalogAccountFiltersOptions *GetCatalogAccountFiltersOptions)`, func() {
		getCatalogAccountFiltersPath := "/catalogaccount/filters"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getCatalogAccountFiltersPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["catalog"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"hide_IBM_cloud_catalog": false, "account_filters": [{"include_all": true, "category_filters": {"mapKey": {"include": false, "filter": {"filter_terms": ["FilterTerms"]}}}, "id_filters": {"include": {"filter_terms": ["FilterTerms"]}, "exclude": {"filter_terms": ["FilterTerms"]}}}], "catalog_filters": [{"catalog": {"id": "ID", "name": "Name"}, "filters": {"include_all": true, "category_filters": {"mapKey": {"include": false, "filter": {"filter_terms": ["FilterTerms"]}}}, "id_filters": {"include": {"filter_terms": ["FilterTerms"]}, "exclude": {"filter_terms": ["FilterTerms"]}}}}]}`)
				}))
			})
			It(`Invoke GetCatalogAccountFilters successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetCatalogAccountFiltersOptions model
				getCatalogAccountFiltersOptionsModel := new(catalogmanagementv1.GetCatalogAccountFiltersOptions)
				getCatalogAccountFiltersOptionsModel.Catalog = core.StringPtr("testString")
				getCatalogAccountFiltersOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetCatalogAccountFiltersWithContext(ctx, getCatalogAccountFiltersOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetCatalogAccountFilters(getCatalogAccountFiltersOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetCatalogAccountFiltersWithContext(ctx, getCatalogAccountFiltersOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getCatalogAccountFiltersPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["catalog"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"hide_IBM_cloud_catalog": false, "account_filters": [{"include_all": true, "category_filters": {"mapKey": {"include": false, "filter": {"filter_terms": ["FilterTerms"]}}}, "id_filters": {"include": {"filter_terms": ["FilterTerms"]}, "exclude": {"filter_terms": ["FilterTerms"]}}}], "catalog_filters": [{"catalog": {"id": "ID", "name": "Name"}, "filters": {"include_all": true, "category_filters": {"mapKey": {"include": false, "filter": {"filter_terms": ["FilterTerms"]}}}, "id_filters": {"include": {"filter_terms": ["FilterTerms"]}, "exclude": {"filter_terms": ["FilterTerms"]}}}}]}`)
				}))
			})
			It(`Invoke GetCatalogAccountFilters successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetCatalogAccountFilters(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetCatalogAccountFiltersOptions model
				getCatalogAccountFiltersOptionsModel := new(catalogmanagementv1.GetCatalogAccountFiltersOptions)
				getCatalogAccountFiltersOptionsModel.Catalog = core.StringPtr("testString")
				getCatalogAccountFiltersOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetCatalogAccountFilters(getCatalogAccountFiltersOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetCatalogAccountFilters with error: Operation request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetCatalogAccountFiltersOptions model
				getCatalogAccountFiltersOptionsModel := new(catalogmanagementv1.GetCatalogAccountFiltersOptions)
				getCatalogAccountFiltersOptionsModel.Catalog = core.StringPtr("testString")
				getCatalogAccountFiltersOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetCatalogAccountFilters(getCatalogAccountFiltersOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetCatalogAccountFilters successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetCatalogAccountFiltersOptions model
				getCatalogAccountFiltersOptionsModel := new(catalogmanagementv1.GetCatalogAccountFiltersOptions)
				getCatalogAccountFiltersOptionsModel.Catalog = core.StringPtr("testString")
				getCatalogAccountFiltersOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetCatalogAccountFilters(getCatalogAccountFiltersOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListCatalogs(listCatalogsOptions *ListCatalogsOptions) - Operation response error`, func() {
		listCatalogsPath := "/catalogs"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listCatalogsPath))
					Expect(req.Method).To(Equal("GET"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListCatalogs with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListCatalogsOptions model
				listCatalogsOptionsModel := new(catalogmanagementv1.ListCatalogsOptions)
				listCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.ListCatalogs(listCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.ListCatalogs(listCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListCatalogs(listCatalogsOptions *ListCatalogsOptions)`, func() {
		listCatalogsPath := "/catalogs"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listCatalogsPath))
					Expect(req.Method).To(Equal("GET"))

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"total_count": 10, "resources": [{"id": "ID", "_rev": "Rev", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "catalog_icon_url": "CatalogIconURL", "tags": ["Tags"], "url": "URL", "crn": "CRN", "offerings_url": "OfferingsURL", "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "disabled": true, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "resource_group_id": "ResourceGroupID", "owning_account": "OwningAccount", "catalog_filters": {"include_all": true, "category_filters": {"mapKey": {"include": false, "filter": {"filter_terms": ["FilterTerms"]}}}, "id_filters": {"include": {"filter_terms": ["FilterTerms"]}, "exclude": {"filter_terms": ["FilterTerms"]}}}, "syndication_settings": {"remove_related_components": false, "clusters": [{"region": "Region", "id": "ID", "name": "Name", "resource_group_name": "ResourceGroupName", "type": "Type", "namespaces": ["Namespaces"], "all_namespaces": false}], "history": {"namespaces": ["Namespaces"], "clusters": [{"region": "Region", "id": "ID", "name": "Name", "resource_group_name": "ResourceGroupName", "type": "Type", "namespaces": ["Namespaces"], "all_namespaces": false}], "last_run": "2019-01-01T12:00:00.000Z"}, "authorization": {"token": "Token", "last_run": "2019-01-01T12:00:00.000Z"}}, "kind": "Kind", "metadata": {"mapKey": "anyValue"}}]}`)
				}))
			})
			It(`Invoke ListCatalogs successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the ListCatalogsOptions model
				listCatalogsOptionsModel := new(catalogmanagementv1.ListCatalogsOptions)
				listCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.ListCatalogsWithContext(ctx, listCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.ListCatalogs(listCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.ListCatalogsWithContext(ctx, listCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listCatalogsPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"total_count": 10, "resources": [{"id": "ID", "_rev": "Rev", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "catalog_icon_url": "CatalogIconURL", "tags": ["Tags"], "url": "URL", "crn": "CRN", "offerings_url": "OfferingsURL", "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "disabled": true, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "resource_group_id": "ResourceGroupID", "owning_account": "OwningAccount", "catalog_filters": {"include_all": true, "category_filters": {"mapKey": {"include": false, "filter": {"filter_terms": ["FilterTerms"]}}}, "id_filters": {"include": {"filter_terms": ["FilterTerms"]}, "exclude": {"filter_terms": ["FilterTerms"]}}}, "syndication_settings": {"remove_related_components": false, "clusters": [{"region": "Region", "id": "ID", "name": "Name", "resource_group_name": "ResourceGroupName", "type": "Type", "namespaces": ["Namespaces"], "all_namespaces": false}], "history": {"namespaces": ["Namespaces"], "clusters": [{"region": "Region", "id": "ID", "name": "Name", "resource_group_name": "ResourceGroupName", "type": "Type", "namespaces": ["Namespaces"], "all_namespaces": false}], "last_run": "2019-01-01T12:00:00.000Z"}, "authorization": {"token": "Token", "last_run": "2019-01-01T12:00:00.000Z"}}, "kind": "Kind", "metadata": {"mapKey": "anyValue"}}]}`)
				}))
			})
			It(`Invoke ListCatalogs successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.ListCatalogs(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListCatalogsOptions model
				listCatalogsOptionsModel := new(catalogmanagementv1.ListCatalogsOptions)
				listCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.ListCatalogs(listCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListCatalogs with error: Operation request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListCatalogsOptions model
				listCatalogsOptionsModel := new(catalogmanagementv1.ListCatalogsOptions)
				listCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.ListCatalogs(listCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListCatalogs successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListCatalogsOptions model
				listCatalogsOptionsModel := new(catalogmanagementv1.ListCatalogsOptions)
				listCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.ListCatalogs(listCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateCatalog(createCatalogOptions *CreateCatalogOptions) - Operation response error`, func() {
		createCatalogPath := "/catalogs"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createCatalogPath))
					Expect(req.Method).To(Equal("POST"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateCatalog with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = make(map[string]string)
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = make(map[string]string)

				// Construct an instance of the FilterTerms model
				filterTermsModel := new(catalogmanagementv1.FilterTerms)
				filterTermsModel.FilterTerms = []string{"testString"}

				// Construct an instance of the CategoryFilter model
				categoryFilterModel := new(catalogmanagementv1.CategoryFilter)
				categoryFilterModel.Include = core.BoolPtr(true)
				categoryFilterModel.Filter = filterTermsModel

				// Construct an instance of the IDFilter model
				idFilterModel := new(catalogmanagementv1.IDFilter)
				idFilterModel.Include = filterTermsModel
				idFilterModel.Exclude = filterTermsModel

				// Construct an instance of the Filters model
				filtersModel := new(catalogmanagementv1.Filters)
				filtersModel.IncludeAll = core.BoolPtr(true)
				filtersModel.CategoryFilters = make(map[string]catalogmanagementv1.CategoryFilter)
				filtersModel.IDFilters = idFilterModel
				filtersModel.CategoryFilters["foo"] = *categoryFilterModel

				// Construct an instance of the SyndicationCluster model
				syndicationClusterModel := new(catalogmanagementv1.SyndicationCluster)
				syndicationClusterModel.Region = core.StringPtr("testString")
				syndicationClusterModel.ID = core.StringPtr("testString")
				syndicationClusterModel.Name = core.StringPtr("testString")
				syndicationClusterModel.ResourceGroupName = core.StringPtr("testString")
				syndicationClusterModel.Type = core.StringPtr("testString")
				syndicationClusterModel.Namespaces = []string{"testString"}
				syndicationClusterModel.AllNamespaces = core.BoolPtr(true)

				// Construct an instance of the SyndicationHistory model
				syndicationHistoryModel := new(catalogmanagementv1.SyndicationHistory)
				syndicationHistoryModel.Namespaces = []string{"testString"}
				syndicationHistoryModel.Clusters = []catalogmanagementv1.SyndicationCluster{*syndicationClusterModel}
				syndicationHistoryModel.LastRun = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the SyndicationAuthorization model
				syndicationAuthorizationModel := new(catalogmanagementv1.SyndicationAuthorization)
				syndicationAuthorizationModel.Token = core.StringPtr("testString")
				syndicationAuthorizationModel.LastRun = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the SyndicationResource model
				syndicationResourceModel := new(catalogmanagementv1.SyndicationResource)
				syndicationResourceModel.RemoveRelatedComponents = core.BoolPtr(true)
				syndicationResourceModel.Clusters = []catalogmanagementv1.SyndicationCluster{*syndicationClusterModel}
				syndicationResourceModel.History = syndicationHistoryModel
				syndicationResourceModel.Authorization = syndicationAuthorizationModel

				// Construct an instance of the CreateCatalogOptions model
				createCatalogOptionsModel := new(catalogmanagementv1.CreateCatalogOptions)
				createCatalogOptionsModel.ID = core.StringPtr("testString")
				createCatalogOptionsModel.Rev = core.StringPtr("testString")
				createCatalogOptionsModel.Label = core.StringPtr("testString")
				createCatalogOptionsModel.LabelI18n = make(map[string]string)
				createCatalogOptionsModel.ShortDescription = core.StringPtr("testString")
				createCatalogOptionsModel.ShortDescriptionI18n = make(map[string]string)
				createCatalogOptionsModel.CatalogIconURL = core.StringPtr("testString")
				createCatalogOptionsModel.Tags = []string{"testString"}
				createCatalogOptionsModel.Features = []catalogmanagementv1.Feature{*featureModel}
				createCatalogOptionsModel.Disabled = core.BoolPtr(true)
				createCatalogOptionsModel.ResourceGroupID = core.StringPtr("testString")
				createCatalogOptionsModel.OwningAccount = core.StringPtr("testString")
				createCatalogOptionsModel.CatalogFilters = filtersModel
				createCatalogOptionsModel.SyndicationSettings = syndicationResourceModel
				createCatalogOptionsModel.Kind = core.StringPtr("testString")
				createCatalogOptionsModel.Metadata = make(map[string]interface{})
				createCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.CreateCatalog(createCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.CreateCatalog(createCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateCatalog(createCatalogOptions *CreateCatalogOptions)`, func() {
		createCatalogPath := "/catalogs"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createCatalogPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "catalog_icon_url": "CatalogIconURL", "tags": ["Tags"], "url": "URL", "crn": "CRN", "offerings_url": "OfferingsURL", "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "disabled": true, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "resource_group_id": "ResourceGroupID", "owning_account": "OwningAccount", "catalog_filters": {"include_all": true, "category_filters": {"mapKey": {"include": false, "filter": {"filter_terms": ["FilterTerms"]}}}, "id_filters": {"include": {"filter_terms": ["FilterTerms"]}, "exclude": {"filter_terms": ["FilterTerms"]}}}, "syndication_settings": {"remove_related_components": false, "clusters": [{"region": "Region", "id": "ID", "name": "Name", "resource_group_name": "ResourceGroupName", "type": "Type", "namespaces": ["Namespaces"], "all_namespaces": false}], "history": {"namespaces": ["Namespaces"], "clusters": [{"region": "Region", "id": "ID", "name": "Name", "resource_group_name": "ResourceGroupName", "type": "Type", "namespaces": ["Namespaces"], "all_namespaces": false}], "last_run": "2019-01-01T12:00:00.000Z"}, "authorization": {"token": "Token", "last_run": "2019-01-01T12:00:00.000Z"}}, "kind": "Kind", "metadata": {"mapKey": "anyValue"}}`)
				}))
			})
			It(`Invoke CreateCatalog successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = make(map[string]string)
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = make(map[string]string)

				// Construct an instance of the FilterTerms model
				filterTermsModel := new(catalogmanagementv1.FilterTerms)
				filterTermsModel.FilterTerms = []string{"testString"}

				// Construct an instance of the CategoryFilter model
				categoryFilterModel := new(catalogmanagementv1.CategoryFilter)
				categoryFilterModel.Include = core.BoolPtr(true)
				categoryFilterModel.Filter = filterTermsModel

				// Construct an instance of the IDFilter model
				idFilterModel := new(catalogmanagementv1.IDFilter)
				idFilterModel.Include = filterTermsModel
				idFilterModel.Exclude = filterTermsModel

				// Construct an instance of the Filters model
				filtersModel := new(catalogmanagementv1.Filters)
				filtersModel.IncludeAll = core.BoolPtr(true)
				filtersModel.CategoryFilters = make(map[string]catalogmanagementv1.CategoryFilter)
				filtersModel.IDFilters = idFilterModel
				filtersModel.CategoryFilters["foo"] = *categoryFilterModel

				// Construct an instance of the SyndicationCluster model
				syndicationClusterModel := new(catalogmanagementv1.SyndicationCluster)
				syndicationClusterModel.Region = core.StringPtr("testString")
				syndicationClusterModel.ID = core.StringPtr("testString")
				syndicationClusterModel.Name = core.StringPtr("testString")
				syndicationClusterModel.ResourceGroupName = core.StringPtr("testString")
				syndicationClusterModel.Type = core.StringPtr("testString")
				syndicationClusterModel.Namespaces = []string{"testString"}
				syndicationClusterModel.AllNamespaces = core.BoolPtr(true)

				// Construct an instance of the SyndicationHistory model
				syndicationHistoryModel := new(catalogmanagementv1.SyndicationHistory)
				syndicationHistoryModel.Namespaces = []string{"testString"}
				syndicationHistoryModel.Clusters = []catalogmanagementv1.SyndicationCluster{*syndicationClusterModel}
				syndicationHistoryModel.LastRun = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the SyndicationAuthorization model
				syndicationAuthorizationModel := new(catalogmanagementv1.SyndicationAuthorization)
				syndicationAuthorizationModel.Token = core.StringPtr("testString")
				syndicationAuthorizationModel.LastRun = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the SyndicationResource model
				syndicationResourceModel := new(catalogmanagementv1.SyndicationResource)
				syndicationResourceModel.RemoveRelatedComponents = core.BoolPtr(true)
				syndicationResourceModel.Clusters = []catalogmanagementv1.SyndicationCluster{*syndicationClusterModel}
				syndicationResourceModel.History = syndicationHistoryModel
				syndicationResourceModel.Authorization = syndicationAuthorizationModel

				// Construct an instance of the CreateCatalogOptions model
				createCatalogOptionsModel := new(catalogmanagementv1.CreateCatalogOptions)
				createCatalogOptionsModel.ID = core.StringPtr("testString")
				createCatalogOptionsModel.Rev = core.StringPtr("testString")
				createCatalogOptionsModel.Label = core.StringPtr("testString")
				createCatalogOptionsModel.LabelI18n = make(map[string]string)
				createCatalogOptionsModel.ShortDescription = core.StringPtr("testString")
				createCatalogOptionsModel.ShortDescriptionI18n = make(map[string]string)
				createCatalogOptionsModel.CatalogIconURL = core.StringPtr("testString")
				createCatalogOptionsModel.Tags = []string{"testString"}
				createCatalogOptionsModel.Features = []catalogmanagementv1.Feature{*featureModel}
				createCatalogOptionsModel.Disabled = core.BoolPtr(true)
				createCatalogOptionsModel.ResourceGroupID = core.StringPtr("testString")
				createCatalogOptionsModel.OwningAccount = core.StringPtr("testString")
				createCatalogOptionsModel.CatalogFilters = filtersModel
				createCatalogOptionsModel.SyndicationSettings = syndicationResourceModel
				createCatalogOptionsModel.Kind = core.StringPtr("testString")
				createCatalogOptionsModel.Metadata = make(map[string]interface{})
				createCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.CreateCatalogWithContext(ctx, createCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.CreateCatalog(createCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.CreateCatalogWithContext(ctx, createCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createCatalogPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "catalog_icon_url": "CatalogIconURL", "tags": ["Tags"], "url": "URL", "crn": "CRN", "offerings_url": "OfferingsURL", "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "disabled": true, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "resource_group_id": "ResourceGroupID", "owning_account": "OwningAccount", "catalog_filters": {"include_all": true, "category_filters": {"mapKey": {"include": false, "filter": {"filter_terms": ["FilterTerms"]}}}, "id_filters": {"include": {"filter_terms": ["FilterTerms"]}, "exclude": {"filter_terms": ["FilterTerms"]}}}, "syndication_settings": {"remove_related_components": false, "clusters": [{"region": "Region", "id": "ID", "name": "Name", "resource_group_name": "ResourceGroupName", "type": "Type", "namespaces": ["Namespaces"], "all_namespaces": false}], "history": {"namespaces": ["Namespaces"], "clusters": [{"region": "Region", "id": "ID", "name": "Name", "resource_group_name": "ResourceGroupName", "type": "Type", "namespaces": ["Namespaces"], "all_namespaces": false}], "last_run": "2019-01-01T12:00:00.000Z"}, "authorization": {"token": "Token", "last_run": "2019-01-01T12:00:00.000Z"}}, "kind": "Kind", "metadata": {"mapKey": "anyValue"}}`)
				}))
			})
			It(`Invoke CreateCatalog successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.CreateCatalog(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = make(map[string]string)
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = make(map[string]string)

				// Construct an instance of the FilterTerms model
				filterTermsModel := new(catalogmanagementv1.FilterTerms)
				filterTermsModel.FilterTerms = []string{"testString"}

				// Construct an instance of the CategoryFilter model
				categoryFilterModel := new(catalogmanagementv1.CategoryFilter)
				categoryFilterModel.Include = core.BoolPtr(true)
				categoryFilterModel.Filter = filterTermsModel

				// Construct an instance of the IDFilter model
				idFilterModel := new(catalogmanagementv1.IDFilter)
				idFilterModel.Include = filterTermsModel
				idFilterModel.Exclude = filterTermsModel

				// Construct an instance of the Filters model
				filtersModel := new(catalogmanagementv1.Filters)
				filtersModel.IncludeAll = core.BoolPtr(true)
				filtersModel.CategoryFilters = make(map[string]catalogmanagementv1.CategoryFilter)
				filtersModel.IDFilters = idFilterModel
				filtersModel.CategoryFilters["foo"] = *categoryFilterModel

				// Construct an instance of the SyndicationCluster model
				syndicationClusterModel := new(catalogmanagementv1.SyndicationCluster)
				syndicationClusterModel.Region = core.StringPtr("testString")
				syndicationClusterModel.ID = core.StringPtr("testString")
				syndicationClusterModel.Name = core.StringPtr("testString")
				syndicationClusterModel.ResourceGroupName = core.StringPtr("testString")
				syndicationClusterModel.Type = core.StringPtr("testString")
				syndicationClusterModel.Namespaces = []string{"testString"}
				syndicationClusterModel.AllNamespaces = core.BoolPtr(true)

				// Construct an instance of the SyndicationHistory model
				syndicationHistoryModel := new(catalogmanagementv1.SyndicationHistory)
				syndicationHistoryModel.Namespaces = []string{"testString"}
				syndicationHistoryModel.Clusters = []catalogmanagementv1.SyndicationCluster{*syndicationClusterModel}
				syndicationHistoryModel.LastRun = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the SyndicationAuthorization model
				syndicationAuthorizationModel := new(catalogmanagementv1.SyndicationAuthorization)
				syndicationAuthorizationModel.Token = core.StringPtr("testString")
				syndicationAuthorizationModel.LastRun = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the SyndicationResource model
				syndicationResourceModel := new(catalogmanagementv1.SyndicationResource)
				syndicationResourceModel.RemoveRelatedComponents = core.BoolPtr(true)
				syndicationResourceModel.Clusters = []catalogmanagementv1.SyndicationCluster{*syndicationClusterModel}
				syndicationResourceModel.History = syndicationHistoryModel
				syndicationResourceModel.Authorization = syndicationAuthorizationModel

				// Construct an instance of the CreateCatalogOptions model
				createCatalogOptionsModel := new(catalogmanagementv1.CreateCatalogOptions)
				createCatalogOptionsModel.ID = core.StringPtr("testString")
				createCatalogOptionsModel.Rev = core.StringPtr("testString")
				createCatalogOptionsModel.Label = core.StringPtr("testString")
				createCatalogOptionsModel.LabelI18n = make(map[string]string)
				createCatalogOptionsModel.ShortDescription = core.StringPtr("testString")
				createCatalogOptionsModel.ShortDescriptionI18n = make(map[string]string)
				createCatalogOptionsModel.CatalogIconURL = core.StringPtr("testString")
				createCatalogOptionsModel.Tags = []string{"testString"}
				createCatalogOptionsModel.Features = []catalogmanagementv1.Feature{*featureModel}
				createCatalogOptionsModel.Disabled = core.BoolPtr(true)
				createCatalogOptionsModel.ResourceGroupID = core.StringPtr("testString")
				createCatalogOptionsModel.OwningAccount = core.StringPtr("testString")
				createCatalogOptionsModel.CatalogFilters = filtersModel
				createCatalogOptionsModel.SyndicationSettings = syndicationResourceModel
				createCatalogOptionsModel.Kind = core.StringPtr("testString")
				createCatalogOptionsModel.Metadata = make(map[string]interface{})
				createCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.CreateCatalog(createCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateCatalog with error: Operation request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = make(map[string]string)
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = make(map[string]string)

				// Construct an instance of the FilterTerms model
				filterTermsModel := new(catalogmanagementv1.FilterTerms)
				filterTermsModel.FilterTerms = []string{"testString"}

				// Construct an instance of the CategoryFilter model
				categoryFilterModel := new(catalogmanagementv1.CategoryFilter)
				categoryFilterModel.Include = core.BoolPtr(true)
				categoryFilterModel.Filter = filterTermsModel

				// Construct an instance of the IDFilter model
				idFilterModel := new(catalogmanagementv1.IDFilter)
				idFilterModel.Include = filterTermsModel
				idFilterModel.Exclude = filterTermsModel

				// Construct an instance of the Filters model
				filtersModel := new(catalogmanagementv1.Filters)
				filtersModel.IncludeAll = core.BoolPtr(true)
				filtersModel.CategoryFilters = make(map[string]catalogmanagementv1.CategoryFilter)
				filtersModel.IDFilters = idFilterModel
				filtersModel.CategoryFilters["foo"] = *categoryFilterModel

				// Construct an instance of the SyndicationCluster model
				syndicationClusterModel := new(catalogmanagementv1.SyndicationCluster)
				syndicationClusterModel.Region = core.StringPtr("testString")
				syndicationClusterModel.ID = core.StringPtr("testString")
				syndicationClusterModel.Name = core.StringPtr("testString")
				syndicationClusterModel.ResourceGroupName = core.StringPtr("testString")
				syndicationClusterModel.Type = core.StringPtr("testString")
				syndicationClusterModel.Namespaces = []string{"testString"}
				syndicationClusterModel.AllNamespaces = core.BoolPtr(true)

				// Construct an instance of the SyndicationHistory model
				syndicationHistoryModel := new(catalogmanagementv1.SyndicationHistory)
				syndicationHistoryModel.Namespaces = []string{"testString"}
				syndicationHistoryModel.Clusters = []catalogmanagementv1.SyndicationCluster{*syndicationClusterModel}
				syndicationHistoryModel.LastRun = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the SyndicationAuthorization model
				syndicationAuthorizationModel := new(catalogmanagementv1.SyndicationAuthorization)
				syndicationAuthorizationModel.Token = core.StringPtr("testString")
				syndicationAuthorizationModel.LastRun = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the SyndicationResource model
				syndicationResourceModel := new(catalogmanagementv1.SyndicationResource)
				syndicationResourceModel.RemoveRelatedComponents = core.BoolPtr(true)
				syndicationResourceModel.Clusters = []catalogmanagementv1.SyndicationCluster{*syndicationClusterModel}
				syndicationResourceModel.History = syndicationHistoryModel
				syndicationResourceModel.Authorization = syndicationAuthorizationModel

				// Construct an instance of the CreateCatalogOptions model
				createCatalogOptionsModel := new(catalogmanagementv1.CreateCatalogOptions)
				createCatalogOptionsModel.ID = core.StringPtr("testString")
				createCatalogOptionsModel.Rev = core.StringPtr("testString")
				createCatalogOptionsModel.Label = core.StringPtr("testString")
				createCatalogOptionsModel.LabelI18n = make(map[string]string)
				createCatalogOptionsModel.ShortDescription = core.StringPtr("testString")
				createCatalogOptionsModel.ShortDescriptionI18n = make(map[string]string)
				createCatalogOptionsModel.CatalogIconURL = core.StringPtr("testString")
				createCatalogOptionsModel.Tags = []string{"testString"}
				createCatalogOptionsModel.Features = []catalogmanagementv1.Feature{*featureModel}
				createCatalogOptionsModel.Disabled = core.BoolPtr(true)
				createCatalogOptionsModel.ResourceGroupID = core.StringPtr("testString")
				createCatalogOptionsModel.OwningAccount = core.StringPtr("testString")
				createCatalogOptionsModel.CatalogFilters = filtersModel
				createCatalogOptionsModel.SyndicationSettings = syndicationResourceModel
				createCatalogOptionsModel.Kind = core.StringPtr("testString")
				createCatalogOptionsModel.Metadata = make(map[string]interface{})
				createCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.CreateCatalog(createCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreateCatalog successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = make(map[string]string)
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = make(map[string]string)

				// Construct an instance of the FilterTerms model
				filterTermsModel := new(catalogmanagementv1.FilterTerms)
				filterTermsModel.FilterTerms = []string{"testString"}

				// Construct an instance of the CategoryFilter model
				categoryFilterModel := new(catalogmanagementv1.CategoryFilter)
				categoryFilterModel.Include = core.BoolPtr(true)
				categoryFilterModel.Filter = filterTermsModel

				// Construct an instance of the IDFilter model
				idFilterModel := new(catalogmanagementv1.IDFilter)
				idFilterModel.Include = filterTermsModel
				idFilterModel.Exclude = filterTermsModel

				// Construct an instance of the Filters model
				filtersModel := new(catalogmanagementv1.Filters)
				filtersModel.IncludeAll = core.BoolPtr(true)
				filtersModel.CategoryFilters = make(map[string]catalogmanagementv1.CategoryFilter)
				filtersModel.IDFilters = idFilterModel
				filtersModel.CategoryFilters["foo"] = *categoryFilterModel

				// Construct an instance of the SyndicationCluster model
				syndicationClusterModel := new(catalogmanagementv1.SyndicationCluster)
				syndicationClusterModel.Region = core.StringPtr("testString")
				syndicationClusterModel.ID = core.StringPtr("testString")
				syndicationClusterModel.Name = core.StringPtr("testString")
				syndicationClusterModel.ResourceGroupName = core.StringPtr("testString")
				syndicationClusterModel.Type = core.StringPtr("testString")
				syndicationClusterModel.Namespaces = []string{"testString"}
				syndicationClusterModel.AllNamespaces = core.BoolPtr(true)

				// Construct an instance of the SyndicationHistory model
				syndicationHistoryModel := new(catalogmanagementv1.SyndicationHistory)
				syndicationHistoryModel.Namespaces = []string{"testString"}
				syndicationHistoryModel.Clusters = []catalogmanagementv1.SyndicationCluster{*syndicationClusterModel}
				syndicationHistoryModel.LastRun = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the SyndicationAuthorization model
				syndicationAuthorizationModel := new(catalogmanagementv1.SyndicationAuthorization)
				syndicationAuthorizationModel.Token = core.StringPtr("testString")
				syndicationAuthorizationModel.LastRun = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the SyndicationResource model
				syndicationResourceModel := new(catalogmanagementv1.SyndicationResource)
				syndicationResourceModel.RemoveRelatedComponents = core.BoolPtr(true)
				syndicationResourceModel.Clusters = []catalogmanagementv1.SyndicationCluster{*syndicationClusterModel}
				syndicationResourceModel.History = syndicationHistoryModel
				syndicationResourceModel.Authorization = syndicationAuthorizationModel

				// Construct an instance of the CreateCatalogOptions model
				createCatalogOptionsModel := new(catalogmanagementv1.CreateCatalogOptions)
				createCatalogOptionsModel.ID = core.StringPtr("testString")
				createCatalogOptionsModel.Rev = core.StringPtr("testString")
				createCatalogOptionsModel.Label = core.StringPtr("testString")
				createCatalogOptionsModel.LabelI18n = make(map[string]string)
				createCatalogOptionsModel.ShortDescription = core.StringPtr("testString")
				createCatalogOptionsModel.ShortDescriptionI18n = make(map[string]string)
				createCatalogOptionsModel.CatalogIconURL = core.StringPtr("testString")
				createCatalogOptionsModel.Tags = []string{"testString"}
				createCatalogOptionsModel.Features = []catalogmanagementv1.Feature{*featureModel}
				createCatalogOptionsModel.Disabled = core.BoolPtr(true)
				createCatalogOptionsModel.ResourceGroupID = core.StringPtr("testString")
				createCatalogOptionsModel.OwningAccount = core.StringPtr("testString")
				createCatalogOptionsModel.CatalogFilters = filtersModel
				createCatalogOptionsModel.SyndicationSettings = syndicationResourceModel
				createCatalogOptionsModel.Kind = core.StringPtr("testString")
				createCatalogOptionsModel.Metadata = make(map[string]interface{})
				createCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.CreateCatalog(createCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetCatalog(getCatalogOptions *GetCatalogOptions) - Operation response error`, func() {
		getCatalogPath := "/catalogs/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getCatalogPath))
					Expect(req.Method).To(Equal("GET"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetCatalog with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetCatalogOptions model
				getCatalogOptionsModel := new(catalogmanagementv1.GetCatalogOptions)
				getCatalogOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetCatalog(getCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetCatalog(getCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetCatalog(getCatalogOptions *GetCatalogOptions)`, func() {
		getCatalogPath := "/catalogs/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getCatalogPath))
					Expect(req.Method).To(Equal("GET"))

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "catalog_icon_url": "CatalogIconURL", "tags": ["Tags"], "url": "URL", "crn": "CRN", "offerings_url": "OfferingsURL", "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "disabled": true, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "resource_group_id": "ResourceGroupID", "owning_account": "OwningAccount", "catalog_filters": {"include_all": true, "category_filters": {"mapKey": {"include": false, "filter": {"filter_terms": ["FilterTerms"]}}}, "id_filters": {"include": {"filter_terms": ["FilterTerms"]}, "exclude": {"filter_terms": ["FilterTerms"]}}}, "syndication_settings": {"remove_related_components": false, "clusters": [{"region": "Region", "id": "ID", "name": "Name", "resource_group_name": "ResourceGroupName", "type": "Type", "namespaces": ["Namespaces"], "all_namespaces": false}], "history": {"namespaces": ["Namespaces"], "clusters": [{"region": "Region", "id": "ID", "name": "Name", "resource_group_name": "ResourceGroupName", "type": "Type", "namespaces": ["Namespaces"], "all_namespaces": false}], "last_run": "2019-01-01T12:00:00.000Z"}, "authorization": {"token": "Token", "last_run": "2019-01-01T12:00:00.000Z"}}, "kind": "Kind", "metadata": {"mapKey": "anyValue"}}`)
				}))
			})
			It(`Invoke GetCatalog successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetCatalogOptions model
				getCatalogOptionsModel := new(catalogmanagementv1.GetCatalogOptions)
				getCatalogOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetCatalogWithContext(ctx, getCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetCatalog(getCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetCatalogWithContext(ctx, getCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getCatalogPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "catalog_icon_url": "CatalogIconURL", "tags": ["Tags"], "url": "URL", "crn": "CRN", "offerings_url": "OfferingsURL", "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "disabled": true, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "resource_group_id": "ResourceGroupID", "owning_account": "OwningAccount", "catalog_filters": {"include_all": true, "category_filters": {"mapKey": {"include": false, "filter": {"filter_terms": ["FilterTerms"]}}}, "id_filters": {"include": {"filter_terms": ["FilterTerms"]}, "exclude": {"filter_terms": ["FilterTerms"]}}}, "syndication_settings": {"remove_related_components": false, "clusters": [{"region": "Region", "id": "ID", "name": "Name", "resource_group_name": "ResourceGroupName", "type": "Type", "namespaces": ["Namespaces"], "all_namespaces": false}], "history": {"namespaces": ["Namespaces"], "clusters": [{"region": "Region", "id": "ID", "name": "Name", "resource_group_name": "ResourceGroupName", "type": "Type", "namespaces": ["Namespaces"], "all_namespaces": false}], "last_run": "2019-01-01T12:00:00.000Z"}, "authorization": {"token": "Token", "last_run": "2019-01-01T12:00:00.000Z"}}, "kind": "Kind", "metadata": {"mapKey": "anyValue"}}`)
				}))
			})
			It(`Invoke GetCatalog successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetCatalog(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetCatalogOptions model
				getCatalogOptionsModel := new(catalogmanagementv1.GetCatalogOptions)
				getCatalogOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetCatalog(getCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetCatalog with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetCatalogOptions model
				getCatalogOptionsModel := new(catalogmanagementv1.GetCatalogOptions)
				getCatalogOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetCatalog(getCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetCatalogOptions model with no property values
				getCatalogOptionsModelNew := new(catalogmanagementv1.GetCatalogOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetCatalog(getCatalogOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetCatalog successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetCatalogOptions model
				getCatalogOptionsModel := new(catalogmanagementv1.GetCatalogOptions)
				getCatalogOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetCatalog(getCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ReplaceCatalog(replaceCatalogOptions *ReplaceCatalogOptions) - Operation response error`, func() {
		replaceCatalogPath := "/catalogs/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(replaceCatalogPath))
					Expect(req.Method).To(Equal("PUT"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ReplaceCatalog with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = make(map[string]string)
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = make(map[string]string)

				// Construct an instance of the FilterTerms model
				filterTermsModel := new(catalogmanagementv1.FilterTerms)
				filterTermsModel.FilterTerms = []string{"testString"}

				// Construct an instance of the CategoryFilter model
				categoryFilterModel := new(catalogmanagementv1.CategoryFilter)
				categoryFilterModel.Include = core.BoolPtr(true)
				categoryFilterModel.Filter = filterTermsModel

				// Construct an instance of the IDFilter model
				idFilterModel := new(catalogmanagementv1.IDFilter)
				idFilterModel.Include = filterTermsModel
				idFilterModel.Exclude = filterTermsModel

				// Construct an instance of the Filters model
				filtersModel := new(catalogmanagementv1.Filters)
				filtersModel.IncludeAll = core.BoolPtr(true)
				filtersModel.CategoryFilters = make(map[string]catalogmanagementv1.CategoryFilter)
				filtersModel.IDFilters = idFilterModel
				filtersModel.CategoryFilters["foo"] = *categoryFilterModel

				// Construct an instance of the SyndicationCluster model
				syndicationClusterModel := new(catalogmanagementv1.SyndicationCluster)
				syndicationClusterModel.Region = core.StringPtr("testString")
				syndicationClusterModel.ID = core.StringPtr("testString")
				syndicationClusterModel.Name = core.StringPtr("testString")
				syndicationClusterModel.ResourceGroupName = core.StringPtr("testString")
				syndicationClusterModel.Type = core.StringPtr("testString")
				syndicationClusterModel.Namespaces = []string{"testString"}
				syndicationClusterModel.AllNamespaces = core.BoolPtr(true)

				// Construct an instance of the SyndicationHistory model
				syndicationHistoryModel := new(catalogmanagementv1.SyndicationHistory)
				syndicationHistoryModel.Namespaces = []string{"testString"}
				syndicationHistoryModel.Clusters = []catalogmanagementv1.SyndicationCluster{*syndicationClusterModel}
				syndicationHistoryModel.LastRun = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the SyndicationAuthorization model
				syndicationAuthorizationModel := new(catalogmanagementv1.SyndicationAuthorization)
				syndicationAuthorizationModel.Token = core.StringPtr("testString")
				syndicationAuthorizationModel.LastRun = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the SyndicationResource model
				syndicationResourceModel := new(catalogmanagementv1.SyndicationResource)
				syndicationResourceModel.RemoveRelatedComponents = core.BoolPtr(true)
				syndicationResourceModel.Clusters = []catalogmanagementv1.SyndicationCluster{*syndicationClusterModel}
				syndicationResourceModel.History = syndicationHistoryModel
				syndicationResourceModel.Authorization = syndicationAuthorizationModel

				// Construct an instance of the ReplaceCatalogOptions model
				replaceCatalogOptionsModel := new(catalogmanagementv1.ReplaceCatalogOptions)
				replaceCatalogOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				replaceCatalogOptionsModel.ID = core.StringPtr("testString")
				replaceCatalogOptionsModel.Rev = core.StringPtr("testString")
				replaceCatalogOptionsModel.Label = core.StringPtr("testString")
				replaceCatalogOptionsModel.LabelI18n = make(map[string]string)
				replaceCatalogOptionsModel.ShortDescription = core.StringPtr("testString")
				replaceCatalogOptionsModel.ShortDescriptionI18n = make(map[string]string)
				replaceCatalogOptionsModel.CatalogIconURL = core.StringPtr("testString")
				replaceCatalogOptionsModel.Tags = []string{"testString"}
				replaceCatalogOptionsModel.Features = []catalogmanagementv1.Feature{*featureModel}
				replaceCatalogOptionsModel.Disabled = core.BoolPtr(true)
				replaceCatalogOptionsModel.ResourceGroupID = core.StringPtr("testString")
				replaceCatalogOptionsModel.OwningAccount = core.StringPtr("testString")
				replaceCatalogOptionsModel.CatalogFilters = filtersModel
				replaceCatalogOptionsModel.SyndicationSettings = syndicationResourceModel
				replaceCatalogOptionsModel.Kind = core.StringPtr("testString")
				replaceCatalogOptionsModel.Metadata = make(map[string]interface{})
				replaceCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.ReplaceCatalog(replaceCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.ReplaceCatalog(replaceCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ReplaceCatalog(replaceCatalogOptions *ReplaceCatalogOptions)`, func() {
		replaceCatalogPath := "/catalogs/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(replaceCatalogPath))
					Expect(req.Method).To(Equal("PUT"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "catalog_icon_url": "CatalogIconURL", "tags": ["Tags"], "url": "URL", "crn": "CRN", "offerings_url": "OfferingsURL", "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "disabled": true, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "resource_group_id": "ResourceGroupID", "owning_account": "OwningAccount", "catalog_filters": {"include_all": true, "category_filters": {"mapKey": {"include": false, "filter": {"filter_terms": ["FilterTerms"]}}}, "id_filters": {"include": {"filter_terms": ["FilterTerms"]}, "exclude": {"filter_terms": ["FilterTerms"]}}}, "syndication_settings": {"remove_related_components": false, "clusters": [{"region": "Region", "id": "ID", "name": "Name", "resource_group_name": "ResourceGroupName", "type": "Type", "namespaces": ["Namespaces"], "all_namespaces": false}], "history": {"namespaces": ["Namespaces"], "clusters": [{"region": "Region", "id": "ID", "name": "Name", "resource_group_name": "ResourceGroupName", "type": "Type", "namespaces": ["Namespaces"], "all_namespaces": false}], "last_run": "2019-01-01T12:00:00.000Z"}, "authorization": {"token": "Token", "last_run": "2019-01-01T12:00:00.000Z"}}, "kind": "Kind", "metadata": {"mapKey": "anyValue"}}`)
				}))
			})
			It(`Invoke ReplaceCatalog successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = make(map[string]string)
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = make(map[string]string)

				// Construct an instance of the FilterTerms model
				filterTermsModel := new(catalogmanagementv1.FilterTerms)
				filterTermsModel.FilterTerms = []string{"testString"}

				// Construct an instance of the CategoryFilter model
				categoryFilterModel := new(catalogmanagementv1.CategoryFilter)
				categoryFilterModel.Include = core.BoolPtr(true)
				categoryFilterModel.Filter = filterTermsModel

				// Construct an instance of the IDFilter model
				idFilterModel := new(catalogmanagementv1.IDFilter)
				idFilterModel.Include = filterTermsModel
				idFilterModel.Exclude = filterTermsModel

				// Construct an instance of the Filters model
				filtersModel := new(catalogmanagementv1.Filters)
				filtersModel.IncludeAll = core.BoolPtr(true)
				filtersModel.CategoryFilters = make(map[string]catalogmanagementv1.CategoryFilter)
				filtersModel.IDFilters = idFilterModel
				filtersModel.CategoryFilters["foo"] = *categoryFilterModel

				// Construct an instance of the SyndicationCluster model
				syndicationClusterModel := new(catalogmanagementv1.SyndicationCluster)
				syndicationClusterModel.Region = core.StringPtr("testString")
				syndicationClusterModel.ID = core.StringPtr("testString")
				syndicationClusterModel.Name = core.StringPtr("testString")
				syndicationClusterModel.ResourceGroupName = core.StringPtr("testString")
				syndicationClusterModel.Type = core.StringPtr("testString")
				syndicationClusterModel.Namespaces = []string{"testString"}
				syndicationClusterModel.AllNamespaces = core.BoolPtr(true)

				// Construct an instance of the SyndicationHistory model
				syndicationHistoryModel := new(catalogmanagementv1.SyndicationHistory)
				syndicationHistoryModel.Namespaces = []string{"testString"}
				syndicationHistoryModel.Clusters = []catalogmanagementv1.SyndicationCluster{*syndicationClusterModel}
				syndicationHistoryModel.LastRun = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the SyndicationAuthorization model
				syndicationAuthorizationModel := new(catalogmanagementv1.SyndicationAuthorization)
				syndicationAuthorizationModel.Token = core.StringPtr("testString")
				syndicationAuthorizationModel.LastRun = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the SyndicationResource model
				syndicationResourceModel := new(catalogmanagementv1.SyndicationResource)
				syndicationResourceModel.RemoveRelatedComponents = core.BoolPtr(true)
				syndicationResourceModel.Clusters = []catalogmanagementv1.SyndicationCluster{*syndicationClusterModel}
				syndicationResourceModel.History = syndicationHistoryModel
				syndicationResourceModel.Authorization = syndicationAuthorizationModel

				// Construct an instance of the ReplaceCatalogOptions model
				replaceCatalogOptionsModel := new(catalogmanagementv1.ReplaceCatalogOptions)
				replaceCatalogOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				replaceCatalogOptionsModel.ID = core.StringPtr("testString")
				replaceCatalogOptionsModel.Rev = core.StringPtr("testString")
				replaceCatalogOptionsModel.Label = core.StringPtr("testString")
				replaceCatalogOptionsModel.LabelI18n = make(map[string]string)
				replaceCatalogOptionsModel.ShortDescription = core.StringPtr("testString")
				replaceCatalogOptionsModel.ShortDescriptionI18n = make(map[string]string)
				replaceCatalogOptionsModel.CatalogIconURL = core.StringPtr("testString")
				replaceCatalogOptionsModel.Tags = []string{"testString"}
				replaceCatalogOptionsModel.Features = []catalogmanagementv1.Feature{*featureModel}
				replaceCatalogOptionsModel.Disabled = core.BoolPtr(true)
				replaceCatalogOptionsModel.ResourceGroupID = core.StringPtr("testString")
				replaceCatalogOptionsModel.OwningAccount = core.StringPtr("testString")
				replaceCatalogOptionsModel.CatalogFilters = filtersModel
				replaceCatalogOptionsModel.SyndicationSettings = syndicationResourceModel
				replaceCatalogOptionsModel.Kind = core.StringPtr("testString")
				replaceCatalogOptionsModel.Metadata = make(map[string]interface{})
				replaceCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.ReplaceCatalogWithContext(ctx, replaceCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.ReplaceCatalog(replaceCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.ReplaceCatalogWithContext(ctx, replaceCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(replaceCatalogPath))
					Expect(req.Method).To(Equal("PUT"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "catalog_icon_url": "CatalogIconURL", "tags": ["Tags"], "url": "URL", "crn": "CRN", "offerings_url": "OfferingsURL", "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "disabled": true, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "resource_group_id": "ResourceGroupID", "owning_account": "OwningAccount", "catalog_filters": {"include_all": true, "category_filters": {"mapKey": {"include": false, "filter": {"filter_terms": ["FilterTerms"]}}}, "id_filters": {"include": {"filter_terms": ["FilterTerms"]}, "exclude": {"filter_terms": ["FilterTerms"]}}}, "syndication_settings": {"remove_related_components": false, "clusters": [{"region": "Region", "id": "ID", "name": "Name", "resource_group_name": "ResourceGroupName", "type": "Type", "namespaces": ["Namespaces"], "all_namespaces": false}], "history": {"namespaces": ["Namespaces"], "clusters": [{"region": "Region", "id": "ID", "name": "Name", "resource_group_name": "ResourceGroupName", "type": "Type", "namespaces": ["Namespaces"], "all_namespaces": false}], "last_run": "2019-01-01T12:00:00.000Z"}, "authorization": {"token": "Token", "last_run": "2019-01-01T12:00:00.000Z"}}, "kind": "Kind", "metadata": {"mapKey": "anyValue"}}`)
				}))
			})
			It(`Invoke ReplaceCatalog successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.ReplaceCatalog(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = make(map[string]string)
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = make(map[string]string)

				// Construct an instance of the FilterTerms model
				filterTermsModel := new(catalogmanagementv1.FilterTerms)
				filterTermsModel.FilterTerms = []string{"testString"}

				// Construct an instance of the CategoryFilter model
				categoryFilterModel := new(catalogmanagementv1.CategoryFilter)
				categoryFilterModel.Include = core.BoolPtr(true)
				categoryFilterModel.Filter = filterTermsModel

				// Construct an instance of the IDFilter model
				idFilterModel := new(catalogmanagementv1.IDFilter)
				idFilterModel.Include = filterTermsModel
				idFilterModel.Exclude = filterTermsModel

				// Construct an instance of the Filters model
				filtersModel := new(catalogmanagementv1.Filters)
				filtersModel.IncludeAll = core.BoolPtr(true)
				filtersModel.CategoryFilters = make(map[string]catalogmanagementv1.CategoryFilter)
				filtersModel.IDFilters = idFilterModel
				filtersModel.CategoryFilters["foo"] = *categoryFilterModel

				// Construct an instance of the SyndicationCluster model
				syndicationClusterModel := new(catalogmanagementv1.SyndicationCluster)
				syndicationClusterModel.Region = core.StringPtr("testString")
				syndicationClusterModel.ID = core.StringPtr("testString")
				syndicationClusterModel.Name = core.StringPtr("testString")
				syndicationClusterModel.ResourceGroupName = core.StringPtr("testString")
				syndicationClusterModel.Type = core.StringPtr("testString")
				syndicationClusterModel.Namespaces = []string{"testString"}
				syndicationClusterModel.AllNamespaces = core.BoolPtr(true)

				// Construct an instance of the SyndicationHistory model
				syndicationHistoryModel := new(catalogmanagementv1.SyndicationHistory)
				syndicationHistoryModel.Namespaces = []string{"testString"}
				syndicationHistoryModel.Clusters = []catalogmanagementv1.SyndicationCluster{*syndicationClusterModel}
				syndicationHistoryModel.LastRun = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the SyndicationAuthorization model
				syndicationAuthorizationModel := new(catalogmanagementv1.SyndicationAuthorization)
				syndicationAuthorizationModel.Token = core.StringPtr("testString")
				syndicationAuthorizationModel.LastRun = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the SyndicationResource model
				syndicationResourceModel := new(catalogmanagementv1.SyndicationResource)
				syndicationResourceModel.RemoveRelatedComponents = core.BoolPtr(true)
				syndicationResourceModel.Clusters = []catalogmanagementv1.SyndicationCluster{*syndicationClusterModel}
				syndicationResourceModel.History = syndicationHistoryModel
				syndicationResourceModel.Authorization = syndicationAuthorizationModel

				// Construct an instance of the ReplaceCatalogOptions model
				replaceCatalogOptionsModel := new(catalogmanagementv1.ReplaceCatalogOptions)
				replaceCatalogOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				replaceCatalogOptionsModel.ID = core.StringPtr("testString")
				replaceCatalogOptionsModel.Rev = core.StringPtr("testString")
				replaceCatalogOptionsModel.Label = core.StringPtr("testString")
				replaceCatalogOptionsModel.LabelI18n = make(map[string]string)
				replaceCatalogOptionsModel.ShortDescription = core.StringPtr("testString")
				replaceCatalogOptionsModel.ShortDescriptionI18n = make(map[string]string)
				replaceCatalogOptionsModel.CatalogIconURL = core.StringPtr("testString")
				replaceCatalogOptionsModel.Tags = []string{"testString"}
				replaceCatalogOptionsModel.Features = []catalogmanagementv1.Feature{*featureModel}
				replaceCatalogOptionsModel.Disabled = core.BoolPtr(true)
				replaceCatalogOptionsModel.ResourceGroupID = core.StringPtr("testString")
				replaceCatalogOptionsModel.OwningAccount = core.StringPtr("testString")
				replaceCatalogOptionsModel.CatalogFilters = filtersModel
				replaceCatalogOptionsModel.SyndicationSettings = syndicationResourceModel
				replaceCatalogOptionsModel.Kind = core.StringPtr("testString")
				replaceCatalogOptionsModel.Metadata = make(map[string]interface{})
				replaceCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.ReplaceCatalog(replaceCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ReplaceCatalog with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = make(map[string]string)
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = make(map[string]string)

				// Construct an instance of the FilterTerms model
				filterTermsModel := new(catalogmanagementv1.FilterTerms)
				filterTermsModel.FilterTerms = []string{"testString"}

				// Construct an instance of the CategoryFilter model
				categoryFilterModel := new(catalogmanagementv1.CategoryFilter)
				categoryFilterModel.Include = core.BoolPtr(true)
				categoryFilterModel.Filter = filterTermsModel

				// Construct an instance of the IDFilter model
				idFilterModel := new(catalogmanagementv1.IDFilter)
				idFilterModel.Include = filterTermsModel
				idFilterModel.Exclude = filterTermsModel

				// Construct an instance of the Filters model
				filtersModel := new(catalogmanagementv1.Filters)
				filtersModel.IncludeAll = core.BoolPtr(true)
				filtersModel.CategoryFilters = make(map[string]catalogmanagementv1.CategoryFilter)
				filtersModel.IDFilters = idFilterModel
				filtersModel.CategoryFilters["foo"] = *categoryFilterModel

				// Construct an instance of the SyndicationCluster model
				syndicationClusterModel := new(catalogmanagementv1.SyndicationCluster)
				syndicationClusterModel.Region = core.StringPtr("testString")
				syndicationClusterModel.ID = core.StringPtr("testString")
				syndicationClusterModel.Name = core.StringPtr("testString")
				syndicationClusterModel.ResourceGroupName = core.StringPtr("testString")
				syndicationClusterModel.Type = core.StringPtr("testString")
				syndicationClusterModel.Namespaces = []string{"testString"}
				syndicationClusterModel.AllNamespaces = core.BoolPtr(true)

				// Construct an instance of the SyndicationHistory model
				syndicationHistoryModel := new(catalogmanagementv1.SyndicationHistory)
				syndicationHistoryModel.Namespaces = []string{"testString"}
				syndicationHistoryModel.Clusters = []catalogmanagementv1.SyndicationCluster{*syndicationClusterModel}
				syndicationHistoryModel.LastRun = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the SyndicationAuthorization model
				syndicationAuthorizationModel := new(catalogmanagementv1.SyndicationAuthorization)
				syndicationAuthorizationModel.Token = core.StringPtr("testString")
				syndicationAuthorizationModel.LastRun = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the SyndicationResource model
				syndicationResourceModel := new(catalogmanagementv1.SyndicationResource)
				syndicationResourceModel.RemoveRelatedComponents = core.BoolPtr(true)
				syndicationResourceModel.Clusters = []catalogmanagementv1.SyndicationCluster{*syndicationClusterModel}
				syndicationResourceModel.History = syndicationHistoryModel
				syndicationResourceModel.Authorization = syndicationAuthorizationModel

				// Construct an instance of the ReplaceCatalogOptions model
				replaceCatalogOptionsModel := new(catalogmanagementv1.ReplaceCatalogOptions)
				replaceCatalogOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				replaceCatalogOptionsModel.ID = core.StringPtr("testString")
				replaceCatalogOptionsModel.Rev = core.StringPtr("testString")
				replaceCatalogOptionsModel.Label = core.StringPtr("testString")
				replaceCatalogOptionsModel.LabelI18n = make(map[string]string)
				replaceCatalogOptionsModel.ShortDescription = core.StringPtr("testString")
				replaceCatalogOptionsModel.ShortDescriptionI18n = make(map[string]string)
				replaceCatalogOptionsModel.CatalogIconURL = core.StringPtr("testString")
				replaceCatalogOptionsModel.Tags = []string{"testString"}
				replaceCatalogOptionsModel.Features = []catalogmanagementv1.Feature{*featureModel}
				replaceCatalogOptionsModel.Disabled = core.BoolPtr(true)
				replaceCatalogOptionsModel.ResourceGroupID = core.StringPtr("testString")
				replaceCatalogOptionsModel.OwningAccount = core.StringPtr("testString")
				replaceCatalogOptionsModel.CatalogFilters = filtersModel
				replaceCatalogOptionsModel.SyndicationSettings = syndicationResourceModel
				replaceCatalogOptionsModel.Kind = core.StringPtr("testString")
				replaceCatalogOptionsModel.Metadata = make(map[string]interface{})
				replaceCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.ReplaceCatalog(replaceCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ReplaceCatalogOptions model with no property values
				replaceCatalogOptionsModelNew := new(catalogmanagementv1.ReplaceCatalogOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.ReplaceCatalog(replaceCatalogOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ReplaceCatalog successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = make(map[string]string)
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = make(map[string]string)

				// Construct an instance of the FilterTerms model
				filterTermsModel := new(catalogmanagementv1.FilterTerms)
				filterTermsModel.FilterTerms = []string{"testString"}

				// Construct an instance of the CategoryFilter model
				categoryFilterModel := new(catalogmanagementv1.CategoryFilter)
				categoryFilterModel.Include = core.BoolPtr(true)
				categoryFilterModel.Filter = filterTermsModel

				// Construct an instance of the IDFilter model
				idFilterModel := new(catalogmanagementv1.IDFilter)
				idFilterModel.Include = filterTermsModel
				idFilterModel.Exclude = filterTermsModel

				// Construct an instance of the Filters model
				filtersModel := new(catalogmanagementv1.Filters)
				filtersModel.IncludeAll = core.BoolPtr(true)
				filtersModel.CategoryFilters = make(map[string]catalogmanagementv1.CategoryFilter)
				filtersModel.IDFilters = idFilterModel
				filtersModel.CategoryFilters["foo"] = *categoryFilterModel

				// Construct an instance of the SyndicationCluster model
				syndicationClusterModel := new(catalogmanagementv1.SyndicationCluster)
				syndicationClusterModel.Region = core.StringPtr("testString")
				syndicationClusterModel.ID = core.StringPtr("testString")
				syndicationClusterModel.Name = core.StringPtr("testString")
				syndicationClusterModel.ResourceGroupName = core.StringPtr("testString")
				syndicationClusterModel.Type = core.StringPtr("testString")
				syndicationClusterModel.Namespaces = []string{"testString"}
				syndicationClusterModel.AllNamespaces = core.BoolPtr(true)

				// Construct an instance of the SyndicationHistory model
				syndicationHistoryModel := new(catalogmanagementv1.SyndicationHistory)
				syndicationHistoryModel.Namespaces = []string{"testString"}
				syndicationHistoryModel.Clusters = []catalogmanagementv1.SyndicationCluster{*syndicationClusterModel}
				syndicationHistoryModel.LastRun = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the SyndicationAuthorization model
				syndicationAuthorizationModel := new(catalogmanagementv1.SyndicationAuthorization)
				syndicationAuthorizationModel.Token = core.StringPtr("testString")
				syndicationAuthorizationModel.LastRun = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the SyndicationResource model
				syndicationResourceModel := new(catalogmanagementv1.SyndicationResource)
				syndicationResourceModel.RemoveRelatedComponents = core.BoolPtr(true)
				syndicationResourceModel.Clusters = []catalogmanagementv1.SyndicationCluster{*syndicationClusterModel}
				syndicationResourceModel.History = syndicationHistoryModel
				syndicationResourceModel.Authorization = syndicationAuthorizationModel

				// Construct an instance of the ReplaceCatalogOptions model
				replaceCatalogOptionsModel := new(catalogmanagementv1.ReplaceCatalogOptions)
				replaceCatalogOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				replaceCatalogOptionsModel.ID = core.StringPtr("testString")
				replaceCatalogOptionsModel.Rev = core.StringPtr("testString")
				replaceCatalogOptionsModel.Label = core.StringPtr("testString")
				replaceCatalogOptionsModel.LabelI18n = make(map[string]string)
				replaceCatalogOptionsModel.ShortDescription = core.StringPtr("testString")
				replaceCatalogOptionsModel.ShortDescriptionI18n = make(map[string]string)
				replaceCatalogOptionsModel.CatalogIconURL = core.StringPtr("testString")
				replaceCatalogOptionsModel.Tags = []string{"testString"}
				replaceCatalogOptionsModel.Features = []catalogmanagementv1.Feature{*featureModel}
				replaceCatalogOptionsModel.Disabled = core.BoolPtr(true)
				replaceCatalogOptionsModel.ResourceGroupID = core.StringPtr("testString")
				replaceCatalogOptionsModel.OwningAccount = core.StringPtr("testString")
				replaceCatalogOptionsModel.CatalogFilters = filtersModel
				replaceCatalogOptionsModel.SyndicationSettings = syndicationResourceModel
				replaceCatalogOptionsModel.Kind = core.StringPtr("testString")
				replaceCatalogOptionsModel.Metadata = make(map[string]interface{})
				replaceCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.ReplaceCatalog(replaceCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteCatalog(deleteCatalogOptions *DeleteCatalogOptions)`, func() {
		deleteCatalogPath := "/catalogs/testString"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteCatalogPath))
					Expect(req.Method).To(Equal("DELETE"))

					res.WriteHeader(200)
				}))
			})
			It(`Invoke DeleteCatalog successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.DeleteCatalog(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteCatalogOptions model
				deleteCatalogOptionsModel := new(catalogmanagementv1.DeleteCatalogOptions)
				deleteCatalogOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				deleteCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.DeleteCatalog(deleteCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteCatalog with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the DeleteCatalogOptions model
				deleteCatalogOptionsModel := new(catalogmanagementv1.DeleteCatalogOptions)
				deleteCatalogOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				deleteCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.DeleteCatalog(deleteCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeleteCatalogOptions model with no property values
				deleteCatalogOptionsModelNew := new(catalogmanagementv1.DeleteCatalogOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.DeleteCatalog(deleteCatalogOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListCatalogAudits(listCatalogAuditsOptions *ListCatalogAuditsOptions) - Operation response error`, func() {
		listCatalogAuditsPath := "/catalogs/testString/audits"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listCatalogAuditsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// TODO: Add check for lookupnames query parameter
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListCatalogAudits with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListCatalogAuditsOptions model
				listCatalogAuditsOptionsModel := new(catalogmanagementv1.ListCatalogAuditsOptions)
				listCatalogAuditsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listCatalogAuditsOptionsModel.Start = core.StringPtr("testString")
				listCatalogAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listCatalogAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listCatalogAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.ListCatalogAudits(listCatalogAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.ListCatalogAudits(listCatalogAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListCatalogAudits(listCatalogAuditsOptions *ListCatalogAuditsOptions)`, func() {
		listCatalogAuditsPath := "/catalogs/testString/audits"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listCatalogAuditsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// TODO: Add check for lookupnames query parameter
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"start": "Start", "limit": 5, "total_count": 10, "resource_count": 13, "first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}, "prev": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}, "audits": [{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message"}]}`)
				}))
			})
			It(`Invoke ListCatalogAudits successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the ListCatalogAuditsOptions model
				listCatalogAuditsOptionsModel := new(catalogmanagementv1.ListCatalogAuditsOptions)
				listCatalogAuditsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listCatalogAuditsOptionsModel.Start = core.StringPtr("testString")
				listCatalogAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listCatalogAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listCatalogAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.ListCatalogAuditsWithContext(ctx, listCatalogAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.ListCatalogAudits(listCatalogAuditsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.ListCatalogAuditsWithContext(ctx, listCatalogAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listCatalogAuditsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// TODO: Add check for lookupnames query parameter
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"start": "Start", "limit": 5, "total_count": 10, "resource_count": 13, "first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}, "prev": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}, "audits": [{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message"}]}`)
				}))
			})
			It(`Invoke ListCatalogAudits successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.ListCatalogAudits(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListCatalogAuditsOptions model
				listCatalogAuditsOptionsModel := new(catalogmanagementv1.ListCatalogAuditsOptions)
				listCatalogAuditsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listCatalogAuditsOptionsModel.Start = core.StringPtr("testString")
				listCatalogAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listCatalogAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listCatalogAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.ListCatalogAudits(listCatalogAuditsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListCatalogAudits with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListCatalogAuditsOptions model
				listCatalogAuditsOptionsModel := new(catalogmanagementv1.ListCatalogAuditsOptions)
				listCatalogAuditsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listCatalogAuditsOptionsModel.Start = core.StringPtr("testString")
				listCatalogAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listCatalogAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listCatalogAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.ListCatalogAudits(listCatalogAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ListCatalogAuditsOptions model with no property values
				listCatalogAuditsOptionsModelNew := new(catalogmanagementv1.ListCatalogAuditsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.ListCatalogAudits(listCatalogAuditsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListCatalogAudits successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListCatalogAuditsOptions model
				listCatalogAuditsOptionsModel := new(catalogmanagementv1.ListCatalogAuditsOptions)
				listCatalogAuditsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listCatalogAuditsOptionsModel.Start = core.StringPtr("testString")
				listCatalogAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listCatalogAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listCatalogAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.ListCatalogAudits(listCatalogAuditsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Test pagination helper method on response`, func() {
			It(`Invoke GetNextStart successfully`, func() {
				responseObject := new(catalogmanagementv1.AuditLogs)
				nextObject := new(catalogmanagementv1.PaginationTokenLink)
				nextObject.Start = core.StringPtr("abc-123")
				responseObject.Next = nextObject
	
				value, err := responseObject.GetNextStart()
				Expect(err).To(BeNil())
				Expect(value).To(Equal(core.StringPtr("abc-123")))
			})
			It(`Invoke GetNextStart without a "Next" property in the response`, func() {
				responseObject := new(catalogmanagementv1.AuditLogs)
	
				value, err := responseObject.GetNextStart()
				Expect(err).To(BeNil())
				Expect(value).To(BeNil())
			})
		})
		Context(`Using mock server endpoint - paginated response`, func() {
			BeforeEach(func() {
				var requestNumber int = 0
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listCatalogAuditsPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					requestNumber++
					if requestNumber == 1 {
						fmt.Fprintf(res, "%s", `{"next":{"start":"1"},"total_count":2,"limit":1,"audits":[{"id":"ID","_rev":"Rev","created":"2019-01-01T12:00:00.000Z","change_type":"ChangeType","target_type":"TargetType","target_id":"TargetID","who_email":"WhoEmail","who_delegate_email":"WhoDelegateEmail","message":"Message"}]}`)
					} else if requestNumber == 2 {
						fmt.Fprintf(res, "%s", `{"total_count":2,"limit":1,"audits":[{"id":"ID","_rev":"Rev","created":"2019-01-01T12:00:00.000Z","change_type":"ChangeType","target_type":"TargetType","target_id":"TargetID","who_email":"WhoEmail","who_delegate_email":"WhoDelegateEmail","message":"Message"}]}`)
					} else {
						res.WriteHeader(400)
					}
				}))
			})
			It(`Use CatalogAuditsPager.GetNext successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				listCatalogAuditsOptionsModel := &catalogmanagementv1.ListCatalogAuditsOptions{
					CatalogIdentifier: core.StringPtr("testString"),
					Limit: core.Int64Ptr(int64(10)),
					Lookupnames: core.BoolPtr(true),
				}

				pager, err := catalogManagementService.NewCatalogAuditsPager(listCatalogAuditsOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				var allResults []catalogmanagementv1.AuditLogDigest
				for pager.HasNext() {
					nextPage, err := pager.GetNext()
					Expect(err).To(BeNil())
					Expect(nextPage).ToNot(BeNil())
					allResults = append(allResults, nextPage...)
				}
				Expect(len(allResults)).To(Equal(2))
			})
			It(`Use CatalogAuditsPager.GetAll successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				listCatalogAuditsOptionsModel := &catalogmanagementv1.ListCatalogAuditsOptions{
					CatalogIdentifier: core.StringPtr("testString"),
					Limit: core.Int64Ptr(int64(10)),
					Lookupnames: core.BoolPtr(true),
				}

				pager, err := catalogManagementService.NewCatalogAuditsPager(listCatalogAuditsOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				allResults, err := pager.GetAll()
				Expect(err).To(BeNil())
				Expect(allResults).ToNot(BeNil())
				Expect(len(allResults)).To(Equal(2))
			})
		})
	})
	Describe(`GetCatalogAudit(getCatalogAuditOptions *GetCatalogAuditOptions) - Operation response error`, func() {
		getCatalogAuditPath := "/catalogs/testString/audits/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getCatalogAuditPath))
					Expect(req.Method).To(Equal("GET"))
					// TODO: Add check for lookupnames query parameter
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetCatalogAudit with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetCatalogAuditOptions model
				getCatalogAuditOptionsModel := new(catalogmanagementv1.GetCatalogAuditOptions)
				getCatalogAuditOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getCatalogAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getCatalogAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getCatalogAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetCatalogAudit(getCatalogAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetCatalogAudit(getCatalogAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetCatalogAudit(getCatalogAuditOptions *GetCatalogAuditOptions)`, func() {
		getCatalogAuditPath := "/catalogs/testString/audits/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getCatalogAuditPath))
					Expect(req.Method).To(Equal("GET"))

					// TODO: Add check for lookupnames query parameter
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message", "gid": "Gid", "who_id": "WhoID", "who_name": "WhoName", "who_delegate_id": "WhoDelegateID", "who_delegate_name": "WhoDelegateName", "data": "anyValue"}`)
				}))
			})
			It(`Invoke GetCatalogAudit successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetCatalogAuditOptions model
				getCatalogAuditOptionsModel := new(catalogmanagementv1.GetCatalogAuditOptions)
				getCatalogAuditOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getCatalogAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getCatalogAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getCatalogAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetCatalogAuditWithContext(ctx, getCatalogAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetCatalogAudit(getCatalogAuditOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetCatalogAuditWithContext(ctx, getCatalogAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getCatalogAuditPath))
					Expect(req.Method).To(Equal("GET"))

					// TODO: Add check for lookupnames query parameter
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message", "gid": "Gid", "who_id": "WhoID", "who_name": "WhoName", "who_delegate_id": "WhoDelegateID", "who_delegate_name": "WhoDelegateName", "data": "anyValue"}`)
				}))
			})
			It(`Invoke GetCatalogAudit successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetCatalogAudit(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetCatalogAuditOptions model
				getCatalogAuditOptionsModel := new(catalogmanagementv1.GetCatalogAuditOptions)
				getCatalogAuditOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getCatalogAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getCatalogAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getCatalogAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetCatalogAudit(getCatalogAuditOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetCatalogAudit with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetCatalogAuditOptions model
				getCatalogAuditOptionsModel := new(catalogmanagementv1.GetCatalogAuditOptions)
				getCatalogAuditOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getCatalogAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getCatalogAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getCatalogAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetCatalogAudit(getCatalogAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetCatalogAuditOptions model with no property values
				getCatalogAuditOptionsModelNew := new(catalogmanagementv1.GetCatalogAuditOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetCatalogAudit(getCatalogAuditOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetCatalogAudit successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetCatalogAuditOptions model
				getCatalogAuditOptionsModel := new(catalogmanagementv1.GetCatalogAuditOptions)
				getCatalogAuditOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getCatalogAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getCatalogAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getCatalogAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetCatalogAudit(getCatalogAuditOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListEnterpriseAudits(listEnterpriseAuditsOptions *ListEnterpriseAuditsOptions) - Operation response error`, func() {
		listEnterpriseAuditsPath := "/enterprises/testString/audits"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listEnterpriseAuditsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// TODO: Add check for lookupnames query parameter
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListEnterpriseAudits with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListEnterpriseAuditsOptions model
				listEnterpriseAuditsOptionsModel := new(catalogmanagementv1.ListEnterpriseAuditsOptions)
				listEnterpriseAuditsOptionsModel.EnterpriseIdentifier = core.StringPtr("testString")
				listEnterpriseAuditsOptionsModel.Start = core.StringPtr("testString")
				listEnterpriseAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listEnterpriseAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listEnterpriseAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.ListEnterpriseAudits(listEnterpriseAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.ListEnterpriseAudits(listEnterpriseAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListEnterpriseAudits(listEnterpriseAuditsOptions *ListEnterpriseAuditsOptions)`, func() {
		listEnterpriseAuditsPath := "/enterprises/testString/audits"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listEnterpriseAuditsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// TODO: Add check for lookupnames query parameter
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"start": "Start", "limit": 5, "total_count": 10, "resource_count": 13, "first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}, "prev": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}, "audits": [{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message"}]}`)
				}))
			})
			It(`Invoke ListEnterpriseAudits successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the ListEnterpriseAuditsOptions model
				listEnterpriseAuditsOptionsModel := new(catalogmanagementv1.ListEnterpriseAuditsOptions)
				listEnterpriseAuditsOptionsModel.EnterpriseIdentifier = core.StringPtr("testString")
				listEnterpriseAuditsOptionsModel.Start = core.StringPtr("testString")
				listEnterpriseAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listEnterpriseAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listEnterpriseAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.ListEnterpriseAuditsWithContext(ctx, listEnterpriseAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.ListEnterpriseAudits(listEnterpriseAuditsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.ListEnterpriseAuditsWithContext(ctx, listEnterpriseAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listEnterpriseAuditsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// TODO: Add check for lookupnames query parameter
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"start": "Start", "limit": 5, "total_count": 10, "resource_count": 13, "first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}, "prev": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}, "audits": [{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message"}]}`)
				}))
			})
			It(`Invoke ListEnterpriseAudits successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.ListEnterpriseAudits(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListEnterpriseAuditsOptions model
				listEnterpriseAuditsOptionsModel := new(catalogmanagementv1.ListEnterpriseAuditsOptions)
				listEnterpriseAuditsOptionsModel.EnterpriseIdentifier = core.StringPtr("testString")
				listEnterpriseAuditsOptionsModel.Start = core.StringPtr("testString")
				listEnterpriseAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listEnterpriseAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listEnterpriseAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.ListEnterpriseAudits(listEnterpriseAuditsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListEnterpriseAudits with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListEnterpriseAuditsOptions model
				listEnterpriseAuditsOptionsModel := new(catalogmanagementv1.ListEnterpriseAuditsOptions)
				listEnterpriseAuditsOptionsModel.EnterpriseIdentifier = core.StringPtr("testString")
				listEnterpriseAuditsOptionsModel.Start = core.StringPtr("testString")
				listEnterpriseAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listEnterpriseAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listEnterpriseAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.ListEnterpriseAudits(listEnterpriseAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ListEnterpriseAuditsOptions model with no property values
				listEnterpriseAuditsOptionsModelNew := new(catalogmanagementv1.ListEnterpriseAuditsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.ListEnterpriseAudits(listEnterpriseAuditsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListEnterpriseAudits successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListEnterpriseAuditsOptions model
				listEnterpriseAuditsOptionsModel := new(catalogmanagementv1.ListEnterpriseAuditsOptions)
				listEnterpriseAuditsOptionsModel.EnterpriseIdentifier = core.StringPtr("testString")
				listEnterpriseAuditsOptionsModel.Start = core.StringPtr("testString")
				listEnterpriseAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listEnterpriseAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listEnterpriseAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.ListEnterpriseAudits(listEnterpriseAuditsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Test pagination helper method on response`, func() {
			It(`Invoke GetNextStart successfully`, func() {
				responseObject := new(catalogmanagementv1.AuditLogs)
				nextObject := new(catalogmanagementv1.PaginationTokenLink)
				nextObject.Start = core.StringPtr("abc-123")
				responseObject.Next = nextObject
	
				value, err := responseObject.GetNextStart()
				Expect(err).To(BeNil())
				Expect(value).To(Equal(core.StringPtr("abc-123")))
			})
			It(`Invoke GetNextStart without a "Next" property in the response`, func() {
				responseObject := new(catalogmanagementv1.AuditLogs)
	
				value, err := responseObject.GetNextStart()
				Expect(err).To(BeNil())
				Expect(value).To(BeNil())
			})
		})
		Context(`Using mock server endpoint - paginated response`, func() {
			BeforeEach(func() {
				var requestNumber int = 0
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listEnterpriseAuditsPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					requestNumber++
					if requestNumber == 1 {
						fmt.Fprintf(res, "%s", `{"next":{"start":"1"},"total_count":2,"limit":1,"audits":[{"id":"ID","_rev":"Rev","created":"2019-01-01T12:00:00.000Z","change_type":"ChangeType","target_type":"TargetType","target_id":"TargetID","who_email":"WhoEmail","who_delegate_email":"WhoDelegateEmail","message":"Message"}]}`)
					} else if requestNumber == 2 {
						fmt.Fprintf(res, "%s", `{"total_count":2,"limit":1,"audits":[{"id":"ID","_rev":"Rev","created":"2019-01-01T12:00:00.000Z","change_type":"ChangeType","target_type":"TargetType","target_id":"TargetID","who_email":"WhoEmail","who_delegate_email":"WhoDelegateEmail","message":"Message"}]}`)
					} else {
						res.WriteHeader(400)
					}
				}))
			})
			It(`Use EnterpriseAuditsPager.GetNext successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				listEnterpriseAuditsOptionsModel := &catalogmanagementv1.ListEnterpriseAuditsOptions{
					EnterpriseIdentifier: core.StringPtr("testString"),
					Limit: core.Int64Ptr(int64(10)),
					Lookupnames: core.BoolPtr(true),
				}

				pager, err := catalogManagementService.NewEnterpriseAuditsPager(listEnterpriseAuditsOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				var allResults []catalogmanagementv1.AuditLogDigest
				for pager.HasNext() {
					nextPage, err := pager.GetNext()
					Expect(err).To(BeNil())
					Expect(nextPage).ToNot(BeNil())
					allResults = append(allResults, nextPage...)
				}
				Expect(len(allResults)).To(Equal(2))
			})
			It(`Use EnterpriseAuditsPager.GetAll successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				listEnterpriseAuditsOptionsModel := &catalogmanagementv1.ListEnterpriseAuditsOptions{
					EnterpriseIdentifier: core.StringPtr("testString"),
					Limit: core.Int64Ptr(int64(10)),
					Lookupnames: core.BoolPtr(true),
				}

				pager, err := catalogManagementService.NewEnterpriseAuditsPager(listEnterpriseAuditsOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				allResults, err := pager.GetAll()
				Expect(err).To(BeNil())
				Expect(allResults).ToNot(BeNil())
				Expect(len(allResults)).To(Equal(2))
			})
		})
	})
	Describe(`GetEnterpriseAudit(getEnterpriseAuditOptions *GetEnterpriseAuditOptions) - Operation response error`, func() {
		getEnterpriseAuditPath := "/enterprises/testString/audits/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getEnterpriseAuditPath))
					Expect(req.Method).To(Equal("GET"))
					// TODO: Add check for lookupnames query parameter
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetEnterpriseAudit with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetEnterpriseAuditOptions model
				getEnterpriseAuditOptionsModel := new(catalogmanagementv1.GetEnterpriseAuditOptions)
				getEnterpriseAuditOptionsModel.EnterpriseIdentifier = core.StringPtr("testString")
				getEnterpriseAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getEnterpriseAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getEnterpriseAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetEnterpriseAudit(getEnterpriseAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetEnterpriseAudit(getEnterpriseAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetEnterpriseAudit(getEnterpriseAuditOptions *GetEnterpriseAuditOptions)`, func() {
		getEnterpriseAuditPath := "/enterprises/testString/audits/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getEnterpriseAuditPath))
					Expect(req.Method).To(Equal("GET"))

					// TODO: Add check for lookupnames query parameter
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message", "gid": "Gid", "who_id": "WhoID", "who_name": "WhoName", "who_delegate_id": "WhoDelegateID", "who_delegate_name": "WhoDelegateName", "data": "anyValue"}`)
				}))
			})
			It(`Invoke GetEnterpriseAudit successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetEnterpriseAuditOptions model
				getEnterpriseAuditOptionsModel := new(catalogmanagementv1.GetEnterpriseAuditOptions)
				getEnterpriseAuditOptionsModel.EnterpriseIdentifier = core.StringPtr("testString")
				getEnterpriseAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getEnterpriseAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getEnterpriseAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetEnterpriseAuditWithContext(ctx, getEnterpriseAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetEnterpriseAudit(getEnterpriseAuditOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetEnterpriseAuditWithContext(ctx, getEnterpriseAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getEnterpriseAuditPath))
					Expect(req.Method).To(Equal("GET"))

					// TODO: Add check for lookupnames query parameter
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message", "gid": "Gid", "who_id": "WhoID", "who_name": "WhoName", "who_delegate_id": "WhoDelegateID", "who_delegate_name": "WhoDelegateName", "data": "anyValue"}`)
				}))
			})
			It(`Invoke GetEnterpriseAudit successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetEnterpriseAudit(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetEnterpriseAuditOptions model
				getEnterpriseAuditOptionsModel := new(catalogmanagementv1.GetEnterpriseAuditOptions)
				getEnterpriseAuditOptionsModel.EnterpriseIdentifier = core.StringPtr("testString")
				getEnterpriseAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getEnterpriseAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getEnterpriseAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetEnterpriseAudit(getEnterpriseAuditOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetEnterpriseAudit with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetEnterpriseAuditOptions model
				getEnterpriseAuditOptionsModel := new(catalogmanagementv1.GetEnterpriseAuditOptions)
				getEnterpriseAuditOptionsModel.EnterpriseIdentifier = core.StringPtr("testString")
				getEnterpriseAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getEnterpriseAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getEnterpriseAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetEnterpriseAudit(getEnterpriseAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetEnterpriseAuditOptions model with no property values
				getEnterpriseAuditOptionsModelNew := new(catalogmanagementv1.GetEnterpriseAuditOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetEnterpriseAudit(getEnterpriseAuditOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetEnterpriseAudit successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetEnterpriseAuditOptions model
				getEnterpriseAuditOptionsModel := new(catalogmanagementv1.GetEnterpriseAuditOptions)
				getEnterpriseAuditOptionsModel.EnterpriseIdentifier = core.StringPtr("testString")
				getEnterpriseAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getEnterpriseAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getEnterpriseAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetEnterpriseAudit(getEnterpriseAuditOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetConsumptionOfferings(getConsumptionOfferingsOptions *GetConsumptionOfferingsOptions) - Operation response error`, func() {
		getConsumptionOfferingsPath := "/offerings"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getConsumptionOfferingsPath))
					Expect(req.Method).To(Equal("GET"))
					// TODO: Add check for digest query parameter
					Expect(req.URL.Query()["catalog"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["select"]).To(Equal([]string{"all"}))
					// TODO: Add check for includeHidden query parameter
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(1000))}))
					Expect(req.URL.Query()["offset"]).To(Equal([]string{fmt.Sprint(int64(38))}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetConsumptionOfferings with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetConsumptionOfferingsOptions model
				getConsumptionOfferingsOptionsModel := new(catalogmanagementv1.GetConsumptionOfferingsOptions)
				getConsumptionOfferingsOptionsModel.Digest = core.BoolPtr(true)
				getConsumptionOfferingsOptionsModel.Catalog = core.StringPtr("testString")
				getConsumptionOfferingsOptionsModel.Select = core.StringPtr("all")
				getConsumptionOfferingsOptionsModel.IncludeHidden = core.BoolPtr(true)
				getConsumptionOfferingsOptionsModel.Limit = core.Int64Ptr(int64(1000))
				getConsumptionOfferingsOptionsModel.Offset = core.Int64Ptr(int64(38))
				getConsumptionOfferingsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetConsumptionOfferings(getConsumptionOfferingsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetConsumptionOfferings(getConsumptionOfferingsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetConsumptionOfferings(getConsumptionOfferingsOptions *GetConsumptionOfferingsOptions)`, func() {
		getConsumptionOfferingsPath := "/offerings"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getConsumptionOfferingsPath))
					Expect(req.Method).To(Equal("GET"))

					// TODO: Add check for digest query parameter
					Expect(req.URL.Query()["catalog"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["select"]).To(Equal([]string{"all"}))
					// TODO: Add check for includeHidden query parameter
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(1000))}))
					Expect(req.URL.Query()["offset"]).To(Equal([]string{fmt.Sprint(int64(38))}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"offset": 6, "limit": 5, "total_count": 10, "resource_count": 13, "first": "First", "last": "Last", "prev": "Prev", "next": "Next", "resources": [{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "offering_icon_url": "OfferingIconURL", "offering_docs_url": "OfferingDocsURL", "offering_support_url": "OfferingSupportURL", "tags": ["Tags"], "keywords": ["Keywords"], "rating": {"one_star_count": 12, "two_star_count": 12, "three_star_count": 14, "four_star_count": 13}, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "kinds": [{"id": "ID", "format_kind": "FormatKind", "install_kind": "InstallKind", "target_kind": "TargetKind", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"mapKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"mapKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "version": "Version", "flavors": ["Flavors"]}]}, "is_consumable": true}], "plans": [{"id": "ID", "label": "Label", "name": "Name", "short_description": "ShortDescription", "long_description": "LongDescription", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "deployments": [{"id": "ID", "label": "Label", "name": "Name", "short_description": "ShortDescription", "long_description": "LongDescription", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z"}]}]}], "pc_managed": false, "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "permit_request_ibm_public_publish": false, "ibm_publish_approved": true, "public_publish_approved": false, "public_original_crn": "PublicOriginalCRN", "publish_public_crn": "PublishPublicCRN", "portal_approval_record": "PortalApprovalRecord", "portal_ui_url": "PortalUIURL", "catalog_id": "CatalogID", "catalog_name": "CatalogName", "metadata": {"mapKey": "anyValue"}, "disclaimer": "Disclaimer", "hidden": true, "provider": "Provider", "provider_info": {"id": "ID", "name": "Name"}, "repo_info": {"token": "Token", "type": "Type"}, "image_pull_keys": [{"name": "Name", "value": "Value", "description": "Description"}], "support": {"url": "URL", "process": "Process", "process_i18n": {"mapKey": "Inner"}, "locations": ["Locations"], "support_details": [{"type": "Type", "contact": "Contact", "response_wait_time": {"value": 5, "type": "Type"}, "availability": {"times": [{"day": 3, "start_time": "StartTime", "end_time": "EndTime"}], "timezone": "Timezone", "always_available": false}}], "support_escalation": {"escalation_wait_time": {"value": 5, "type": "Type"}, "response_wait_time": {"value": 5, "type": "Type"}, "contact": "Contact"}, "support_type": "SupportType"}, "media": [{"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}], "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "product_kind": "ProductKind", "badges": [{"id": "ID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}, "icon": "Icon", "authority": "Authority", "tag": "Tag", "learn_more_links": {"first_party": "FirstParty", "third_party": "ThirdParty"}, "constraints": [{"type": "Type", "rule": "anyValue"}]}]}]}`)
				}))
			})
			It(`Invoke GetConsumptionOfferings successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetConsumptionOfferingsOptions model
				getConsumptionOfferingsOptionsModel := new(catalogmanagementv1.GetConsumptionOfferingsOptions)
				getConsumptionOfferingsOptionsModel.Digest = core.BoolPtr(true)
				getConsumptionOfferingsOptionsModel.Catalog = core.StringPtr("testString")
				getConsumptionOfferingsOptionsModel.Select = core.StringPtr("all")
				getConsumptionOfferingsOptionsModel.IncludeHidden = core.BoolPtr(true)
				getConsumptionOfferingsOptionsModel.Limit = core.Int64Ptr(int64(1000))
				getConsumptionOfferingsOptionsModel.Offset = core.Int64Ptr(int64(38))
				getConsumptionOfferingsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetConsumptionOfferingsWithContext(ctx, getConsumptionOfferingsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetConsumptionOfferings(getConsumptionOfferingsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetConsumptionOfferingsWithContext(ctx, getConsumptionOfferingsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getConsumptionOfferingsPath))
					Expect(req.Method).To(Equal("GET"))

					// TODO: Add check for digest query parameter
					Expect(req.URL.Query()["catalog"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["select"]).To(Equal([]string{"all"}))
					// TODO: Add check for includeHidden query parameter
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(1000))}))
					Expect(req.URL.Query()["offset"]).To(Equal([]string{fmt.Sprint(int64(38))}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"offset": 6, "limit": 5, "total_count": 10, "resource_count": 13, "first": "First", "last": "Last", "prev": "Prev", "next": "Next", "resources": [{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "offering_icon_url": "OfferingIconURL", "offering_docs_url": "OfferingDocsURL", "offering_support_url": "OfferingSupportURL", "tags": ["Tags"], "keywords": ["Keywords"], "rating": {"one_star_count": 12, "two_star_count": 12, "three_star_count": 14, "four_star_count": 13}, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "kinds": [{"id": "ID", "format_kind": "FormatKind", "install_kind": "InstallKind", "target_kind": "TargetKind", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"mapKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"mapKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "version": "Version", "flavors": ["Flavors"]}]}, "is_consumable": true}], "plans": [{"id": "ID", "label": "Label", "name": "Name", "short_description": "ShortDescription", "long_description": "LongDescription", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "deployments": [{"id": "ID", "label": "Label", "name": "Name", "short_description": "ShortDescription", "long_description": "LongDescription", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z"}]}]}], "pc_managed": false, "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "permit_request_ibm_public_publish": false, "ibm_publish_approved": true, "public_publish_approved": false, "public_original_crn": "PublicOriginalCRN", "publish_public_crn": "PublishPublicCRN", "portal_approval_record": "PortalApprovalRecord", "portal_ui_url": "PortalUIURL", "catalog_id": "CatalogID", "catalog_name": "CatalogName", "metadata": {"mapKey": "anyValue"}, "disclaimer": "Disclaimer", "hidden": true, "provider": "Provider", "provider_info": {"id": "ID", "name": "Name"}, "repo_info": {"token": "Token", "type": "Type"}, "image_pull_keys": [{"name": "Name", "value": "Value", "description": "Description"}], "support": {"url": "URL", "process": "Process", "process_i18n": {"mapKey": "Inner"}, "locations": ["Locations"], "support_details": [{"type": "Type", "contact": "Contact", "response_wait_time": {"value": 5, "type": "Type"}, "availability": {"times": [{"day": 3, "start_time": "StartTime", "end_time": "EndTime"}], "timezone": "Timezone", "always_available": false}}], "support_escalation": {"escalation_wait_time": {"value": 5, "type": "Type"}, "response_wait_time": {"value": 5, "type": "Type"}, "contact": "Contact"}, "support_type": "SupportType"}, "media": [{"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}], "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "product_kind": "ProductKind", "badges": [{"id": "ID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}, "icon": "Icon", "authority": "Authority", "tag": "Tag", "learn_more_links": {"first_party": "FirstParty", "third_party": "ThirdParty"}, "constraints": [{"type": "Type", "rule": "anyValue"}]}]}]}`)
				}))
			})
			It(`Invoke GetConsumptionOfferings successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetConsumptionOfferings(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetConsumptionOfferingsOptions model
				getConsumptionOfferingsOptionsModel := new(catalogmanagementv1.GetConsumptionOfferingsOptions)
				getConsumptionOfferingsOptionsModel.Digest = core.BoolPtr(true)
				getConsumptionOfferingsOptionsModel.Catalog = core.StringPtr("testString")
				getConsumptionOfferingsOptionsModel.Select = core.StringPtr("all")
				getConsumptionOfferingsOptionsModel.IncludeHidden = core.BoolPtr(true)
				getConsumptionOfferingsOptionsModel.Limit = core.Int64Ptr(int64(1000))
				getConsumptionOfferingsOptionsModel.Offset = core.Int64Ptr(int64(38))
				getConsumptionOfferingsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetConsumptionOfferings(getConsumptionOfferingsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetConsumptionOfferings with error: Operation request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetConsumptionOfferingsOptions model
				getConsumptionOfferingsOptionsModel := new(catalogmanagementv1.GetConsumptionOfferingsOptions)
				getConsumptionOfferingsOptionsModel.Digest = core.BoolPtr(true)
				getConsumptionOfferingsOptionsModel.Catalog = core.StringPtr("testString")
				getConsumptionOfferingsOptionsModel.Select = core.StringPtr("all")
				getConsumptionOfferingsOptionsModel.IncludeHidden = core.BoolPtr(true)
				getConsumptionOfferingsOptionsModel.Limit = core.Int64Ptr(int64(1000))
				getConsumptionOfferingsOptionsModel.Offset = core.Int64Ptr(int64(38))
				getConsumptionOfferingsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetConsumptionOfferings(getConsumptionOfferingsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetConsumptionOfferings successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetConsumptionOfferingsOptions model
				getConsumptionOfferingsOptionsModel := new(catalogmanagementv1.GetConsumptionOfferingsOptions)
				getConsumptionOfferingsOptionsModel.Digest = core.BoolPtr(true)
				getConsumptionOfferingsOptionsModel.Catalog = core.StringPtr("testString")
				getConsumptionOfferingsOptionsModel.Select = core.StringPtr("all")
				getConsumptionOfferingsOptionsModel.IncludeHidden = core.BoolPtr(true)
				getConsumptionOfferingsOptionsModel.Limit = core.Int64Ptr(int64(1000))
				getConsumptionOfferingsOptionsModel.Offset = core.Int64Ptr(int64(38))
				getConsumptionOfferingsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetConsumptionOfferings(getConsumptionOfferingsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListOfferings(listOfferingsOptions *ListOfferingsOptions) - Operation response error`, func() {
		listOfferingsPath := "/catalogs/testString/offerings"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listOfferingsPath))
					Expect(req.Method).To(Equal("GET"))
					// TODO: Add check for digest query parameter
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(1000))}))
					Expect(req.URL.Query()["offset"]).To(Equal([]string{fmt.Sprint(int64(38))}))
					Expect(req.URL.Query()["name"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["sort"]).To(Equal([]string{"testString"}))
					// TODO: Add check for includeHidden query parameter
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListOfferings with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListOfferingsOptions model
				listOfferingsOptionsModel := new(catalogmanagementv1.ListOfferingsOptions)
				listOfferingsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listOfferingsOptionsModel.Digest = core.BoolPtr(true)
				listOfferingsOptionsModel.Limit = core.Int64Ptr(int64(1000))
				listOfferingsOptionsModel.Offset = core.Int64Ptr(int64(38))
				listOfferingsOptionsModel.Name = core.StringPtr("testString")
				listOfferingsOptionsModel.Sort = core.StringPtr("testString")
				listOfferingsOptionsModel.IncludeHidden = core.BoolPtr(true)
				listOfferingsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.ListOfferings(listOfferingsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.ListOfferings(listOfferingsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListOfferings(listOfferingsOptions *ListOfferingsOptions)`, func() {
		listOfferingsPath := "/catalogs/testString/offerings"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listOfferingsPath))
					Expect(req.Method).To(Equal("GET"))

					// TODO: Add check for digest query parameter
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(1000))}))
					Expect(req.URL.Query()["offset"]).To(Equal([]string{fmt.Sprint(int64(38))}))
					Expect(req.URL.Query()["name"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["sort"]).To(Equal([]string{"testString"}))
					// TODO: Add check for includeHidden query parameter
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"offset": 6, "limit": 5, "total_count": 10, "resource_count": 13, "first": "First", "last": "Last", "prev": "Prev", "next": "Next", "resources": [{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "offering_icon_url": "OfferingIconURL", "offering_docs_url": "OfferingDocsURL", "offering_support_url": "OfferingSupportURL", "tags": ["Tags"], "keywords": ["Keywords"], "rating": {"one_star_count": 12, "two_star_count": 12, "three_star_count": 14, "four_star_count": 13}, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "kinds": [{"id": "ID", "format_kind": "FormatKind", "install_kind": "InstallKind", "target_kind": "TargetKind", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"mapKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"mapKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "version": "Version", "flavors": ["Flavors"]}]}, "is_consumable": true}], "plans": [{"id": "ID", "label": "Label", "name": "Name", "short_description": "ShortDescription", "long_description": "LongDescription", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "deployments": [{"id": "ID", "label": "Label", "name": "Name", "short_description": "ShortDescription", "long_description": "LongDescription", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z"}]}]}], "pc_managed": false, "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "permit_request_ibm_public_publish": false, "ibm_publish_approved": true, "public_publish_approved": false, "public_original_crn": "PublicOriginalCRN", "publish_public_crn": "PublishPublicCRN", "portal_approval_record": "PortalApprovalRecord", "portal_ui_url": "PortalUIURL", "catalog_id": "CatalogID", "catalog_name": "CatalogName", "metadata": {"mapKey": "anyValue"}, "disclaimer": "Disclaimer", "hidden": true, "provider": "Provider", "provider_info": {"id": "ID", "name": "Name"}, "repo_info": {"token": "Token", "type": "Type"}, "image_pull_keys": [{"name": "Name", "value": "Value", "description": "Description"}], "support": {"url": "URL", "process": "Process", "process_i18n": {"mapKey": "Inner"}, "locations": ["Locations"], "support_details": [{"type": "Type", "contact": "Contact", "response_wait_time": {"value": 5, "type": "Type"}, "availability": {"times": [{"day": 3, "start_time": "StartTime", "end_time": "EndTime"}], "timezone": "Timezone", "always_available": false}}], "support_escalation": {"escalation_wait_time": {"value": 5, "type": "Type"}, "response_wait_time": {"value": 5, "type": "Type"}, "contact": "Contact"}, "support_type": "SupportType"}, "media": [{"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}], "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "product_kind": "ProductKind", "badges": [{"id": "ID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}, "icon": "Icon", "authority": "Authority", "tag": "Tag", "learn_more_links": {"first_party": "FirstParty", "third_party": "ThirdParty"}, "constraints": [{"type": "Type", "rule": "anyValue"}]}]}]}`)
				}))
			})
			It(`Invoke ListOfferings successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the ListOfferingsOptions model
				listOfferingsOptionsModel := new(catalogmanagementv1.ListOfferingsOptions)
				listOfferingsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listOfferingsOptionsModel.Digest = core.BoolPtr(true)
				listOfferingsOptionsModel.Limit = core.Int64Ptr(int64(1000))
				listOfferingsOptionsModel.Offset = core.Int64Ptr(int64(38))
				listOfferingsOptionsModel.Name = core.StringPtr("testString")
				listOfferingsOptionsModel.Sort = core.StringPtr("testString")
				listOfferingsOptionsModel.IncludeHidden = core.BoolPtr(true)
				listOfferingsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.ListOfferingsWithContext(ctx, listOfferingsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.ListOfferings(listOfferingsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.ListOfferingsWithContext(ctx, listOfferingsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listOfferingsPath))
					Expect(req.Method).To(Equal("GET"))

					// TODO: Add check for digest query parameter
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(1000))}))
					Expect(req.URL.Query()["offset"]).To(Equal([]string{fmt.Sprint(int64(38))}))
					Expect(req.URL.Query()["name"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["sort"]).To(Equal([]string{"testString"}))
					// TODO: Add check for includeHidden query parameter
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"offset": 6, "limit": 5, "total_count": 10, "resource_count": 13, "first": "First", "last": "Last", "prev": "Prev", "next": "Next", "resources": [{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "offering_icon_url": "OfferingIconURL", "offering_docs_url": "OfferingDocsURL", "offering_support_url": "OfferingSupportURL", "tags": ["Tags"], "keywords": ["Keywords"], "rating": {"one_star_count": 12, "two_star_count": 12, "three_star_count": 14, "four_star_count": 13}, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "kinds": [{"id": "ID", "format_kind": "FormatKind", "install_kind": "InstallKind", "target_kind": "TargetKind", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"mapKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"mapKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "version": "Version", "flavors": ["Flavors"]}]}, "is_consumable": true}], "plans": [{"id": "ID", "label": "Label", "name": "Name", "short_description": "ShortDescription", "long_description": "LongDescription", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "deployments": [{"id": "ID", "label": "Label", "name": "Name", "short_description": "ShortDescription", "long_description": "LongDescription", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z"}]}]}], "pc_managed": false, "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "permit_request_ibm_public_publish": false, "ibm_publish_approved": true, "public_publish_approved": false, "public_original_crn": "PublicOriginalCRN", "publish_public_crn": "PublishPublicCRN", "portal_approval_record": "PortalApprovalRecord", "portal_ui_url": "PortalUIURL", "catalog_id": "CatalogID", "catalog_name": "CatalogName", "metadata": {"mapKey": "anyValue"}, "disclaimer": "Disclaimer", "hidden": true, "provider": "Provider", "provider_info": {"id": "ID", "name": "Name"}, "repo_info": {"token": "Token", "type": "Type"}, "image_pull_keys": [{"name": "Name", "value": "Value", "description": "Description"}], "support": {"url": "URL", "process": "Process", "process_i18n": {"mapKey": "Inner"}, "locations": ["Locations"], "support_details": [{"type": "Type", "contact": "Contact", "response_wait_time": {"value": 5, "type": "Type"}, "availability": {"times": [{"day": 3, "start_time": "StartTime", "end_time": "EndTime"}], "timezone": "Timezone", "always_available": false}}], "support_escalation": {"escalation_wait_time": {"value": 5, "type": "Type"}, "response_wait_time": {"value": 5, "type": "Type"}, "contact": "Contact"}, "support_type": "SupportType"}, "media": [{"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}], "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "product_kind": "ProductKind", "badges": [{"id": "ID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}, "icon": "Icon", "authority": "Authority", "tag": "Tag", "learn_more_links": {"first_party": "FirstParty", "third_party": "ThirdParty"}, "constraints": [{"type": "Type", "rule": "anyValue"}]}]}]}`)
				}))
			})
			It(`Invoke ListOfferings successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.ListOfferings(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListOfferingsOptions model
				listOfferingsOptionsModel := new(catalogmanagementv1.ListOfferingsOptions)
				listOfferingsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listOfferingsOptionsModel.Digest = core.BoolPtr(true)
				listOfferingsOptionsModel.Limit = core.Int64Ptr(int64(1000))
				listOfferingsOptionsModel.Offset = core.Int64Ptr(int64(38))
				listOfferingsOptionsModel.Name = core.StringPtr("testString")
				listOfferingsOptionsModel.Sort = core.StringPtr("testString")
				listOfferingsOptionsModel.IncludeHidden = core.BoolPtr(true)
				listOfferingsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.ListOfferings(listOfferingsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListOfferings with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListOfferingsOptions model
				listOfferingsOptionsModel := new(catalogmanagementv1.ListOfferingsOptions)
				listOfferingsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listOfferingsOptionsModel.Digest = core.BoolPtr(true)
				listOfferingsOptionsModel.Limit = core.Int64Ptr(int64(1000))
				listOfferingsOptionsModel.Offset = core.Int64Ptr(int64(38))
				listOfferingsOptionsModel.Name = core.StringPtr("testString")
				listOfferingsOptionsModel.Sort = core.StringPtr("testString")
				listOfferingsOptionsModel.IncludeHidden = core.BoolPtr(true)
				listOfferingsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.ListOfferings(listOfferingsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ListOfferingsOptions model with no property values
				listOfferingsOptionsModelNew := new(catalogmanagementv1.ListOfferingsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.ListOfferings(listOfferingsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListOfferings successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListOfferingsOptions model
				listOfferingsOptionsModel := new(catalogmanagementv1.ListOfferingsOptions)
				listOfferingsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listOfferingsOptionsModel.Digest = core.BoolPtr(true)
				listOfferingsOptionsModel.Limit = core.Int64Ptr(int64(1000))
				listOfferingsOptionsModel.Offset = core.Int64Ptr(int64(38))
				listOfferingsOptionsModel.Name = core.StringPtr("testString")
				listOfferingsOptionsModel.Sort = core.StringPtr("testString")
				listOfferingsOptionsModel.IncludeHidden = core.BoolPtr(true)
				listOfferingsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.ListOfferings(listOfferingsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateOffering(createOfferingOptions *CreateOfferingOptions) - Operation response error`, func() {
		createOfferingPath := "/catalogs/testString/offerings"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createOfferingPath))
					Expect(req.Method).To(Equal("POST"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateOffering with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Rating model
				ratingModel := new(catalogmanagementv1.Rating)
				ratingModel.OneStarCount = core.Int64Ptr(int64(38))
				ratingModel.TwoStarCount = core.Int64Ptr(int64(38))
				ratingModel.ThreeStarCount = core.Int64Ptr(int64(38))
				ratingModel.FourStarCount = core.Int64Ptr(int64(38))

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = make(map[string]string)
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = make(map[string]string)

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = make(map[string]string)
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the RenderTypeAssociationsParametersItem model
				renderTypeAssociationsParametersItemModel := new(catalogmanagementv1.RenderTypeAssociationsParametersItem)
				renderTypeAssociationsParametersItemModel.Name = core.StringPtr("testString")
				renderTypeAssociationsParametersItemModel.OptionsRefresh = core.BoolPtr(true)

				// Construct an instance of the RenderTypeAssociations model
				renderTypeAssociationsModel := new(catalogmanagementv1.RenderTypeAssociations)
				renderTypeAssociationsModel.Parameters = []catalogmanagementv1.RenderTypeAssociationsParametersItem{*renderTypeAssociationsParametersItemModel}

				// Construct an instance of the RenderType model
				renderTypeModel := new(catalogmanagementv1.RenderType)
				renderTypeModel.Type = core.StringPtr("testString")
				renderTypeModel.Grouping = core.StringPtr("testString")
				renderTypeModel.OriginalGrouping = core.StringPtr("testString")
				renderTypeModel.GroupingIndex = core.Int64Ptr(int64(38))
				renderTypeModel.ConfigConstraints = map[string]interface{}{"anyKey": "anyValue"}
				renderTypeModel.Associations = renderTypeAssociationsModel

				// Construct an instance of the Configuration model
				configurationModel := new(catalogmanagementv1.Configuration)
				configurationModel.Key = core.StringPtr("testString")
				configurationModel.Type = core.StringPtr("testString")
				configurationModel.DefaultValue = core.StringPtr("testString")
				configurationModel.DisplayName = core.StringPtr("testString")
				configurationModel.ValueConstraint = core.StringPtr("testString")
				configurationModel.Description = core.StringPtr("testString")
				configurationModel.Required = core.BoolPtr(true)
				configurationModel.Options = []interface{}{"testString"}
				configurationModel.Hidden = core.BoolPtr(true)
				configurationModel.CustomConfig = renderTypeModel
				configurationModel.TypeMetadata = core.StringPtr("testString")

				// Construct an instance of the Output model
				outputModel := new(catalogmanagementv1.Output)
				outputModel.Key = core.StringPtr("testString")
				outputModel.Description = core.StringPtr("testString")

				// Construct an instance of the IamResource model
				iamResourceModel := new(catalogmanagementv1.IamResource)
				iamResourceModel.Name = core.StringPtr("testString")
				iamResourceModel.Description = core.StringPtr("testString")
				iamResourceModel.RoleCrns = []string{"testString"}

				// Construct an instance of the IamPermission model
				iamPermissionModel := new(catalogmanagementv1.IamPermission)
				iamPermissionModel.ServiceName = core.StringPtr("testString")
				iamPermissionModel.RoleCrns = []string{"testString"}
				iamPermissionModel.Resources = []catalogmanagementv1.IamResource{*iamResourceModel}

				// Construct an instance of the Validation model
				validationModel := new(catalogmanagementv1.Validation)
				validationModel.Validated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.Requested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.State = core.StringPtr("testString")
				validationModel.LastOperation = core.StringPtr("testString")
				validationModel.Target = make(map[string]interface{})
				validationModel.Message = core.StringPtr("testString")

				// Construct an instance of the Resource model
				resourceModel := new(catalogmanagementv1.Resource)
				resourceModel.Type = core.StringPtr("mem")
				resourceModel.Value = core.StringPtr("testString")

				// Construct an instance of the Script model
				scriptModel := new(catalogmanagementv1.Script)
				scriptModel.Instructions = core.StringPtr("testString")
				scriptModel.InstructionsI18n = make(map[string]string)
				scriptModel.Script = core.StringPtr("testString")
				scriptModel.ScriptPermission = core.StringPtr("testString")
				scriptModel.DeleteScript = core.StringPtr("testString")
				scriptModel.Scope = core.StringPtr("testString")

				// Construct an instance of the VersionEntitlement model
				versionEntitlementModel := new(catalogmanagementv1.VersionEntitlement)
				versionEntitlementModel.ProviderName = core.StringPtr("testString")
				versionEntitlementModel.ProviderID = core.StringPtr("testString")
				versionEntitlementModel.ProductID = core.StringPtr("testString")
				versionEntitlementModel.PartNumbers = []string{"testString"}
				versionEntitlementModel.ImageRepoName = core.StringPtr("testString")

				// Construct an instance of the License model
				licenseModel := new(catalogmanagementv1.License)
				licenseModel.ID = core.StringPtr("testString")
				licenseModel.Name = core.StringPtr("testString")
				licenseModel.Type = core.StringPtr("testString")
				licenseModel.URL = core.StringPtr("testString")
				licenseModel.Description = core.StringPtr("testString")

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")

				// Construct an instance of the DeprecatePending model
				deprecatePendingModel := new(catalogmanagementv1.DeprecatePending)
				deprecatePendingModel.DeprecateDate = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				deprecatePendingModel.DeprecateState = core.StringPtr("testString")
				deprecatePendingModel.Description = core.StringPtr("testString")

				// Construct an instance of the URLProxy model
				urlProxyModel := new(catalogmanagementv1.URLProxy)
				urlProxyModel.URL = core.StringPtr("testString")
				urlProxyModel.Sha = core.StringPtr("testString")

				// Construct an instance of the MediaItem model
				mediaItemModel := new(catalogmanagementv1.MediaItem)
				mediaItemModel.URL = core.StringPtr("testString")
				mediaItemModel.APIURL = core.StringPtr("testString")
				mediaItemModel.URLProxy = urlProxyModel
				mediaItemModel.Caption = core.StringPtr("testString")
				mediaItemModel.CaptionI18n = make(map[string]string)
				mediaItemModel.Type = core.StringPtr("testString")
				mediaItemModel.ThumbnailURL = core.StringPtr("testString")

				// Construct an instance of the ArchitectureDiagram model
				architectureDiagramModel := new(catalogmanagementv1.ArchitectureDiagram)
				architectureDiagramModel.Diagram = mediaItemModel
				architectureDiagramModel.Description = core.StringPtr("testString")
				architectureDiagramModel.DescriptionI18n = make(map[string]string)

				// Construct an instance of the CostComponent model
				costComponentModel := new(catalogmanagementv1.CostComponent)
				costComponentModel.Name = core.StringPtr("testString")
				costComponentModel.Unit = core.StringPtr("testString")
				costComponentModel.HourlyQuantity = core.StringPtr("testString")
				costComponentModel.MonthlyQuantity = core.StringPtr("testString")
				costComponentModel.Price = core.StringPtr("testString")
				costComponentModel.HourlyCost = core.StringPtr("testString")
				costComponentModel.MonthlyCost = core.StringPtr("testString")

				// Construct an instance of the CostResource model
				costResourceModel := new(catalogmanagementv1.CostResource)
				costResourceModel.Name = core.StringPtr("testString")
				costResourceModel.Metadata = make(map[string]interface{})
				costResourceModel.HourlyCost = core.StringPtr("testString")
				costResourceModel.MonthlyCost = core.StringPtr("testString")
				costResourceModel.CostComponents = []catalogmanagementv1.CostComponent{*costComponentModel}

				// Construct an instance of the CostBreakdown model
				costBreakdownModel := new(catalogmanagementv1.CostBreakdown)
				costBreakdownModel.TotalHourlyCost = core.StringPtr("testString")
				costBreakdownModel.TotalMonthlyCOst = core.StringPtr("testString")
				costBreakdownModel.Resources = []catalogmanagementv1.CostResource{*costResourceModel}

				// Construct an instance of the CostSummary model
				costSummaryModel := new(catalogmanagementv1.CostSummary)
				costSummaryModel.TotalDetectedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalSupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUnsupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUsageBasedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalNoPriceResources = core.Int64Ptr(int64(38))
				costSummaryModel.UnsupportedResourceCounts = make(map[string]int64)
				costSummaryModel.NoPriceResourceCounts = make(map[string]int64)

				// Construct an instance of the Project model
				projectModel := new(catalogmanagementv1.Project)
				projectModel.Name = core.StringPtr("testString")
				projectModel.Metadata = make(map[string]interface{})
				projectModel.PastBreakdown = costBreakdownModel
				projectModel.Breakdown = costBreakdownModel
				projectModel.Diff = costBreakdownModel
				projectModel.Summary = costSummaryModel

				// Construct an instance of the CostEstimate model
				costEstimateModel := new(catalogmanagementv1.CostEstimate)
				costEstimateModel.Version = core.StringPtr("testString")
				costEstimateModel.Currency = core.StringPtr("testString")
				costEstimateModel.Projects = []catalogmanagementv1.Project{*projectModel}
				costEstimateModel.Summary = costSummaryModel
				costEstimateModel.TotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.TotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.TimeGenerated = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the Dependency model
				dependencyModel := new(catalogmanagementv1.Dependency)
				dependencyModel.CatalogID = core.StringPtr("testString")
				dependencyModel.ID = core.StringPtr("testString")
				dependencyModel.Name = core.StringPtr("testString")
				dependencyModel.Version = core.StringPtr("testString")
				dependencyModel.Flavors = []string{"testString"}

				// Construct an instance of the SolutionInfo model
				solutionInfoModel := new(catalogmanagementv1.SolutionInfo)
				solutionInfoModel.ArchitectureDiagrams = []catalogmanagementv1.ArchitectureDiagram{*architectureDiagramModel}
				solutionInfoModel.Features = []catalogmanagementv1.Feature{*featureModel}
				solutionInfoModel.CostEstimate = costEstimateModel
				solutionInfoModel.Dependencies = []catalogmanagementv1.Dependency{*dependencyModel}

				// Construct an instance of the Version model
				versionModel := new(catalogmanagementv1.Version)
				versionModel.ID = core.StringPtr("testString")
				versionModel.Rev = core.StringPtr("testString")
				versionModel.CRN = core.StringPtr("testString")
				versionModel.Version = core.StringPtr("testString")
				versionModel.Flavor = flavorModel
				versionModel.Sha = core.StringPtr("testString")
				versionModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.OfferingID = core.StringPtr("testString")
				versionModel.CatalogID = core.StringPtr("testString")
				versionModel.KindID = core.StringPtr("testString")
				versionModel.Tags = []string{"testString"}
				versionModel.RepoURL = core.StringPtr("testString")
				versionModel.SourceURL = core.StringPtr("testString")
				versionModel.TgzURL = core.StringPtr("testString")
				versionModel.Configuration = []catalogmanagementv1.Configuration{*configurationModel}
				versionModel.Outputs = []catalogmanagementv1.Output{*outputModel}
				versionModel.IamPermissions = []catalogmanagementv1.IamPermission{*iamPermissionModel}
				versionModel.Metadata = make(map[string]interface{})
				versionModel.Validation = validationModel
				versionModel.RequiredResources = []catalogmanagementv1.Resource{*resourceModel}
				versionModel.SingleInstance = core.BoolPtr(true)
				versionModel.Install = scriptModel
				versionModel.PreInstall = []catalogmanagementv1.Script{*scriptModel}
				versionModel.Entitlement = versionEntitlementModel
				versionModel.Licenses = []catalogmanagementv1.License{*licenseModel}
				versionModel.ImageManifestURL = core.StringPtr("testString")
				versionModel.Deprecated = core.BoolPtr(true)
				versionModel.PackageVersion = core.StringPtr("testString")
				versionModel.State = stateModel
				versionModel.VersionLocator = core.StringPtr("testString")
				versionModel.LongDescription = core.StringPtr("testString")
				versionModel.LongDescriptionI18n = make(map[string]string)
				versionModel.WhitelistedAccounts = []string{"testString"}
				versionModel.ImagePullKeyName = core.StringPtr("testString")
				versionModel.DeprecatePending = deprecatePendingModel
				versionModel.SolutionInfo = solutionInfoModel
				versionModel.IsConsumable = core.BoolPtr(true)

				// Construct an instance of the Deployment model
				deploymentModel := new(catalogmanagementv1.Deployment)
				deploymentModel.ID = core.StringPtr("testString")
				deploymentModel.Label = core.StringPtr("testString")
				deploymentModel.Name = core.StringPtr("testString")
				deploymentModel.ShortDescription = core.StringPtr("testString")
				deploymentModel.LongDescription = core.StringPtr("testString")
				deploymentModel.Metadata = make(map[string]interface{})
				deploymentModel.Tags = []string{"testString"}
				deploymentModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				deploymentModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the Plan model
				planModel := new(catalogmanagementv1.Plan)
				planModel.ID = core.StringPtr("testString")
				planModel.Label = core.StringPtr("testString")
				planModel.Name = core.StringPtr("testString")
				planModel.ShortDescription = core.StringPtr("testString")
				planModel.LongDescription = core.StringPtr("testString")
				planModel.Metadata = make(map[string]interface{})
				planModel.Tags = []string{"testString"}
				planModel.AdditionalFeatures = []catalogmanagementv1.Feature{*featureModel}
				planModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.Deployments = []catalogmanagementv1.Deployment{*deploymentModel}

				// Construct an instance of the Kind model
				kindModel := new(catalogmanagementv1.Kind)
				kindModel.ID = core.StringPtr("testString")
				kindModel.FormatKind = core.StringPtr("testString")
				kindModel.InstallKind = core.StringPtr("testString")
				kindModel.TargetKind = core.StringPtr("testString")
				kindModel.Metadata = make(map[string]interface{})
				kindModel.Tags = []string{"testString"}
				kindModel.AdditionalFeatures = []catalogmanagementv1.Feature{*featureModel}
				kindModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Versions = []catalogmanagementv1.Version{*versionModel}
				kindModel.Plans = []catalogmanagementv1.Plan{*planModel}

				// Construct an instance of the ProviderInfo model
				providerInfoModel := new(catalogmanagementv1.ProviderInfo)
				providerInfoModel.ID = core.StringPtr("testString")
				providerInfoModel.Name = core.StringPtr("testString")

				// Construct an instance of the RepoInfo model
				repoInfoModel := new(catalogmanagementv1.RepoInfo)
				repoInfoModel.Token = core.StringPtr("testString")
				repoInfoModel.Type = core.StringPtr("testString")

				// Construct an instance of the ImagePullKey model
				imagePullKeyModel := new(catalogmanagementv1.ImagePullKey)
				imagePullKeyModel.Name = core.StringPtr("testString")
				imagePullKeyModel.Value = core.StringPtr("testString")
				imagePullKeyModel.Description = core.StringPtr("testString")

				// Construct an instance of the SupportWaitTime model
				supportWaitTimeModel := new(catalogmanagementv1.SupportWaitTime)
				supportWaitTimeModel.Value = core.Int64Ptr(int64(38))
				supportWaitTimeModel.Type = core.StringPtr("testString")

				// Construct an instance of the SupportTime model
				supportTimeModel := new(catalogmanagementv1.SupportTime)
				supportTimeModel.Day = core.Int64Ptr(int64(38))
				supportTimeModel.StartTime = core.StringPtr("testString")
				supportTimeModel.EndTime = core.StringPtr("testString")

				// Construct an instance of the SupportAvailability model
				supportAvailabilityModel := new(catalogmanagementv1.SupportAvailability)
				supportAvailabilityModel.Times = []catalogmanagementv1.SupportTime{*supportTimeModel}
				supportAvailabilityModel.Timezone = core.StringPtr("testString")
				supportAvailabilityModel.AlwaysAvailable = core.BoolPtr(true)

				// Construct an instance of the SupportDetail model
				supportDetailModel := new(catalogmanagementv1.SupportDetail)
				supportDetailModel.Type = core.StringPtr("testString")
				supportDetailModel.Contact = core.StringPtr("testString")
				supportDetailModel.ResponseWaitTime = supportWaitTimeModel
				supportDetailModel.Availability = supportAvailabilityModel

				// Construct an instance of the SupportEscalation model
				supportEscalationModel := new(catalogmanagementv1.SupportEscalation)
				supportEscalationModel.EscalationWaitTime = supportWaitTimeModel
				supportEscalationModel.ResponseWaitTime = supportWaitTimeModel
				supportEscalationModel.Contact = core.StringPtr("testString")

				// Construct an instance of the Support model
				supportModel := new(catalogmanagementv1.Support)
				supportModel.URL = core.StringPtr("testString")
				supportModel.Process = core.StringPtr("testString")
				supportModel.ProcessI18n = make(map[string]string)
				supportModel.Locations = []string{"testString"}
				supportModel.SupportDetails = []catalogmanagementv1.SupportDetail{*supportDetailModel}
				supportModel.SupportEscalation = supportEscalationModel
				supportModel.SupportType = core.StringPtr("testString")

				// Construct an instance of the LearnMoreLinks model
				learnMoreLinksModel := new(catalogmanagementv1.LearnMoreLinks)
				learnMoreLinksModel.FirstParty = core.StringPtr("testString")
				learnMoreLinksModel.ThirdParty = core.StringPtr("testString")

				// Construct an instance of the Constraint model
				constraintModel := new(catalogmanagementv1.Constraint)
				constraintModel.Type = core.StringPtr("testString")
				constraintModel.Rule = core.StringPtr("testString")

				// Construct an instance of the Badge model
				badgeModel := new(catalogmanagementv1.Badge)
				badgeModel.ID = core.StringPtr("testString")
				badgeModel.Label = core.StringPtr("testString")
				badgeModel.LabelI18n = make(map[string]string)
				badgeModel.Description = core.StringPtr("testString")
				badgeModel.DescriptionI18n = make(map[string]string)
				badgeModel.Icon = core.StringPtr("testString")
				badgeModel.Authority = core.StringPtr("testString")
				badgeModel.Tag = core.StringPtr("testString")
				badgeModel.LearnMoreLinks = learnMoreLinksModel
				badgeModel.Constraints = []catalogmanagementv1.Constraint{*constraintModel}

				// Construct an instance of the CreateOfferingOptions model
				createOfferingOptionsModel := new(catalogmanagementv1.CreateOfferingOptions)
				createOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				createOfferingOptionsModel.ID = core.StringPtr("testString")
				createOfferingOptionsModel.Rev = core.StringPtr("testString")
				createOfferingOptionsModel.URL = core.StringPtr("testString")
				createOfferingOptionsModel.CRN = core.StringPtr("testString")
				createOfferingOptionsModel.Label = core.StringPtr("testString")
				createOfferingOptionsModel.LabelI18n = make(map[string]string)
				createOfferingOptionsModel.Name = core.StringPtr("testString")
				createOfferingOptionsModel.OfferingIconURL = core.StringPtr("testString")
				createOfferingOptionsModel.OfferingDocsURL = core.StringPtr("testString")
				createOfferingOptionsModel.OfferingSupportURL = core.StringPtr("testString")
				createOfferingOptionsModel.Tags = []string{"testString"}
				createOfferingOptionsModel.Keywords = []string{"testString"}
				createOfferingOptionsModel.Rating = ratingModel
				createOfferingOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createOfferingOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createOfferingOptionsModel.ShortDescription = core.StringPtr("testString")
				createOfferingOptionsModel.ShortDescriptionI18n = make(map[string]string)
				createOfferingOptionsModel.LongDescription = core.StringPtr("testString")
				createOfferingOptionsModel.LongDescriptionI18n = make(map[string]string)
				createOfferingOptionsModel.Features = []catalogmanagementv1.Feature{*featureModel}
				createOfferingOptionsModel.Kinds = []catalogmanagementv1.Kind{*kindModel}
				createOfferingOptionsModel.PcManaged = core.BoolPtr(true)
				createOfferingOptionsModel.PublishApproved = core.BoolPtr(true)
				createOfferingOptionsModel.ShareWithAll = core.BoolPtr(true)
				createOfferingOptionsModel.ShareWithIBM = core.BoolPtr(true)
				createOfferingOptionsModel.ShareEnabled = core.BoolPtr(true)
				createOfferingOptionsModel.PermitRequestIBMPublicPublish = core.BoolPtr(true)
				createOfferingOptionsModel.IBMPublishApproved = core.BoolPtr(true)
				createOfferingOptionsModel.PublicPublishApproved = core.BoolPtr(true)
				createOfferingOptionsModel.PublicOriginalCRN = core.StringPtr("testString")
				createOfferingOptionsModel.PublishPublicCRN = core.StringPtr("testString")
				createOfferingOptionsModel.PortalApprovalRecord = core.StringPtr("testString")
				createOfferingOptionsModel.PortalUIURL = core.StringPtr("testString")
				createOfferingOptionsModel.CatalogID = core.StringPtr("testString")
				createOfferingOptionsModel.CatalogName = core.StringPtr("testString")
				createOfferingOptionsModel.Metadata = make(map[string]interface{})
				createOfferingOptionsModel.Disclaimer = core.StringPtr("testString")
				createOfferingOptionsModel.Hidden = core.BoolPtr(true)
				createOfferingOptionsModel.Provider = core.StringPtr("testString")
				createOfferingOptionsModel.ProviderInfo = providerInfoModel
				createOfferingOptionsModel.RepoInfo = repoInfoModel
				createOfferingOptionsModel.ImagePullKeys = []catalogmanagementv1.ImagePullKey{*imagePullKeyModel}
				createOfferingOptionsModel.Support = supportModel
				createOfferingOptionsModel.Media = []catalogmanagementv1.MediaItem{*mediaItemModel}
				createOfferingOptionsModel.DeprecatePending = deprecatePendingModel
				createOfferingOptionsModel.ProductKind = core.StringPtr("testString")
				createOfferingOptionsModel.Badges = []catalogmanagementv1.Badge{*badgeModel}
				createOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.CreateOffering(createOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.CreateOffering(createOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateOffering(createOfferingOptions *CreateOfferingOptions)`, func() {
		createOfferingPath := "/catalogs/testString/offerings"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createOfferingPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "offering_icon_url": "OfferingIconURL", "offering_docs_url": "OfferingDocsURL", "offering_support_url": "OfferingSupportURL", "tags": ["Tags"], "keywords": ["Keywords"], "rating": {"one_star_count": 12, "two_star_count": 12, "three_star_count": 14, "four_star_count": 13}, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "kinds": [{"id": "ID", "format_kind": "FormatKind", "install_kind": "InstallKind", "target_kind": "TargetKind", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"mapKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"mapKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "version": "Version", "flavors": ["Flavors"]}]}, "is_consumable": true}], "plans": [{"id": "ID", "label": "Label", "name": "Name", "short_description": "ShortDescription", "long_description": "LongDescription", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "deployments": [{"id": "ID", "label": "Label", "name": "Name", "short_description": "ShortDescription", "long_description": "LongDescription", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z"}]}]}], "pc_managed": false, "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "permit_request_ibm_public_publish": false, "ibm_publish_approved": true, "public_publish_approved": false, "public_original_crn": "PublicOriginalCRN", "publish_public_crn": "PublishPublicCRN", "portal_approval_record": "PortalApprovalRecord", "portal_ui_url": "PortalUIURL", "catalog_id": "CatalogID", "catalog_name": "CatalogName", "metadata": {"mapKey": "anyValue"}, "disclaimer": "Disclaimer", "hidden": true, "provider": "Provider", "provider_info": {"id": "ID", "name": "Name"}, "repo_info": {"token": "Token", "type": "Type"}, "image_pull_keys": [{"name": "Name", "value": "Value", "description": "Description"}], "support": {"url": "URL", "process": "Process", "process_i18n": {"mapKey": "Inner"}, "locations": ["Locations"], "support_details": [{"type": "Type", "contact": "Contact", "response_wait_time": {"value": 5, "type": "Type"}, "availability": {"times": [{"day": 3, "start_time": "StartTime", "end_time": "EndTime"}], "timezone": "Timezone", "always_available": false}}], "support_escalation": {"escalation_wait_time": {"value": 5, "type": "Type"}, "response_wait_time": {"value": 5, "type": "Type"}, "contact": "Contact"}, "support_type": "SupportType"}, "media": [{"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}], "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "product_kind": "ProductKind", "badges": [{"id": "ID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}, "icon": "Icon", "authority": "Authority", "tag": "Tag", "learn_more_links": {"first_party": "FirstParty", "third_party": "ThirdParty"}, "constraints": [{"type": "Type", "rule": "anyValue"}]}]}`)
				}))
			})
			It(`Invoke CreateOffering successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the Rating model
				ratingModel := new(catalogmanagementv1.Rating)
				ratingModel.OneStarCount = core.Int64Ptr(int64(38))
				ratingModel.TwoStarCount = core.Int64Ptr(int64(38))
				ratingModel.ThreeStarCount = core.Int64Ptr(int64(38))
				ratingModel.FourStarCount = core.Int64Ptr(int64(38))

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = make(map[string]string)
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = make(map[string]string)

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = make(map[string]string)
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the RenderTypeAssociationsParametersItem model
				renderTypeAssociationsParametersItemModel := new(catalogmanagementv1.RenderTypeAssociationsParametersItem)
				renderTypeAssociationsParametersItemModel.Name = core.StringPtr("testString")
				renderTypeAssociationsParametersItemModel.OptionsRefresh = core.BoolPtr(true)

				// Construct an instance of the RenderTypeAssociations model
				renderTypeAssociationsModel := new(catalogmanagementv1.RenderTypeAssociations)
				renderTypeAssociationsModel.Parameters = []catalogmanagementv1.RenderTypeAssociationsParametersItem{*renderTypeAssociationsParametersItemModel}

				// Construct an instance of the RenderType model
				renderTypeModel := new(catalogmanagementv1.RenderType)
				renderTypeModel.Type = core.StringPtr("testString")
				renderTypeModel.Grouping = core.StringPtr("testString")
				renderTypeModel.OriginalGrouping = core.StringPtr("testString")
				renderTypeModel.GroupingIndex = core.Int64Ptr(int64(38))
				renderTypeModel.ConfigConstraints = map[string]interface{}{"anyKey": "anyValue"}
				renderTypeModel.Associations = renderTypeAssociationsModel

				// Construct an instance of the Configuration model
				configurationModel := new(catalogmanagementv1.Configuration)
				configurationModel.Key = core.StringPtr("testString")
				configurationModel.Type = core.StringPtr("testString")
				configurationModel.DefaultValue = core.StringPtr("testString")
				configurationModel.DisplayName = core.StringPtr("testString")
				configurationModel.ValueConstraint = core.StringPtr("testString")
				configurationModel.Description = core.StringPtr("testString")
				configurationModel.Required = core.BoolPtr(true)
				configurationModel.Options = []interface{}{"testString"}
				configurationModel.Hidden = core.BoolPtr(true)
				configurationModel.CustomConfig = renderTypeModel
				configurationModel.TypeMetadata = core.StringPtr("testString")

				// Construct an instance of the Output model
				outputModel := new(catalogmanagementv1.Output)
				outputModel.Key = core.StringPtr("testString")
				outputModel.Description = core.StringPtr("testString")

				// Construct an instance of the IamResource model
				iamResourceModel := new(catalogmanagementv1.IamResource)
				iamResourceModel.Name = core.StringPtr("testString")
				iamResourceModel.Description = core.StringPtr("testString")
				iamResourceModel.RoleCrns = []string{"testString"}

				// Construct an instance of the IamPermission model
				iamPermissionModel := new(catalogmanagementv1.IamPermission)
				iamPermissionModel.ServiceName = core.StringPtr("testString")
				iamPermissionModel.RoleCrns = []string{"testString"}
				iamPermissionModel.Resources = []catalogmanagementv1.IamResource{*iamResourceModel}

				// Construct an instance of the Validation model
				validationModel := new(catalogmanagementv1.Validation)
				validationModel.Validated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.Requested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.State = core.StringPtr("testString")
				validationModel.LastOperation = core.StringPtr("testString")
				validationModel.Target = make(map[string]interface{})
				validationModel.Message = core.StringPtr("testString")

				// Construct an instance of the Resource model
				resourceModel := new(catalogmanagementv1.Resource)
				resourceModel.Type = core.StringPtr("mem")
				resourceModel.Value = core.StringPtr("testString")

				// Construct an instance of the Script model
				scriptModel := new(catalogmanagementv1.Script)
				scriptModel.Instructions = core.StringPtr("testString")
				scriptModel.InstructionsI18n = make(map[string]string)
				scriptModel.Script = core.StringPtr("testString")
				scriptModel.ScriptPermission = core.StringPtr("testString")
				scriptModel.DeleteScript = core.StringPtr("testString")
				scriptModel.Scope = core.StringPtr("testString")

				// Construct an instance of the VersionEntitlement model
				versionEntitlementModel := new(catalogmanagementv1.VersionEntitlement)
				versionEntitlementModel.ProviderName = core.StringPtr("testString")
				versionEntitlementModel.ProviderID = core.StringPtr("testString")
				versionEntitlementModel.ProductID = core.StringPtr("testString")
				versionEntitlementModel.PartNumbers = []string{"testString"}
				versionEntitlementModel.ImageRepoName = core.StringPtr("testString")

				// Construct an instance of the License model
				licenseModel := new(catalogmanagementv1.License)
				licenseModel.ID = core.StringPtr("testString")
				licenseModel.Name = core.StringPtr("testString")
				licenseModel.Type = core.StringPtr("testString")
				licenseModel.URL = core.StringPtr("testString")
				licenseModel.Description = core.StringPtr("testString")

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")

				// Construct an instance of the DeprecatePending model
				deprecatePendingModel := new(catalogmanagementv1.DeprecatePending)
				deprecatePendingModel.DeprecateDate = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				deprecatePendingModel.DeprecateState = core.StringPtr("testString")
				deprecatePendingModel.Description = core.StringPtr("testString")

				// Construct an instance of the URLProxy model
				urlProxyModel := new(catalogmanagementv1.URLProxy)
				urlProxyModel.URL = core.StringPtr("testString")
				urlProxyModel.Sha = core.StringPtr("testString")

				// Construct an instance of the MediaItem model
				mediaItemModel := new(catalogmanagementv1.MediaItem)
				mediaItemModel.URL = core.StringPtr("testString")
				mediaItemModel.APIURL = core.StringPtr("testString")
				mediaItemModel.URLProxy = urlProxyModel
				mediaItemModel.Caption = core.StringPtr("testString")
				mediaItemModel.CaptionI18n = make(map[string]string)
				mediaItemModel.Type = core.StringPtr("testString")
				mediaItemModel.ThumbnailURL = core.StringPtr("testString")

				// Construct an instance of the ArchitectureDiagram model
				architectureDiagramModel := new(catalogmanagementv1.ArchitectureDiagram)
				architectureDiagramModel.Diagram = mediaItemModel
				architectureDiagramModel.Description = core.StringPtr("testString")
				architectureDiagramModel.DescriptionI18n = make(map[string]string)

				// Construct an instance of the CostComponent model
				costComponentModel := new(catalogmanagementv1.CostComponent)
				costComponentModel.Name = core.StringPtr("testString")
				costComponentModel.Unit = core.StringPtr("testString")
				costComponentModel.HourlyQuantity = core.StringPtr("testString")
				costComponentModel.MonthlyQuantity = core.StringPtr("testString")
				costComponentModel.Price = core.StringPtr("testString")
				costComponentModel.HourlyCost = core.StringPtr("testString")
				costComponentModel.MonthlyCost = core.StringPtr("testString")

				// Construct an instance of the CostResource model
				costResourceModel := new(catalogmanagementv1.CostResource)
				costResourceModel.Name = core.StringPtr("testString")
				costResourceModel.Metadata = make(map[string]interface{})
				costResourceModel.HourlyCost = core.StringPtr("testString")
				costResourceModel.MonthlyCost = core.StringPtr("testString")
				costResourceModel.CostComponents = []catalogmanagementv1.CostComponent{*costComponentModel}

				// Construct an instance of the CostBreakdown model
				costBreakdownModel := new(catalogmanagementv1.CostBreakdown)
				costBreakdownModel.TotalHourlyCost = core.StringPtr("testString")
				costBreakdownModel.TotalMonthlyCOst = core.StringPtr("testString")
				costBreakdownModel.Resources = []catalogmanagementv1.CostResource{*costResourceModel}

				// Construct an instance of the CostSummary model
				costSummaryModel := new(catalogmanagementv1.CostSummary)
				costSummaryModel.TotalDetectedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalSupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUnsupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUsageBasedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalNoPriceResources = core.Int64Ptr(int64(38))
				costSummaryModel.UnsupportedResourceCounts = make(map[string]int64)
				costSummaryModel.NoPriceResourceCounts = make(map[string]int64)

				// Construct an instance of the Project model
				projectModel := new(catalogmanagementv1.Project)
				projectModel.Name = core.StringPtr("testString")
				projectModel.Metadata = make(map[string]interface{})
				projectModel.PastBreakdown = costBreakdownModel
				projectModel.Breakdown = costBreakdownModel
				projectModel.Diff = costBreakdownModel
				projectModel.Summary = costSummaryModel

				// Construct an instance of the CostEstimate model
				costEstimateModel := new(catalogmanagementv1.CostEstimate)
				costEstimateModel.Version = core.StringPtr("testString")
				costEstimateModel.Currency = core.StringPtr("testString")
				costEstimateModel.Projects = []catalogmanagementv1.Project{*projectModel}
				costEstimateModel.Summary = costSummaryModel
				costEstimateModel.TotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.TotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.TimeGenerated = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the Dependency model
				dependencyModel := new(catalogmanagementv1.Dependency)
				dependencyModel.CatalogID = core.StringPtr("testString")
				dependencyModel.ID = core.StringPtr("testString")
				dependencyModel.Name = core.StringPtr("testString")
				dependencyModel.Version = core.StringPtr("testString")
				dependencyModel.Flavors = []string{"testString"}

				// Construct an instance of the SolutionInfo model
				solutionInfoModel := new(catalogmanagementv1.SolutionInfo)
				solutionInfoModel.ArchitectureDiagrams = []catalogmanagementv1.ArchitectureDiagram{*architectureDiagramModel}
				solutionInfoModel.Features = []catalogmanagementv1.Feature{*featureModel}
				solutionInfoModel.CostEstimate = costEstimateModel
				solutionInfoModel.Dependencies = []catalogmanagementv1.Dependency{*dependencyModel}

				// Construct an instance of the Version model
				versionModel := new(catalogmanagementv1.Version)
				versionModel.ID = core.StringPtr("testString")
				versionModel.Rev = core.StringPtr("testString")
				versionModel.CRN = core.StringPtr("testString")
				versionModel.Version = core.StringPtr("testString")
				versionModel.Flavor = flavorModel
				versionModel.Sha = core.StringPtr("testString")
				versionModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.OfferingID = core.StringPtr("testString")
				versionModel.CatalogID = core.StringPtr("testString")
				versionModel.KindID = core.StringPtr("testString")
				versionModel.Tags = []string{"testString"}
				versionModel.RepoURL = core.StringPtr("testString")
				versionModel.SourceURL = core.StringPtr("testString")
				versionModel.TgzURL = core.StringPtr("testString")
				versionModel.Configuration = []catalogmanagementv1.Configuration{*configurationModel}
				versionModel.Outputs = []catalogmanagementv1.Output{*outputModel}
				versionModel.IamPermissions = []catalogmanagementv1.IamPermission{*iamPermissionModel}
				versionModel.Metadata = make(map[string]interface{})
				versionModel.Validation = validationModel
				versionModel.RequiredResources = []catalogmanagementv1.Resource{*resourceModel}
				versionModel.SingleInstance = core.BoolPtr(true)
				versionModel.Install = scriptModel
				versionModel.PreInstall = []catalogmanagementv1.Script{*scriptModel}
				versionModel.Entitlement = versionEntitlementModel
				versionModel.Licenses = []catalogmanagementv1.License{*licenseModel}
				versionModel.ImageManifestURL = core.StringPtr("testString")
				versionModel.Deprecated = core.BoolPtr(true)
				versionModel.PackageVersion = core.StringPtr("testString")
				versionModel.State = stateModel
				versionModel.VersionLocator = core.StringPtr("testString")
				versionModel.LongDescription = core.StringPtr("testString")
				versionModel.LongDescriptionI18n = make(map[string]string)
				versionModel.WhitelistedAccounts = []string{"testString"}
				versionModel.ImagePullKeyName = core.StringPtr("testString")
				versionModel.DeprecatePending = deprecatePendingModel
				versionModel.SolutionInfo = solutionInfoModel
				versionModel.IsConsumable = core.BoolPtr(true)

				// Construct an instance of the Deployment model
				deploymentModel := new(catalogmanagementv1.Deployment)
				deploymentModel.ID = core.StringPtr("testString")
				deploymentModel.Label = core.StringPtr("testString")
				deploymentModel.Name = core.StringPtr("testString")
				deploymentModel.ShortDescription = core.StringPtr("testString")
				deploymentModel.LongDescription = core.StringPtr("testString")
				deploymentModel.Metadata = make(map[string]interface{})
				deploymentModel.Tags = []string{"testString"}
				deploymentModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				deploymentModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the Plan model
				planModel := new(catalogmanagementv1.Plan)
				planModel.ID = core.StringPtr("testString")
				planModel.Label = core.StringPtr("testString")
				planModel.Name = core.StringPtr("testString")
				planModel.ShortDescription = core.StringPtr("testString")
				planModel.LongDescription = core.StringPtr("testString")
				planModel.Metadata = make(map[string]interface{})
				planModel.Tags = []string{"testString"}
				planModel.AdditionalFeatures = []catalogmanagementv1.Feature{*featureModel}
				planModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.Deployments = []catalogmanagementv1.Deployment{*deploymentModel}

				// Construct an instance of the Kind model
				kindModel := new(catalogmanagementv1.Kind)
				kindModel.ID = core.StringPtr("testString")
				kindModel.FormatKind = core.StringPtr("testString")
				kindModel.InstallKind = core.StringPtr("testString")
				kindModel.TargetKind = core.StringPtr("testString")
				kindModel.Metadata = make(map[string]interface{})
				kindModel.Tags = []string{"testString"}
				kindModel.AdditionalFeatures = []catalogmanagementv1.Feature{*featureModel}
				kindModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Versions = []catalogmanagementv1.Version{*versionModel}
				kindModel.Plans = []catalogmanagementv1.Plan{*planModel}

				// Construct an instance of the ProviderInfo model
				providerInfoModel := new(catalogmanagementv1.ProviderInfo)
				providerInfoModel.ID = core.StringPtr("testString")
				providerInfoModel.Name = core.StringPtr("testString")

				// Construct an instance of the RepoInfo model
				repoInfoModel := new(catalogmanagementv1.RepoInfo)
				repoInfoModel.Token = core.StringPtr("testString")
				repoInfoModel.Type = core.StringPtr("testString")

				// Construct an instance of the ImagePullKey model
				imagePullKeyModel := new(catalogmanagementv1.ImagePullKey)
				imagePullKeyModel.Name = core.StringPtr("testString")
				imagePullKeyModel.Value = core.StringPtr("testString")
				imagePullKeyModel.Description = core.StringPtr("testString")

				// Construct an instance of the SupportWaitTime model
				supportWaitTimeModel := new(catalogmanagementv1.SupportWaitTime)
				supportWaitTimeModel.Value = core.Int64Ptr(int64(38))
				supportWaitTimeModel.Type = core.StringPtr("testString")

				// Construct an instance of the SupportTime model
				supportTimeModel := new(catalogmanagementv1.SupportTime)
				supportTimeModel.Day = core.Int64Ptr(int64(38))
				supportTimeModel.StartTime = core.StringPtr("testString")
				supportTimeModel.EndTime = core.StringPtr("testString")

				// Construct an instance of the SupportAvailability model
				supportAvailabilityModel := new(catalogmanagementv1.SupportAvailability)
				supportAvailabilityModel.Times = []catalogmanagementv1.SupportTime{*supportTimeModel}
				supportAvailabilityModel.Timezone = core.StringPtr("testString")
				supportAvailabilityModel.AlwaysAvailable = core.BoolPtr(true)

				// Construct an instance of the SupportDetail model
				supportDetailModel := new(catalogmanagementv1.SupportDetail)
				supportDetailModel.Type = core.StringPtr("testString")
				supportDetailModel.Contact = core.StringPtr("testString")
				supportDetailModel.ResponseWaitTime = supportWaitTimeModel
				supportDetailModel.Availability = supportAvailabilityModel

				// Construct an instance of the SupportEscalation model
				supportEscalationModel := new(catalogmanagementv1.SupportEscalation)
				supportEscalationModel.EscalationWaitTime = supportWaitTimeModel
				supportEscalationModel.ResponseWaitTime = supportWaitTimeModel
				supportEscalationModel.Contact = core.StringPtr("testString")

				// Construct an instance of the Support model
				supportModel := new(catalogmanagementv1.Support)
				supportModel.URL = core.StringPtr("testString")
				supportModel.Process = core.StringPtr("testString")
				supportModel.ProcessI18n = make(map[string]string)
				supportModel.Locations = []string{"testString"}
				supportModel.SupportDetails = []catalogmanagementv1.SupportDetail{*supportDetailModel}
				supportModel.SupportEscalation = supportEscalationModel
				supportModel.SupportType = core.StringPtr("testString")

				// Construct an instance of the LearnMoreLinks model
				learnMoreLinksModel := new(catalogmanagementv1.LearnMoreLinks)
				learnMoreLinksModel.FirstParty = core.StringPtr("testString")
				learnMoreLinksModel.ThirdParty = core.StringPtr("testString")

				// Construct an instance of the Constraint model
				constraintModel := new(catalogmanagementv1.Constraint)
				constraintModel.Type = core.StringPtr("testString")
				constraintModel.Rule = core.StringPtr("testString")

				// Construct an instance of the Badge model
				badgeModel := new(catalogmanagementv1.Badge)
				badgeModel.ID = core.StringPtr("testString")
				badgeModel.Label = core.StringPtr("testString")
				badgeModel.LabelI18n = make(map[string]string)
				badgeModel.Description = core.StringPtr("testString")
				badgeModel.DescriptionI18n = make(map[string]string)
				badgeModel.Icon = core.StringPtr("testString")
				badgeModel.Authority = core.StringPtr("testString")
				badgeModel.Tag = core.StringPtr("testString")
				badgeModel.LearnMoreLinks = learnMoreLinksModel
				badgeModel.Constraints = []catalogmanagementv1.Constraint{*constraintModel}

				// Construct an instance of the CreateOfferingOptions model
				createOfferingOptionsModel := new(catalogmanagementv1.CreateOfferingOptions)
				createOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				createOfferingOptionsModel.ID = core.StringPtr("testString")
				createOfferingOptionsModel.Rev = core.StringPtr("testString")
				createOfferingOptionsModel.URL = core.StringPtr("testString")
				createOfferingOptionsModel.CRN = core.StringPtr("testString")
				createOfferingOptionsModel.Label = core.StringPtr("testString")
				createOfferingOptionsModel.LabelI18n = make(map[string]string)
				createOfferingOptionsModel.Name = core.StringPtr("testString")
				createOfferingOptionsModel.OfferingIconURL = core.StringPtr("testString")
				createOfferingOptionsModel.OfferingDocsURL = core.StringPtr("testString")
				createOfferingOptionsModel.OfferingSupportURL = core.StringPtr("testString")
				createOfferingOptionsModel.Tags = []string{"testString"}
				createOfferingOptionsModel.Keywords = []string{"testString"}
				createOfferingOptionsModel.Rating = ratingModel
				createOfferingOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createOfferingOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createOfferingOptionsModel.ShortDescription = core.StringPtr("testString")
				createOfferingOptionsModel.ShortDescriptionI18n = make(map[string]string)
				createOfferingOptionsModel.LongDescription = core.StringPtr("testString")
				createOfferingOptionsModel.LongDescriptionI18n = make(map[string]string)
				createOfferingOptionsModel.Features = []catalogmanagementv1.Feature{*featureModel}
				createOfferingOptionsModel.Kinds = []catalogmanagementv1.Kind{*kindModel}
				createOfferingOptionsModel.PcManaged = core.BoolPtr(true)
				createOfferingOptionsModel.PublishApproved = core.BoolPtr(true)
				createOfferingOptionsModel.ShareWithAll = core.BoolPtr(true)
				createOfferingOptionsModel.ShareWithIBM = core.BoolPtr(true)
				createOfferingOptionsModel.ShareEnabled = core.BoolPtr(true)
				createOfferingOptionsModel.PermitRequestIBMPublicPublish = core.BoolPtr(true)
				createOfferingOptionsModel.IBMPublishApproved = core.BoolPtr(true)
				createOfferingOptionsModel.PublicPublishApproved = core.BoolPtr(true)
				createOfferingOptionsModel.PublicOriginalCRN = core.StringPtr("testString")
				createOfferingOptionsModel.PublishPublicCRN = core.StringPtr("testString")
				createOfferingOptionsModel.PortalApprovalRecord = core.StringPtr("testString")
				createOfferingOptionsModel.PortalUIURL = core.StringPtr("testString")
				createOfferingOptionsModel.CatalogID = core.StringPtr("testString")
				createOfferingOptionsModel.CatalogName = core.StringPtr("testString")
				createOfferingOptionsModel.Metadata = make(map[string]interface{})
				createOfferingOptionsModel.Disclaimer = core.StringPtr("testString")
				createOfferingOptionsModel.Hidden = core.BoolPtr(true)
				createOfferingOptionsModel.Provider = core.StringPtr("testString")
				createOfferingOptionsModel.ProviderInfo = providerInfoModel
				createOfferingOptionsModel.RepoInfo = repoInfoModel
				createOfferingOptionsModel.ImagePullKeys = []catalogmanagementv1.ImagePullKey{*imagePullKeyModel}
				createOfferingOptionsModel.Support = supportModel
				createOfferingOptionsModel.Media = []catalogmanagementv1.MediaItem{*mediaItemModel}
				createOfferingOptionsModel.DeprecatePending = deprecatePendingModel
				createOfferingOptionsModel.ProductKind = core.StringPtr("testString")
				createOfferingOptionsModel.Badges = []catalogmanagementv1.Badge{*badgeModel}
				createOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.CreateOfferingWithContext(ctx, createOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.CreateOffering(createOfferingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.CreateOfferingWithContext(ctx, createOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createOfferingPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "offering_icon_url": "OfferingIconURL", "offering_docs_url": "OfferingDocsURL", "offering_support_url": "OfferingSupportURL", "tags": ["Tags"], "keywords": ["Keywords"], "rating": {"one_star_count": 12, "two_star_count": 12, "three_star_count": 14, "four_star_count": 13}, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "kinds": [{"id": "ID", "format_kind": "FormatKind", "install_kind": "InstallKind", "target_kind": "TargetKind", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"mapKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"mapKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "version": "Version", "flavors": ["Flavors"]}]}, "is_consumable": true}], "plans": [{"id": "ID", "label": "Label", "name": "Name", "short_description": "ShortDescription", "long_description": "LongDescription", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "deployments": [{"id": "ID", "label": "Label", "name": "Name", "short_description": "ShortDescription", "long_description": "LongDescription", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z"}]}]}], "pc_managed": false, "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "permit_request_ibm_public_publish": false, "ibm_publish_approved": true, "public_publish_approved": false, "public_original_crn": "PublicOriginalCRN", "publish_public_crn": "PublishPublicCRN", "portal_approval_record": "PortalApprovalRecord", "portal_ui_url": "PortalUIURL", "catalog_id": "CatalogID", "catalog_name": "CatalogName", "metadata": {"mapKey": "anyValue"}, "disclaimer": "Disclaimer", "hidden": true, "provider": "Provider", "provider_info": {"id": "ID", "name": "Name"}, "repo_info": {"token": "Token", "type": "Type"}, "image_pull_keys": [{"name": "Name", "value": "Value", "description": "Description"}], "support": {"url": "URL", "process": "Process", "process_i18n": {"mapKey": "Inner"}, "locations": ["Locations"], "support_details": [{"type": "Type", "contact": "Contact", "response_wait_time": {"value": 5, "type": "Type"}, "availability": {"times": [{"day": 3, "start_time": "StartTime", "end_time": "EndTime"}], "timezone": "Timezone", "always_available": false}}], "support_escalation": {"escalation_wait_time": {"value": 5, "type": "Type"}, "response_wait_time": {"value": 5, "type": "Type"}, "contact": "Contact"}, "support_type": "SupportType"}, "media": [{"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}], "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "product_kind": "ProductKind", "badges": [{"id": "ID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}, "icon": "Icon", "authority": "Authority", "tag": "Tag", "learn_more_links": {"first_party": "FirstParty", "third_party": "ThirdParty"}, "constraints": [{"type": "Type", "rule": "anyValue"}]}]}`)
				}))
			})
			It(`Invoke CreateOffering successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.CreateOffering(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the Rating model
				ratingModel := new(catalogmanagementv1.Rating)
				ratingModel.OneStarCount = core.Int64Ptr(int64(38))
				ratingModel.TwoStarCount = core.Int64Ptr(int64(38))
				ratingModel.ThreeStarCount = core.Int64Ptr(int64(38))
				ratingModel.FourStarCount = core.Int64Ptr(int64(38))

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = make(map[string]string)
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = make(map[string]string)

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = make(map[string]string)
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the RenderTypeAssociationsParametersItem model
				renderTypeAssociationsParametersItemModel := new(catalogmanagementv1.RenderTypeAssociationsParametersItem)
				renderTypeAssociationsParametersItemModel.Name = core.StringPtr("testString")
				renderTypeAssociationsParametersItemModel.OptionsRefresh = core.BoolPtr(true)

				// Construct an instance of the RenderTypeAssociations model
				renderTypeAssociationsModel := new(catalogmanagementv1.RenderTypeAssociations)
				renderTypeAssociationsModel.Parameters = []catalogmanagementv1.RenderTypeAssociationsParametersItem{*renderTypeAssociationsParametersItemModel}

				// Construct an instance of the RenderType model
				renderTypeModel := new(catalogmanagementv1.RenderType)
				renderTypeModel.Type = core.StringPtr("testString")
				renderTypeModel.Grouping = core.StringPtr("testString")
				renderTypeModel.OriginalGrouping = core.StringPtr("testString")
				renderTypeModel.GroupingIndex = core.Int64Ptr(int64(38))
				renderTypeModel.ConfigConstraints = map[string]interface{}{"anyKey": "anyValue"}
				renderTypeModel.Associations = renderTypeAssociationsModel

				// Construct an instance of the Configuration model
				configurationModel := new(catalogmanagementv1.Configuration)
				configurationModel.Key = core.StringPtr("testString")
				configurationModel.Type = core.StringPtr("testString")
				configurationModel.DefaultValue = core.StringPtr("testString")
				configurationModel.DisplayName = core.StringPtr("testString")
				configurationModel.ValueConstraint = core.StringPtr("testString")
				configurationModel.Description = core.StringPtr("testString")
				configurationModel.Required = core.BoolPtr(true)
				configurationModel.Options = []interface{}{"testString"}
				configurationModel.Hidden = core.BoolPtr(true)
				configurationModel.CustomConfig = renderTypeModel
				configurationModel.TypeMetadata = core.StringPtr("testString")

				// Construct an instance of the Output model
				outputModel := new(catalogmanagementv1.Output)
				outputModel.Key = core.StringPtr("testString")
				outputModel.Description = core.StringPtr("testString")

				// Construct an instance of the IamResource model
				iamResourceModel := new(catalogmanagementv1.IamResource)
				iamResourceModel.Name = core.StringPtr("testString")
				iamResourceModel.Description = core.StringPtr("testString")
				iamResourceModel.RoleCrns = []string{"testString"}

				// Construct an instance of the IamPermission model
				iamPermissionModel := new(catalogmanagementv1.IamPermission)
				iamPermissionModel.ServiceName = core.StringPtr("testString")
				iamPermissionModel.RoleCrns = []string{"testString"}
				iamPermissionModel.Resources = []catalogmanagementv1.IamResource{*iamResourceModel}

				// Construct an instance of the Validation model
				validationModel := new(catalogmanagementv1.Validation)
				validationModel.Validated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.Requested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.State = core.StringPtr("testString")
				validationModel.LastOperation = core.StringPtr("testString")
				validationModel.Target = make(map[string]interface{})
				validationModel.Message = core.StringPtr("testString")

				// Construct an instance of the Resource model
				resourceModel := new(catalogmanagementv1.Resource)
				resourceModel.Type = core.StringPtr("mem")
				resourceModel.Value = core.StringPtr("testString")

				// Construct an instance of the Script model
				scriptModel := new(catalogmanagementv1.Script)
				scriptModel.Instructions = core.StringPtr("testString")
				scriptModel.InstructionsI18n = make(map[string]string)
				scriptModel.Script = core.StringPtr("testString")
				scriptModel.ScriptPermission = core.StringPtr("testString")
				scriptModel.DeleteScript = core.StringPtr("testString")
				scriptModel.Scope = core.StringPtr("testString")

				// Construct an instance of the VersionEntitlement model
				versionEntitlementModel := new(catalogmanagementv1.VersionEntitlement)
				versionEntitlementModel.ProviderName = core.StringPtr("testString")
				versionEntitlementModel.ProviderID = core.StringPtr("testString")
				versionEntitlementModel.ProductID = core.StringPtr("testString")
				versionEntitlementModel.PartNumbers = []string{"testString"}
				versionEntitlementModel.ImageRepoName = core.StringPtr("testString")

				// Construct an instance of the License model
				licenseModel := new(catalogmanagementv1.License)
				licenseModel.ID = core.StringPtr("testString")
				licenseModel.Name = core.StringPtr("testString")
				licenseModel.Type = core.StringPtr("testString")
				licenseModel.URL = core.StringPtr("testString")
				licenseModel.Description = core.StringPtr("testString")

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")

				// Construct an instance of the DeprecatePending model
				deprecatePendingModel := new(catalogmanagementv1.DeprecatePending)
				deprecatePendingModel.DeprecateDate = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				deprecatePendingModel.DeprecateState = core.StringPtr("testString")
				deprecatePendingModel.Description = core.StringPtr("testString")

				// Construct an instance of the URLProxy model
				urlProxyModel := new(catalogmanagementv1.URLProxy)
				urlProxyModel.URL = core.StringPtr("testString")
				urlProxyModel.Sha = core.StringPtr("testString")

				// Construct an instance of the MediaItem model
				mediaItemModel := new(catalogmanagementv1.MediaItem)
				mediaItemModel.URL = core.StringPtr("testString")
				mediaItemModel.APIURL = core.StringPtr("testString")
				mediaItemModel.URLProxy = urlProxyModel
				mediaItemModel.Caption = core.StringPtr("testString")
				mediaItemModel.CaptionI18n = make(map[string]string)
				mediaItemModel.Type = core.StringPtr("testString")
				mediaItemModel.ThumbnailURL = core.StringPtr("testString")

				// Construct an instance of the ArchitectureDiagram model
				architectureDiagramModel := new(catalogmanagementv1.ArchitectureDiagram)
				architectureDiagramModel.Diagram = mediaItemModel
				architectureDiagramModel.Description = core.StringPtr("testString")
				architectureDiagramModel.DescriptionI18n = make(map[string]string)

				// Construct an instance of the CostComponent model
				costComponentModel := new(catalogmanagementv1.CostComponent)
				costComponentModel.Name = core.StringPtr("testString")
				costComponentModel.Unit = core.StringPtr("testString")
				costComponentModel.HourlyQuantity = core.StringPtr("testString")
				costComponentModel.MonthlyQuantity = core.StringPtr("testString")
				costComponentModel.Price = core.StringPtr("testString")
				costComponentModel.HourlyCost = core.StringPtr("testString")
				costComponentModel.MonthlyCost = core.StringPtr("testString")

				// Construct an instance of the CostResource model
				costResourceModel := new(catalogmanagementv1.CostResource)
				costResourceModel.Name = core.StringPtr("testString")
				costResourceModel.Metadata = make(map[string]interface{})
				costResourceModel.HourlyCost = core.StringPtr("testString")
				costResourceModel.MonthlyCost = core.StringPtr("testString")
				costResourceModel.CostComponents = []catalogmanagementv1.CostComponent{*costComponentModel}

				// Construct an instance of the CostBreakdown model
				costBreakdownModel := new(catalogmanagementv1.CostBreakdown)
				costBreakdownModel.TotalHourlyCost = core.StringPtr("testString")
				costBreakdownModel.TotalMonthlyCOst = core.StringPtr("testString")
				costBreakdownModel.Resources = []catalogmanagementv1.CostResource{*costResourceModel}

				// Construct an instance of the CostSummary model
				costSummaryModel := new(catalogmanagementv1.CostSummary)
				costSummaryModel.TotalDetectedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalSupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUnsupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUsageBasedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalNoPriceResources = core.Int64Ptr(int64(38))
				costSummaryModel.UnsupportedResourceCounts = make(map[string]int64)
				costSummaryModel.NoPriceResourceCounts = make(map[string]int64)

				// Construct an instance of the Project model
				projectModel := new(catalogmanagementv1.Project)
				projectModel.Name = core.StringPtr("testString")
				projectModel.Metadata = make(map[string]interface{})
				projectModel.PastBreakdown = costBreakdownModel
				projectModel.Breakdown = costBreakdownModel
				projectModel.Diff = costBreakdownModel
				projectModel.Summary = costSummaryModel

				// Construct an instance of the CostEstimate model
				costEstimateModel := new(catalogmanagementv1.CostEstimate)
				costEstimateModel.Version = core.StringPtr("testString")
				costEstimateModel.Currency = core.StringPtr("testString")
				costEstimateModel.Projects = []catalogmanagementv1.Project{*projectModel}
				costEstimateModel.Summary = costSummaryModel
				costEstimateModel.TotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.TotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.TimeGenerated = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the Dependency model
				dependencyModel := new(catalogmanagementv1.Dependency)
				dependencyModel.CatalogID = core.StringPtr("testString")
				dependencyModel.ID = core.StringPtr("testString")
				dependencyModel.Name = core.StringPtr("testString")
				dependencyModel.Version = core.StringPtr("testString")
				dependencyModel.Flavors = []string{"testString"}

				// Construct an instance of the SolutionInfo model
				solutionInfoModel := new(catalogmanagementv1.SolutionInfo)
				solutionInfoModel.ArchitectureDiagrams = []catalogmanagementv1.ArchitectureDiagram{*architectureDiagramModel}
				solutionInfoModel.Features = []catalogmanagementv1.Feature{*featureModel}
				solutionInfoModel.CostEstimate = costEstimateModel
				solutionInfoModel.Dependencies = []catalogmanagementv1.Dependency{*dependencyModel}

				// Construct an instance of the Version model
				versionModel := new(catalogmanagementv1.Version)
				versionModel.ID = core.StringPtr("testString")
				versionModel.Rev = core.StringPtr("testString")
				versionModel.CRN = core.StringPtr("testString")
				versionModel.Version = core.StringPtr("testString")
				versionModel.Flavor = flavorModel
				versionModel.Sha = core.StringPtr("testString")
				versionModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.OfferingID = core.StringPtr("testString")
				versionModel.CatalogID = core.StringPtr("testString")
				versionModel.KindID = core.StringPtr("testString")
				versionModel.Tags = []string{"testString"}
				versionModel.RepoURL = core.StringPtr("testString")
				versionModel.SourceURL = core.StringPtr("testString")
				versionModel.TgzURL = core.StringPtr("testString")
				versionModel.Configuration = []catalogmanagementv1.Configuration{*configurationModel}
				versionModel.Outputs = []catalogmanagementv1.Output{*outputModel}
				versionModel.IamPermissions = []catalogmanagementv1.IamPermission{*iamPermissionModel}
				versionModel.Metadata = make(map[string]interface{})
				versionModel.Validation = validationModel
				versionModel.RequiredResources = []catalogmanagementv1.Resource{*resourceModel}
				versionModel.SingleInstance = core.BoolPtr(true)
				versionModel.Install = scriptModel
				versionModel.PreInstall = []catalogmanagementv1.Script{*scriptModel}
				versionModel.Entitlement = versionEntitlementModel
				versionModel.Licenses = []catalogmanagementv1.License{*licenseModel}
				versionModel.ImageManifestURL = core.StringPtr("testString")
				versionModel.Deprecated = core.BoolPtr(true)
				versionModel.PackageVersion = core.StringPtr("testString")
				versionModel.State = stateModel
				versionModel.VersionLocator = core.StringPtr("testString")
				versionModel.LongDescription = core.StringPtr("testString")
				versionModel.LongDescriptionI18n = make(map[string]string)
				versionModel.WhitelistedAccounts = []string{"testString"}
				versionModel.ImagePullKeyName = core.StringPtr("testString")
				versionModel.DeprecatePending = deprecatePendingModel
				versionModel.SolutionInfo = solutionInfoModel
				versionModel.IsConsumable = core.BoolPtr(true)

				// Construct an instance of the Deployment model
				deploymentModel := new(catalogmanagementv1.Deployment)
				deploymentModel.ID = core.StringPtr("testString")
				deploymentModel.Label = core.StringPtr("testString")
				deploymentModel.Name = core.StringPtr("testString")
				deploymentModel.ShortDescription = core.StringPtr("testString")
				deploymentModel.LongDescription = core.StringPtr("testString")
				deploymentModel.Metadata = make(map[string]interface{})
				deploymentModel.Tags = []string{"testString"}
				deploymentModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				deploymentModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the Plan model
				planModel := new(catalogmanagementv1.Plan)
				planModel.ID = core.StringPtr("testString")
				planModel.Label = core.StringPtr("testString")
				planModel.Name = core.StringPtr("testString")
				planModel.ShortDescription = core.StringPtr("testString")
				planModel.LongDescription = core.StringPtr("testString")
				planModel.Metadata = make(map[string]interface{})
				planModel.Tags = []string{"testString"}
				planModel.AdditionalFeatures = []catalogmanagementv1.Feature{*featureModel}
				planModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.Deployments = []catalogmanagementv1.Deployment{*deploymentModel}

				// Construct an instance of the Kind model
				kindModel := new(catalogmanagementv1.Kind)
				kindModel.ID = core.StringPtr("testString")
				kindModel.FormatKind = core.StringPtr("testString")
				kindModel.InstallKind = core.StringPtr("testString")
				kindModel.TargetKind = core.StringPtr("testString")
				kindModel.Metadata = make(map[string]interface{})
				kindModel.Tags = []string{"testString"}
				kindModel.AdditionalFeatures = []catalogmanagementv1.Feature{*featureModel}
				kindModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Versions = []catalogmanagementv1.Version{*versionModel}
				kindModel.Plans = []catalogmanagementv1.Plan{*planModel}

				// Construct an instance of the ProviderInfo model
				providerInfoModel := new(catalogmanagementv1.ProviderInfo)
				providerInfoModel.ID = core.StringPtr("testString")
				providerInfoModel.Name = core.StringPtr("testString")

				// Construct an instance of the RepoInfo model
				repoInfoModel := new(catalogmanagementv1.RepoInfo)
				repoInfoModel.Token = core.StringPtr("testString")
				repoInfoModel.Type = core.StringPtr("testString")

				// Construct an instance of the ImagePullKey model
				imagePullKeyModel := new(catalogmanagementv1.ImagePullKey)
				imagePullKeyModel.Name = core.StringPtr("testString")
				imagePullKeyModel.Value = core.StringPtr("testString")
				imagePullKeyModel.Description = core.StringPtr("testString")

				// Construct an instance of the SupportWaitTime model
				supportWaitTimeModel := new(catalogmanagementv1.SupportWaitTime)
				supportWaitTimeModel.Value = core.Int64Ptr(int64(38))
				supportWaitTimeModel.Type = core.StringPtr("testString")

				// Construct an instance of the SupportTime model
				supportTimeModel := new(catalogmanagementv1.SupportTime)
				supportTimeModel.Day = core.Int64Ptr(int64(38))
				supportTimeModel.StartTime = core.StringPtr("testString")
				supportTimeModel.EndTime = core.StringPtr("testString")

				// Construct an instance of the SupportAvailability model
				supportAvailabilityModel := new(catalogmanagementv1.SupportAvailability)
				supportAvailabilityModel.Times = []catalogmanagementv1.SupportTime{*supportTimeModel}
				supportAvailabilityModel.Timezone = core.StringPtr("testString")
				supportAvailabilityModel.AlwaysAvailable = core.BoolPtr(true)

				// Construct an instance of the SupportDetail model
				supportDetailModel := new(catalogmanagementv1.SupportDetail)
				supportDetailModel.Type = core.StringPtr("testString")
				supportDetailModel.Contact = core.StringPtr("testString")
				supportDetailModel.ResponseWaitTime = supportWaitTimeModel
				supportDetailModel.Availability = supportAvailabilityModel

				// Construct an instance of the SupportEscalation model
				supportEscalationModel := new(catalogmanagementv1.SupportEscalation)
				supportEscalationModel.EscalationWaitTime = supportWaitTimeModel
				supportEscalationModel.ResponseWaitTime = supportWaitTimeModel
				supportEscalationModel.Contact = core.StringPtr("testString")

				// Construct an instance of the Support model
				supportModel := new(catalogmanagementv1.Support)
				supportModel.URL = core.StringPtr("testString")
				supportModel.Process = core.StringPtr("testString")
				supportModel.ProcessI18n = make(map[string]string)
				supportModel.Locations = []string{"testString"}
				supportModel.SupportDetails = []catalogmanagementv1.SupportDetail{*supportDetailModel}
				supportModel.SupportEscalation = supportEscalationModel
				supportModel.SupportType = core.StringPtr("testString")

				// Construct an instance of the LearnMoreLinks model
				learnMoreLinksModel := new(catalogmanagementv1.LearnMoreLinks)
				learnMoreLinksModel.FirstParty = core.StringPtr("testString")
				learnMoreLinksModel.ThirdParty = core.StringPtr("testString")

				// Construct an instance of the Constraint model
				constraintModel := new(catalogmanagementv1.Constraint)
				constraintModel.Type = core.StringPtr("testString")
				constraintModel.Rule = core.StringPtr("testString")

				// Construct an instance of the Badge model
				badgeModel := new(catalogmanagementv1.Badge)
				badgeModel.ID = core.StringPtr("testString")
				badgeModel.Label = core.StringPtr("testString")
				badgeModel.LabelI18n = make(map[string]string)
				badgeModel.Description = core.StringPtr("testString")
				badgeModel.DescriptionI18n = make(map[string]string)
				badgeModel.Icon = core.StringPtr("testString")
				badgeModel.Authority = core.StringPtr("testString")
				badgeModel.Tag = core.StringPtr("testString")
				badgeModel.LearnMoreLinks = learnMoreLinksModel
				badgeModel.Constraints = []catalogmanagementv1.Constraint{*constraintModel}

				// Construct an instance of the CreateOfferingOptions model
				createOfferingOptionsModel := new(catalogmanagementv1.CreateOfferingOptions)
				createOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				createOfferingOptionsModel.ID = core.StringPtr("testString")
				createOfferingOptionsModel.Rev = core.StringPtr("testString")
				createOfferingOptionsModel.URL = core.StringPtr("testString")
				createOfferingOptionsModel.CRN = core.StringPtr("testString")
				createOfferingOptionsModel.Label = core.StringPtr("testString")
				createOfferingOptionsModel.LabelI18n = make(map[string]string)
				createOfferingOptionsModel.Name = core.StringPtr("testString")
				createOfferingOptionsModel.OfferingIconURL = core.StringPtr("testString")
				createOfferingOptionsModel.OfferingDocsURL = core.StringPtr("testString")
				createOfferingOptionsModel.OfferingSupportURL = core.StringPtr("testString")
				createOfferingOptionsModel.Tags = []string{"testString"}
				createOfferingOptionsModel.Keywords = []string{"testString"}
				createOfferingOptionsModel.Rating = ratingModel
				createOfferingOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createOfferingOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createOfferingOptionsModel.ShortDescription = core.StringPtr("testString")
				createOfferingOptionsModel.ShortDescriptionI18n = make(map[string]string)
				createOfferingOptionsModel.LongDescription = core.StringPtr("testString")
				createOfferingOptionsModel.LongDescriptionI18n = make(map[string]string)
				createOfferingOptionsModel.Features = []catalogmanagementv1.Feature{*featureModel}
				createOfferingOptionsModel.Kinds = []catalogmanagementv1.Kind{*kindModel}
				createOfferingOptionsModel.PcManaged = core.BoolPtr(true)
				createOfferingOptionsModel.PublishApproved = core.BoolPtr(true)
				createOfferingOptionsModel.ShareWithAll = core.BoolPtr(true)
				createOfferingOptionsModel.ShareWithIBM = core.BoolPtr(true)
				createOfferingOptionsModel.ShareEnabled = core.BoolPtr(true)
				createOfferingOptionsModel.PermitRequestIBMPublicPublish = core.BoolPtr(true)
				createOfferingOptionsModel.IBMPublishApproved = core.BoolPtr(true)
				createOfferingOptionsModel.PublicPublishApproved = core.BoolPtr(true)
				createOfferingOptionsModel.PublicOriginalCRN = core.StringPtr("testString")
				createOfferingOptionsModel.PublishPublicCRN = core.StringPtr("testString")
				createOfferingOptionsModel.PortalApprovalRecord = core.StringPtr("testString")
				createOfferingOptionsModel.PortalUIURL = core.StringPtr("testString")
				createOfferingOptionsModel.CatalogID = core.StringPtr("testString")
				createOfferingOptionsModel.CatalogName = core.StringPtr("testString")
				createOfferingOptionsModel.Metadata = make(map[string]interface{})
				createOfferingOptionsModel.Disclaimer = core.StringPtr("testString")
				createOfferingOptionsModel.Hidden = core.BoolPtr(true)
				createOfferingOptionsModel.Provider = core.StringPtr("testString")
				createOfferingOptionsModel.ProviderInfo = providerInfoModel
				createOfferingOptionsModel.RepoInfo = repoInfoModel
				createOfferingOptionsModel.ImagePullKeys = []catalogmanagementv1.ImagePullKey{*imagePullKeyModel}
				createOfferingOptionsModel.Support = supportModel
				createOfferingOptionsModel.Media = []catalogmanagementv1.MediaItem{*mediaItemModel}
				createOfferingOptionsModel.DeprecatePending = deprecatePendingModel
				createOfferingOptionsModel.ProductKind = core.StringPtr("testString")
				createOfferingOptionsModel.Badges = []catalogmanagementv1.Badge{*badgeModel}
				createOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.CreateOffering(createOfferingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateOffering with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Rating model
				ratingModel := new(catalogmanagementv1.Rating)
				ratingModel.OneStarCount = core.Int64Ptr(int64(38))
				ratingModel.TwoStarCount = core.Int64Ptr(int64(38))
				ratingModel.ThreeStarCount = core.Int64Ptr(int64(38))
				ratingModel.FourStarCount = core.Int64Ptr(int64(38))

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = make(map[string]string)
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = make(map[string]string)

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = make(map[string]string)
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the RenderTypeAssociationsParametersItem model
				renderTypeAssociationsParametersItemModel := new(catalogmanagementv1.RenderTypeAssociationsParametersItem)
				renderTypeAssociationsParametersItemModel.Name = core.StringPtr("testString")
				renderTypeAssociationsParametersItemModel.OptionsRefresh = core.BoolPtr(true)

				// Construct an instance of the RenderTypeAssociations model
				renderTypeAssociationsModel := new(catalogmanagementv1.RenderTypeAssociations)
				renderTypeAssociationsModel.Parameters = []catalogmanagementv1.RenderTypeAssociationsParametersItem{*renderTypeAssociationsParametersItemModel}

				// Construct an instance of the RenderType model
				renderTypeModel := new(catalogmanagementv1.RenderType)
				renderTypeModel.Type = core.StringPtr("testString")
				renderTypeModel.Grouping = core.StringPtr("testString")
				renderTypeModel.OriginalGrouping = core.StringPtr("testString")
				renderTypeModel.GroupingIndex = core.Int64Ptr(int64(38))
				renderTypeModel.ConfigConstraints = map[string]interface{}{"anyKey": "anyValue"}
				renderTypeModel.Associations = renderTypeAssociationsModel

				// Construct an instance of the Configuration model
				configurationModel := new(catalogmanagementv1.Configuration)
				configurationModel.Key = core.StringPtr("testString")
				configurationModel.Type = core.StringPtr("testString")
				configurationModel.DefaultValue = core.StringPtr("testString")
				configurationModel.DisplayName = core.StringPtr("testString")
				configurationModel.ValueConstraint = core.StringPtr("testString")
				configurationModel.Description = core.StringPtr("testString")
				configurationModel.Required = core.BoolPtr(true)
				configurationModel.Options = []interface{}{"testString"}
				configurationModel.Hidden = core.BoolPtr(true)
				configurationModel.CustomConfig = renderTypeModel
				configurationModel.TypeMetadata = core.StringPtr("testString")

				// Construct an instance of the Output model
				outputModel := new(catalogmanagementv1.Output)
				outputModel.Key = core.StringPtr("testString")
				outputModel.Description = core.StringPtr("testString")

				// Construct an instance of the IamResource model
				iamResourceModel := new(catalogmanagementv1.IamResource)
				iamResourceModel.Name = core.StringPtr("testString")
				iamResourceModel.Description = core.StringPtr("testString")
				iamResourceModel.RoleCrns = []string{"testString"}

				// Construct an instance of the IamPermission model
				iamPermissionModel := new(catalogmanagementv1.IamPermission)
				iamPermissionModel.ServiceName = core.StringPtr("testString")
				iamPermissionModel.RoleCrns = []string{"testString"}
				iamPermissionModel.Resources = []catalogmanagementv1.IamResource{*iamResourceModel}

				// Construct an instance of the Validation model
				validationModel := new(catalogmanagementv1.Validation)
				validationModel.Validated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.Requested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.State = core.StringPtr("testString")
				validationModel.LastOperation = core.StringPtr("testString")
				validationModel.Target = make(map[string]interface{})
				validationModel.Message = core.StringPtr("testString")

				// Construct an instance of the Resource model
				resourceModel := new(catalogmanagementv1.Resource)
				resourceModel.Type = core.StringPtr("mem")
				resourceModel.Value = core.StringPtr("testString")

				// Construct an instance of the Script model
				scriptModel := new(catalogmanagementv1.Script)
				scriptModel.Instructions = core.StringPtr("testString")
				scriptModel.InstructionsI18n = make(map[string]string)
				scriptModel.Script = core.StringPtr("testString")
				scriptModel.ScriptPermission = core.StringPtr("testString")
				scriptModel.DeleteScript = core.StringPtr("testString")
				scriptModel.Scope = core.StringPtr("testString")

				// Construct an instance of the VersionEntitlement model
				versionEntitlementModel := new(catalogmanagementv1.VersionEntitlement)
				versionEntitlementModel.ProviderName = core.StringPtr("testString")
				versionEntitlementModel.ProviderID = core.StringPtr("testString")
				versionEntitlementModel.ProductID = core.StringPtr("testString")
				versionEntitlementModel.PartNumbers = []string{"testString"}
				versionEntitlementModel.ImageRepoName = core.StringPtr("testString")

				// Construct an instance of the License model
				licenseModel := new(catalogmanagementv1.License)
				licenseModel.ID = core.StringPtr("testString")
				licenseModel.Name = core.StringPtr("testString")
				licenseModel.Type = core.StringPtr("testString")
				licenseModel.URL = core.StringPtr("testString")
				licenseModel.Description = core.StringPtr("testString")

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")

				// Construct an instance of the DeprecatePending model
				deprecatePendingModel := new(catalogmanagementv1.DeprecatePending)
				deprecatePendingModel.DeprecateDate = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				deprecatePendingModel.DeprecateState = core.StringPtr("testString")
				deprecatePendingModel.Description = core.StringPtr("testString")

				// Construct an instance of the URLProxy model
				urlProxyModel := new(catalogmanagementv1.URLProxy)
				urlProxyModel.URL = core.StringPtr("testString")
				urlProxyModel.Sha = core.StringPtr("testString")

				// Construct an instance of the MediaItem model
				mediaItemModel := new(catalogmanagementv1.MediaItem)
				mediaItemModel.URL = core.StringPtr("testString")
				mediaItemModel.APIURL = core.StringPtr("testString")
				mediaItemModel.URLProxy = urlProxyModel
				mediaItemModel.Caption = core.StringPtr("testString")
				mediaItemModel.CaptionI18n = make(map[string]string)
				mediaItemModel.Type = core.StringPtr("testString")
				mediaItemModel.ThumbnailURL = core.StringPtr("testString")

				// Construct an instance of the ArchitectureDiagram model
				architectureDiagramModel := new(catalogmanagementv1.ArchitectureDiagram)
				architectureDiagramModel.Diagram = mediaItemModel
				architectureDiagramModel.Description = core.StringPtr("testString")
				architectureDiagramModel.DescriptionI18n = make(map[string]string)

				// Construct an instance of the CostComponent model
				costComponentModel := new(catalogmanagementv1.CostComponent)
				costComponentModel.Name = core.StringPtr("testString")
				costComponentModel.Unit = core.StringPtr("testString")
				costComponentModel.HourlyQuantity = core.StringPtr("testString")
				costComponentModel.MonthlyQuantity = core.StringPtr("testString")
				costComponentModel.Price = core.StringPtr("testString")
				costComponentModel.HourlyCost = core.StringPtr("testString")
				costComponentModel.MonthlyCost = core.StringPtr("testString")

				// Construct an instance of the CostResource model
				costResourceModel := new(catalogmanagementv1.CostResource)
				costResourceModel.Name = core.StringPtr("testString")
				costResourceModel.Metadata = make(map[string]interface{})
				costResourceModel.HourlyCost = core.StringPtr("testString")
				costResourceModel.MonthlyCost = core.StringPtr("testString")
				costResourceModel.CostComponents = []catalogmanagementv1.CostComponent{*costComponentModel}

				// Construct an instance of the CostBreakdown model
				costBreakdownModel := new(catalogmanagementv1.CostBreakdown)
				costBreakdownModel.TotalHourlyCost = core.StringPtr("testString")
				costBreakdownModel.TotalMonthlyCOst = core.StringPtr("testString")
				costBreakdownModel.Resources = []catalogmanagementv1.CostResource{*costResourceModel}

				// Construct an instance of the CostSummary model
				costSummaryModel := new(catalogmanagementv1.CostSummary)
				costSummaryModel.TotalDetectedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalSupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUnsupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUsageBasedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalNoPriceResources = core.Int64Ptr(int64(38))
				costSummaryModel.UnsupportedResourceCounts = make(map[string]int64)
				costSummaryModel.NoPriceResourceCounts = make(map[string]int64)

				// Construct an instance of the Project model
				projectModel := new(catalogmanagementv1.Project)
				projectModel.Name = core.StringPtr("testString")
				projectModel.Metadata = make(map[string]interface{})
				projectModel.PastBreakdown = costBreakdownModel
				projectModel.Breakdown = costBreakdownModel
				projectModel.Diff = costBreakdownModel
				projectModel.Summary = costSummaryModel

				// Construct an instance of the CostEstimate model
				costEstimateModel := new(catalogmanagementv1.CostEstimate)
				costEstimateModel.Version = core.StringPtr("testString")
				costEstimateModel.Currency = core.StringPtr("testString")
				costEstimateModel.Projects = []catalogmanagementv1.Project{*projectModel}
				costEstimateModel.Summary = costSummaryModel
				costEstimateModel.TotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.TotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.TimeGenerated = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the Dependency model
				dependencyModel := new(catalogmanagementv1.Dependency)
				dependencyModel.CatalogID = core.StringPtr("testString")
				dependencyModel.ID = core.StringPtr("testString")
				dependencyModel.Name = core.StringPtr("testString")
				dependencyModel.Version = core.StringPtr("testString")
				dependencyModel.Flavors = []string{"testString"}

				// Construct an instance of the SolutionInfo model
				solutionInfoModel := new(catalogmanagementv1.SolutionInfo)
				solutionInfoModel.ArchitectureDiagrams = []catalogmanagementv1.ArchitectureDiagram{*architectureDiagramModel}
				solutionInfoModel.Features = []catalogmanagementv1.Feature{*featureModel}
				solutionInfoModel.CostEstimate = costEstimateModel
				solutionInfoModel.Dependencies = []catalogmanagementv1.Dependency{*dependencyModel}

				// Construct an instance of the Version model
				versionModel := new(catalogmanagementv1.Version)
				versionModel.ID = core.StringPtr("testString")
				versionModel.Rev = core.StringPtr("testString")
				versionModel.CRN = core.StringPtr("testString")
				versionModel.Version = core.StringPtr("testString")
				versionModel.Flavor = flavorModel
				versionModel.Sha = core.StringPtr("testString")
				versionModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.OfferingID = core.StringPtr("testString")
				versionModel.CatalogID = core.StringPtr("testString")
				versionModel.KindID = core.StringPtr("testString")
				versionModel.Tags = []string{"testString"}
				versionModel.RepoURL = core.StringPtr("testString")
				versionModel.SourceURL = core.StringPtr("testString")
				versionModel.TgzURL = core.StringPtr("testString")
				versionModel.Configuration = []catalogmanagementv1.Configuration{*configurationModel}
				versionModel.Outputs = []catalogmanagementv1.Output{*outputModel}
				versionModel.IamPermissions = []catalogmanagementv1.IamPermission{*iamPermissionModel}
				versionModel.Metadata = make(map[string]interface{})
				versionModel.Validation = validationModel
				versionModel.RequiredResources = []catalogmanagementv1.Resource{*resourceModel}
				versionModel.SingleInstance = core.BoolPtr(true)
				versionModel.Install = scriptModel
				versionModel.PreInstall = []catalogmanagementv1.Script{*scriptModel}
				versionModel.Entitlement = versionEntitlementModel
				versionModel.Licenses = []catalogmanagementv1.License{*licenseModel}
				versionModel.ImageManifestURL = core.StringPtr("testString")
				versionModel.Deprecated = core.BoolPtr(true)
				versionModel.PackageVersion = core.StringPtr("testString")
				versionModel.State = stateModel
				versionModel.VersionLocator = core.StringPtr("testString")
				versionModel.LongDescription = core.StringPtr("testString")
				versionModel.LongDescriptionI18n = make(map[string]string)
				versionModel.WhitelistedAccounts = []string{"testString"}
				versionModel.ImagePullKeyName = core.StringPtr("testString")
				versionModel.DeprecatePending = deprecatePendingModel
				versionModel.SolutionInfo = solutionInfoModel
				versionModel.IsConsumable = core.BoolPtr(true)

				// Construct an instance of the Deployment model
				deploymentModel := new(catalogmanagementv1.Deployment)
				deploymentModel.ID = core.StringPtr("testString")
				deploymentModel.Label = core.StringPtr("testString")
				deploymentModel.Name = core.StringPtr("testString")
				deploymentModel.ShortDescription = core.StringPtr("testString")
				deploymentModel.LongDescription = core.StringPtr("testString")
				deploymentModel.Metadata = make(map[string]interface{})
				deploymentModel.Tags = []string{"testString"}
				deploymentModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				deploymentModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the Plan model
				planModel := new(catalogmanagementv1.Plan)
				planModel.ID = core.StringPtr("testString")
				planModel.Label = core.StringPtr("testString")
				planModel.Name = core.StringPtr("testString")
				planModel.ShortDescription = core.StringPtr("testString")
				planModel.LongDescription = core.StringPtr("testString")
				planModel.Metadata = make(map[string]interface{})
				planModel.Tags = []string{"testString"}
				planModel.AdditionalFeatures = []catalogmanagementv1.Feature{*featureModel}
				planModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.Deployments = []catalogmanagementv1.Deployment{*deploymentModel}

				// Construct an instance of the Kind model
				kindModel := new(catalogmanagementv1.Kind)
				kindModel.ID = core.StringPtr("testString")
				kindModel.FormatKind = core.StringPtr("testString")
				kindModel.InstallKind = core.StringPtr("testString")
				kindModel.TargetKind = core.StringPtr("testString")
				kindModel.Metadata = make(map[string]interface{})
				kindModel.Tags = []string{"testString"}
				kindModel.AdditionalFeatures = []catalogmanagementv1.Feature{*featureModel}
				kindModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Versions = []catalogmanagementv1.Version{*versionModel}
				kindModel.Plans = []catalogmanagementv1.Plan{*planModel}

				// Construct an instance of the ProviderInfo model
				providerInfoModel := new(catalogmanagementv1.ProviderInfo)
				providerInfoModel.ID = core.StringPtr("testString")
				providerInfoModel.Name = core.StringPtr("testString")

				// Construct an instance of the RepoInfo model
				repoInfoModel := new(catalogmanagementv1.RepoInfo)
				repoInfoModel.Token = core.StringPtr("testString")
				repoInfoModel.Type = core.StringPtr("testString")

				// Construct an instance of the ImagePullKey model
				imagePullKeyModel := new(catalogmanagementv1.ImagePullKey)
				imagePullKeyModel.Name = core.StringPtr("testString")
				imagePullKeyModel.Value = core.StringPtr("testString")
				imagePullKeyModel.Description = core.StringPtr("testString")

				// Construct an instance of the SupportWaitTime model
				supportWaitTimeModel := new(catalogmanagementv1.SupportWaitTime)
				supportWaitTimeModel.Value = core.Int64Ptr(int64(38))
				supportWaitTimeModel.Type = core.StringPtr("testString")

				// Construct an instance of the SupportTime model
				supportTimeModel := new(catalogmanagementv1.SupportTime)
				supportTimeModel.Day = core.Int64Ptr(int64(38))
				supportTimeModel.StartTime = core.StringPtr("testString")
				supportTimeModel.EndTime = core.StringPtr("testString")

				// Construct an instance of the SupportAvailability model
				supportAvailabilityModel := new(catalogmanagementv1.SupportAvailability)
				supportAvailabilityModel.Times = []catalogmanagementv1.SupportTime{*supportTimeModel}
				supportAvailabilityModel.Timezone = core.StringPtr("testString")
				supportAvailabilityModel.AlwaysAvailable = core.BoolPtr(true)

				// Construct an instance of the SupportDetail model
				supportDetailModel := new(catalogmanagementv1.SupportDetail)
				supportDetailModel.Type = core.StringPtr("testString")
				supportDetailModel.Contact = core.StringPtr("testString")
				supportDetailModel.ResponseWaitTime = supportWaitTimeModel
				supportDetailModel.Availability = supportAvailabilityModel

				// Construct an instance of the SupportEscalation model
				supportEscalationModel := new(catalogmanagementv1.SupportEscalation)
				supportEscalationModel.EscalationWaitTime = supportWaitTimeModel
				supportEscalationModel.ResponseWaitTime = supportWaitTimeModel
				supportEscalationModel.Contact = core.StringPtr("testString")

				// Construct an instance of the Support model
				supportModel := new(catalogmanagementv1.Support)
				supportModel.URL = core.StringPtr("testString")
				supportModel.Process = core.StringPtr("testString")
				supportModel.ProcessI18n = make(map[string]string)
				supportModel.Locations = []string{"testString"}
				supportModel.SupportDetails = []catalogmanagementv1.SupportDetail{*supportDetailModel}
				supportModel.SupportEscalation = supportEscalationModel
				supportModel.SupportType = core.StringPtr("testString")

				// Construct an instance of the LearnMoreLinks model
				learnMoreLinksModel := new(catalogmanagementv1.LearnMoreLinks)
				learnMoreLinksModel.FirstParty = core.StringPtr("testString")
				learnMoreLinksModel.ThirdParty = core.StringPtr("testString")

				// Construct an instance of the Constraint model
				constraintModel := new(catalogmanagementv1.Constraint)
				constraintModel.Type = core.StringPtr("testString")
				constraintModel.Rule = core.StringPtr("testString")

				// Construct an instance of the Badge model
				badgeModel := new(catalogmanagementv1.Badge)
				badgeModel.ID = core.StringPtr("testString")
				badgeModel.Label = core.StringPtr("testString")
				badgeModel.LabelI18n = make(map[string]string)
				badgeModel.Description = core.StringPtr("testString")
				badgeModel.DescriptionI18n = make(map[string]string)
				badgeModel.Icon = core.StringPtr("testString")
				badgeModel.Authority = core.StringPtr("testString")
				badgeModel.Tag = core.StringPtr("testString")
				badgeModel.LearnMoreLinks = learnMoreLinksModel
				badgeModel.Constraints = []catalogmanagementv1.Constraint{*constraintModel}

				// Construct an instance of the CreateOfferingOptions model
				createOfferingOptionsModel := new(catalogmanagementv1.CreateOfferingOptions)
				createOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				createOfferingOptionsModel.ID = core.StringPtr("testString")
				createOfferingOptionsModel.Rev = core.StringPtr("testString")
				createOfferingOptionsModel.URL = core.StringPtr("testString")
				createOfferingOptionsModel.CRN = core.StringPtr("testString")
				createOfferingOptionsModel.Label = core.StringPtr("testString")
				createOfferingOptionsModel.LabelI18n = make(map[string]string)
				createOfferingOptionsModel.Name = core.StringPtr("testString")
				createOfferingOptionsModel.OfferingIconURL = core.StringPtr("testString")
				createOfferingOptionsModel.OfferingDocsURL = core.StringPtr("testString")
				createOfferingOptionsModel.OfferingSupportURL = core.StringPtr("testString")
				createOfferingOptionsModel.Tags = []string{"testString"}
				createOfferingOptionsModel.Keywords = []string{"testString"}
				createOfferingOptionsModel.Rating = ratingModel
				createOfferingOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createOfferingOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createOfferingOptionsModel.ShortDescription = core.StringPtr("testString")
				createOfferingOptionsModel.ShortDescriptionI18n = make(map[string]string)
				createOfferingOptionsModel.LongDescription = core.StringPtr("testString")
				createOfferingOptionsModel.LongDescriptionI18n = make(map[string]string)
				createOfferingOptionsModel.Features = []catalogmanagementv1.Feature{*featureModel}
				createOfferingOptionsModel.Kinds = []catalogmanagementv1.Kind{*kindModel}
				createOfferingOptionsModel.PcManaged = core.BoolPtr(true)
				createOfferingOptionsModel.PublishApproved = core.BoolPtr(true)
				createOfferingOptionsModel.ShareWithAll = core.BoolPtr(true)
				createOfferingOptionsModel.ShareWithIBM = core.BoolPtr(true)
				createOfferingOptionsModel.ShareEnabled = core.BoolPtr(true)
				createOfferingOptionsModel.PermitRequestIBMPublicPublish = core.BoolPtr(true)
				createOfferingOptionsModel.IBMPublishApproved = core.BoolPtr(true)
				createOfferingOptionsModel.PublicPublishApproved = core.BoolPtr(true)
				createOfferingOptionsModel.PublicOriginalCRN = core.StringPtr("testString")
				createOfferingOptionsModel.PublishPublicCRN = core.StringPtr("testString")
				createOfferingOptionsModel.PortalApprovalRecord = core.StringPtr("testString")
				createOfferingOptionsModel.PortalUIURL = core.StringPtr("testString")
				createOfferingOptionsModel.CatalogID = core.StringPtr("testString")
				createOfferingOptionsModel.CatalogName = core.StringPtr("testString")
				createOfferingOptionsModel.Metadata = make(map[string]interface{})
				createOfferingOptionsModel.Disclaimer = core.StringPtr("testString")
				createOfferingOptionsModel.Hidden = core.BoolPtr(true)
				createOfferingOptionsModel.Provider = core.StringPtr("testString")
				createOfferingOptionsModel.ProviderInfo = providerInfoModel
				createOfferingOptionsModel.RepoInfo = repoInfoModel
				createOfferingOptionsModel.ImagePullKeys = []catalogmanagementv1.ImagePullKey{*imagePullKeyModel}
				createOfferingOptionsModel.Support = supportModel
				createOfferingOptionsModel.Media = []catalogmanagementv1.MediaItem{*mediaItemModel}
				createOfferingOptionsModel.DeprecatePending = deprecatePendingModel
				createOfferingOptionsModel.ProductKind = core.StringPtr("testString")
				createOfferingOptionsModel.Badges = []catalogmanagementv1.Badge{*badgeModel}
				createOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.CreateOffering(createOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreateOfferingOptions model with no property values
				createOfferingOptionsModelNew := new(catalogmanagementv1.CreateOfferingOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.CreateOffering(createOfferingOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreateOffering successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Rating model
				ratingModel := new(catalogmanagementv1.Rating)
				ratingModel.OneStarCount = core.Int64Ptr(int64(38))
				ratingModel.TwoStarCount = core.Int64Ptr(int64(38))
				ratingModel.ThreeStarCount = core.Int64Ptr(int64(38))
				ratingModel.FourStarCount = core.Int64Ptr(int64(38))

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = make(map[string]string)
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = make(map[string]string)

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = make(map[string]string)
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the RenderTypeAssociationsParametersItem model
				renderTypeAssociationsParametersItemModel := new(catalogmanagementv1.RenderTypeAssociationsParametersItem)
				renderTypeAssociationsParametersItemModel.Name = core.StringPtr("testString")
				renderTypeAssociationsParametersItemModel.OptionsRefresh = core.BoolPtr(true)

				// Construct an instance of the RenderTypeAssociations model
				renderTypeAssociationsModel := new(catalogmanagementv1.RenderTypeAssociations)
				renderTypeAssociationsModel.Parameters = []catalogmanagementv1.RenderTypeAssociationsParametersItem{*renderTypeAssociationsParametersItemModel}

				// Construct an instance of the RenderType model
				renderTypeModel := new(catalogmanagementv1.RenderType)
				renderTypeModel.Type = core.StringPtr("testString")
				renderTypeModel.Grouping = core.StringPtr("testString")
				renderTypeModel.OriginalGrouping = core.StringPtr("testString")
				renderTypeModel.GroupingIndex = core.Int64Ptr(int64(38))
				renderTypeModel.ConfigConstraints = map[string]interface{}{"anyKey": "anyValue"}
				renderTypeModel.Associations = renderTypeAssociationsModel

				// Construct an instance of the Configuration model
				configurationModel := new(catalogmanagementv1.Configuration)
				configurationModel.Key = core.StringPtr("testString")
				configurationModel.Type = core.StringPtr("testString")
				configurationModel.DefaultValue = core.StringPtr("testString")
				configurationModel.DisplayName = core.StringPtr("testString")
				configurationModel.ValueConstraint = core.StringPtr("testString")
				configurationModel.Description = core.StringPtr("testString")
				configurationModel.Required = core.BoolPtr(true)
				configurationModel.Options = []interface{}{"testString"}
				configurationModel.Hidden = core.BoolPtr(true)
				configurationModel.CustomConfig = renderTypeModel
				configurationModel.TypeMetadata = core.StringPtr("testString")

				// Construct an instance of the Output model
				outputModel := new(catalogmanagementv1.Output)
				outputModel.Key = core.StringPtr("testString")
				outputModel.Description = core.StringPtr("testString")

				// Construct an instance of the IamResource model
				iamResourceModel := new(catalogmanagementv1.IamResource)
				iamResourceModel.Name = core.StringPtr("testString")
				iamResourceModel.Description = core.StringPtr("testString")
				iamResourceModel.RoleCrns = []string{"testString"}

				// Construct an instance of the IamPermission model
				iamPermissionModel := new(catalogmanagementv1.IamPermission)
				iamPermissionModel.ServiceName = core.StringPtr("testString")
				iamPermissionModel.RoleCrns = []string{"testString"}
				iamPermissionModel.Resources = []catalogmanagementv1.IamResource{*iamResourceModel}

				// Construct an instance of the Validation model
				validationModel := new(catalogmanagementv1.Validation)
				validationModel.Validated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.Requested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.State = core.StringPtr("testString")
				validationModel.LastOperation = core.StringPtr("testString")
				validationModel.Target = make(map[string]interface{})
				validationModel.Message = core.StringPtr("testString")

				// Construct an instance of the Resource model
				resourceModel := new(catalogmanagementv1.Resource)
				resourceModel.Type = core.StringPtr("mem")
				resourceModel.Value = core.StringPtr("testString")

				// Construct an instance of the Script model
				scriptModel := new(catalogmanagementv1.Script)
				scriptModel.Instructions = core.StringPtr("testString")
				scriptModel.InstructionsI18n = make(map[string]string)
				scriptModel.Script = core.StringPtr("testString")
				scriptModel.ScriptPermission = core.StringPtr("testString")
				scriptModel.DeleteScript = core.StringPtr("testString")
				scriptModel.Scope = core.StringPtr("testString")

				// Construct an instance of the VersionEntitlement model
				versionEntitlementModel := new(catalogmanagementv1.VersionEntitlement)
				versionEntitlementModel.ProviderName = core.StringPtr("testString")
				versionEntitlementModel.ProviderID = core.StringPtr("testString")
				versionEntitlementModel.ProductID = core.StringPtr("testString")
				versionEntitlementModel.PartNumbers = []string{"testString"}
				versionEntitlementModel.ImageRepoName = core.StringPtr("testString")

				// Construct an instance of the License model
				licenseModel := new(catalogmanagementv1.License)
				licenseModel.ID = core.StringPtr("testString")
				licenseModel.Name = core.StringPtr("testString")
				licenseModel.Type = core.StringPtr("testString")
				licenseModel.URL = core.StringPtr("testString")
				licenseModel.Description = core.StringPtr("testString")

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")

				// Construct an instance of the DeprecatePending model
				deprecatePendingModel := new(catalogmanagementv1.DeprecatePending)
				deprecatePendingModel.DeprecateDate = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				deprecatePendingModel.DeprecateState = core.StringPtr("testString")
				deprecatePendingModel.Description = core.StringPtr("testString")

				// Construct an instance of the URLProxy model
				urlProxyModel := new(catalogmanagementv1.URLProxy)
				urlProxyModel.URL = core.StringPtr("testString")
				urlProxyModel.Sha = core.StringPtr("testString")

				// Construct an instance of the MediaItem model
				mediaItemModel := new(catalogmanagementv1.MediaItem)
				mediaItemModel.URL = core.StringPtr("testString")
				mediaItemModel.APIURL = core.StringPtr("testString")
				mediaItemModel.URLProxy = urlProxyModel
				mediaItemModel.Caption = core.StringPtr("testString")
				mediaItemModel.CaptionI18n = make(map[string]string)
				mediaItemModel.Type = core.StringPtr("testString")
				mediaItemModel.ThumbnailURL = core.StringPtr("testString")

				// Construct an instance of the ArchitectureDiagram model
				architectureDiagramModel := new(catalogmanagementv1.ArchitectureDiagram)
				architectureDiagramModel.Diagram = mediaItemModel
				architectureDiagramModel.Description = core.StringPtr("testString")
				architectureDiagramModel.DescriptionI18n = make(map[string]string)

				// Construct an instance of the CostComponent model
				costComponentModel := new(catalogmanagementv1.CostComponent)
				costComponentModel.Name = core.StringPtr("testString")
				costComponentModel.Unit = core.StringPtr("testString")
				costComponentModel.HourlyQuantity = core.StringPtr("testString")
				costComponentModel.MonthlyQuantity = core.StringPtr("testString")
				costComponentModel.Price = core.StringPtr("testString")
				costComponentModel.HourlyCost = core.StringPtr("testString")
				costComponentModel.MonthlyCost = core.StringPtr("testString")

				// Construct an instance of the CostResource model
				costResourceModel := new(catalogmanagementv1.CostResource)
				costResourceModel.Name = core.StringPtr("testString")
				costResourceModel.Metadata = make(map[string]interface{})
				costResourceModel.HourlyCost = core.StringPtr("testString")
				costResourceModel.MonthlyCost = core.StringPtr("testString")
				costResourceModel.CostComponents = []catalogmanagementv1.CostComponent{*costComponentModel}

				// Construct an instance of the CostBreakdown model
				costBreakdownModel := new(catalogmanagementv1.CostBreakdown)
				costBreakdownModel.TotalHourlyCost = core.StringPtr("testString")
				costBreakdownModel.TotalMonthlyCOst = core.StringPtr("testString")
				costBreakdownModel.Resources = []catalogmanagementv1.CostResource{*costResourceModel}

				// Construct an instance of the CostSummary model
				costSummaryModel := new(catalogmanagementv1.CostSummary)
				costSummaryModel.TotalDetectedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalSupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUnsupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUsageBasedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalNoPriceResources = core.Int64Ptr(int64(38))
				costSummaryModel.UnsupportedResourceCounts = make(map[string]int64)
				costSummaryModel.NoPriceResourceCounts = make(map[string]int64)

				// Construct an instance of the Project model
				projectModel := new(catalogmanagementv1.Project)
				projectModel.Name = core.StringPtr("testString")
				projectModel.Metadata = make(map[string]interface{})
				projectModel.PastBreakdown = costBreakdownModel
				projectModel.Breakdown = costBreakdownModel
				projectModel.Diff = costBreakdownModel
				projectModel.Summary = costSummaryModel

				// Construct an instance of the CostEstimate model
				costEstimateModel := new(catalogmanagementv1.CostEstimate)
				costEstimateModel.Version = core.StringPtr("testString")
				costEstimateModel.Currency = core.StringPtr("testString")
				costEstimateModel.Projects = []catalogmanagementv1.Project{*projectModel}
				costEstimateModel.Summary = costSummaryModel
				costEstimateModel.TotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.TotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.TimeGenerated = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the Dependency model
				dependencyModel := new(catalogmanagementv1.Dependency)
				dependencyModel.CatalogID = core.StringPtr("testString")
				dependencyModel.ID = core.StringPtr("testString")
				dependencyModel.Name = core.StringPtr("testString")
				dependencyModel.Version = core.StringPtr("testString")
				dependencyModel.Flavors = []string{"testString"}

				// Construct an instance of the SolutionInfo model
				solutionInfoModel := new(catalogmanagementv1.SolutionInfo)
				solutionInfoModel.ArchitectureDiagrams = []catalogmanagementv1.ArchitectureDiagram{*architectureDiagramModel}
				solutionInfoModel.Features = []catalogmanagementv1.Feature{*featureModel}
				solutionInfoModel.CostEstimate = costEstimateModel
				solutionInfoModel.Dependencies = []catalogmanagementv1.Dependency{*dependencyModel}

				// Construct an instance of the Version model
				versionModel := new(catalogmanagementv1.Version)
				versionModel.ID = core.StringPtr("testString")
				versionModel.Rev = core.StringPtr("testString")
				versionModel.CRN = core.StringPtr("testString")
				versionModel.Version = core.StringPtr("testString")
				versionModel.Flavor = flavorModel
				versionModel.Sha = core.StringPtr("testString")
				versionModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.OfferingID = core.StringPtr("testString")
				versionModel.CatalogID = core.StringPtr("testString")
				versionModel.KindID = core.StringPtr("testString")
				versionModel.Tags = []string{"testString"}
				versionModel.RepoURL = core.StringPtr("testString")
				versionModel.SourceURL = core.StringPtr("testString")
				versionModel.TgzURL = core.StringPtr("testString")
				versionModel.Configuration = []catalogmanagementv1.Configuration{*configurationModel}
				versionModel.Outputs = []catalogmanagementv1.Output{*outputModel}
				versionModel.IamPermissions = []catalogmanagementv1.IamPermission{*iamPermissionModel}
				versionModel.Metadata = make(map[string]interface{})
				versionModel.Validation = validationModel
				versionModel.RequiredResources = []catalogmanagementv1.Resource{*resourceModel}
				versionModel.SingleInstance = core.BoolPtr(true)
				versionModel.Install = scriptModel
				versionModel.PreInstall = []catalogmanagementv1.Script{*scriptModel}
				versionModel.Entitlement = versionEntitlementModel
				versionModel.Licenses = []catalogmanagementv1.License{*licenseModel}
				versionModel.ImageManifestURL = core.StringPtr("testString")
				versionModel.Deprecated = core.BoolPtr(true)
				versionModel.PackageVersion = core.StringPtr("testString")
				versionModel.State = stateModel
				versionModel.VersionLocator = core.StringPtr("testString")
				versionModel.LongDescription = core.StringPtr("testString")
				versionModel.LongDescriptionI18n = make(map[string]string)
				versionModel.WhitelistedAccounts = []string{"testString"}
				versionModel.ImagePullKeyName = core.StringPtr("testString")
				versionModel.DeprecatePending = deprecatePendingModel
				versionModel.SolutionInfo = solutionInfoModel
				versionModel.IsConsumable = core.BoolPtr(true)

				// Construct an instance of the Deployment model
				deploymentModel := new(catalogmanagementv1.Deployment)
				deploymentModel.ID = core.StringPtr("testString")
				deploymentModel.Label = core.StringPtr("testString")
				deploymentModel.Name = core.StringPtr("testString")
				deploymentModel.ShortDescription = core.StringPtr("testString")
				deploymentModel.LongDescription = core.StringPtr("testString")
				deploymentModel.Metadata = make(map[string]interface{})
				deploymentModel.Tags = []string{"testString"}
				deploymentModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				deploymentModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the Plan model
				planModel := new(catalogmanagementv1.Plan)
				planModel.ID = core.StringPtr("testString")
				planModel.Label = core.StringPtr("testString")
				planModel.Name = core.StringPtr("testString")
				planModel.ShortDescription = core.StringPtr("testString")
				planModel.LongDescription = core.StringPtr("testString")
				planModel.Metadata = make(map[string]interface{})
				planModel.Tags = []string{"testString"}
				planModel.AdditionalFeatures = []catalogmanagementv1.Feature{*featureModel}
				planModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.Deployments = []catalogmanagementv1.Deployment{*deploymentModel}

				// Construct an instance of the Kind model
				kindModel := new(catalogmanagementv1.Kind)
				kindModel.ID = core.StringPtr("testString")
				kindModel.FormatKind = core.StringPtr("testString")
				kindModel.InstallKind = core.StringPtr("testString")
				kindModel.TargetKind = core.StringPtr("testString")
				kindModel.Metadata = make(map[string]interface{})
				kindModel.Tags = []string{"testString"}
				kindModel.AdditionalFeatures = []catalogmanagementv1.Feature{*featureModel}
				kindModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Versions = []catalogmanagementv1.Version{*versionModel}
				kindModel.Plans = []catalogmanagementv1.Plan{*planModel}

				// Construct an instance of the ProviderInfo model
				providerInfoModel := new(catalogmanagementv1.ProviderInfo)
				providerInfoModel.ID = core.StringPtr("testString")
				providerInfoModel.Name = core.StringPtr("testString")

				// Construct an instance of the RepoInfo model
				repoInfoModel := new(catalogmanagementv1.RepoInfo)
				repoInfoModel.Token = core.StringPtr("testString")
				repoInfoModel.Type = core.StringPtr("testString")

				// Construct an instance of the ImagePullKey model
				imagePullKeyModel := new(catalogmanagementv1.ImagePullKey)
				imagePullKeyModel.Name = core.StringPtr("testString")
				imagePullKeyModel.Value = core.StringPtr("testString")
				imagePullKeyModel.Description = core.StringPtr("testString")

				// Construct an instance of the SupportWaitTime model
				supportWaitTimeModel := new(catalogmanagementv1.SupportWaitTime)
				supportWaitTimeModel.Value = core.Int64Ptr(int64(38))
				supportWaitTimeModel.Type = core.StringPtr("testString")

				// Construct an instance of the SupportTime model
				supportTimeModel := new(catalogmanagementv1.SupportTime)
				supportTimeModel.Day = core.Int64Ptr(int64(38))
				supportTimeModel.StartTime = core.StringPtr("testString")
				supportTimeModel.EndTime = core.StringPtr("testString")

				// Construct an instance of the SupportAvailability model
				supportAvailabilityModel := new(catalogmanagementv1.SupportAvailability)
				supportAvailabilityModel.Times = []catalogmanagementv1.SupportTime{*supportTimeModel}
				supportAvailabilityModel.Timezone = core.StringPtr("testString")
				supportAvailabilityModel.AlwaysAvailable = core.BoolPtr(true)

				// Construct an instance of the SupportDetail model
				supportDetailModel := new(catalogmanagementv1.SupportDetail)
				supportDetailModel.Type = core.StringPtr("testString")
				supportDetailModel.Contact = core.StringPtr("testString")
				supportDetailModel.ResponseWaitTime = supportWaitTimeModel
				supportDetailModel.Availability = supportAvailabilityModel

				// Construct an instance of the SupportEscalation model
				supportEscalationModel := new(catalogmanagementv1.SupportEscalation)
				supportEscalationModel.EscalationWaitTime = supportWaitTimeModel
				supportEscalationModel.ResponseWaitTime = supportWaitTimeModel
				supportEscalationModel.Contact = core.StringPtr("testString")

				// Construct an instance of the Support model
				supportModel := new(catalogmanagementv1.Support)
				supportModel.URL = core.StringPtr("testString")
				supportModel.Process = core.StringPtr("testString")
				supportModel.ProcessI18n = make(map[string]string)
				supportModel.Locations = []string{"testString"}
				supportModel.SupportDetails = []catalogmanagementv1.SupportDetail{*supportDetailModel}
				supportModel.SupportEscalation = supportEscalationModel
				supportModel.SupportType = core.StringPtr("testString")

				// Construct an instance of the LearnMoreLinks model
				learnMoreLinksModel := new(catalogmanagementv1.LearnMoreLinks)
				learnMoreLinksModel.FirstParty = core.StringPtr("testString")
				learnMoreLinksModel.ThirdParty = core.StringPtr("testString")

				// Construct an instance of the Constraint model
				constraintModel := new(catalogmanagementv1.Constraint)
				constraintModel.Type = core.StringPtr("testString")
				constraintModel.Rule = core.StringPtr("testString")

				// Construct an instance of the Badge model
				badgeModel := new(catalogmanagementv1.Badge)
				badgeModel.ID = core.StringPtr("testString")
				badgeModel.Label = core.StringPtr("testString")
				badgeModel.LabelI18n = make(map[string]string)
				badgeModel.Description = core.StringPtr("testString")
				badgeModel.DescriptionI18n = make(map[string]string)
				badgeModel.Icon = core.StringPtr("testString")
				badgeModel.Authority = core.StringPtr("testString")
				badgeModel.Tag = core.StringPtr("testString")
				badgeModel.LearnMoreLinks = learnMoreLinksModel
				badgeModel.Constraints = []catalogmanagementv1.Constraint{*constraintModel}

				// Construct an instance of the CreateOfferingOptions model
				createOfferingOptionsModel := new(catalogmanagementv1.CreateOfferingOptions)
				createOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				createOfferingOptionsModel.ID = core.StringPtr("testString")
				createOfferingOptionsModel.Rev = core.StringPtr("testString")
				createOfferingOptionsModel.URL = core.StringPtr("testString")
				createOfferingOptionsModel.CRN = core.StringPtr("testString")
				createOfferingOptionsModel.Label = core.StringPtr("testString")
				createOfferingOptionsModel.LabelI18n = make(map[string]string)
				createOfferingOptionsModel.Name = core.StringPtr("testString")
				createOfferingOptionsModel.OfferingIconURL = core.StringPtr("testString")
				createOfferingOptionsModel.OfferingDocsURL = core.StringPtr("testString")
				createOfferingOptionsModel.OfferingSupportURL = core.StringPtr("testString")
				createOfferingOptionsModel.Tags = []string{"testString"}
				createOfferingOptionsModel.Keywords = []string{"testString"}
				createOfferingOptionsModel.Rating = ratingModel
				createOfferingOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createOfferingOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createOfferingOptionsModel.ShortDescription = core.StringPtr("testString")
				createOfferingOptionsModel.ShortDescriptionI18n = make(map[string]string)
				createOfferingOptionsModel.LongDescription = core.StringPtr("testString")
				createOfferingOptionsModel.LongDescriptionI18n = make(map[string]string)
				createOfferingOptionsModel.Features = []catalogmanagementv1.Feature{*featureModel}
				createOfferingOptionsModel.Kinds = []catalogmanagementv1.Kind{*kindModel}
				createOfferingOptionsModel.PcManaged = core.BoolPtr(true)
				createOfferingOptionsModel.PublishApproved = core.BoolPtr(true)
				createOfferingOptionsModel.ShareWithAll = core.BoolPtr(true)
				createOfferingOptionsModel.ShareWithIBM = core.BoolPtr(true)
				createOfferingOptionsModel.ShareEnabled = core.BoolPtr(true)
				createOfferingOptionsModel.PermitRequestIBMPublicPublish = core.BoolPtr(true)
				createOfferingOptionsModel.IBMPublishApproved = core.BoolPtr(true)
				createOfferingOptionsModel.PublicPublishApproved = core.BoolPtr(true)
				createOfferingOptionsModel.PublicOriginalCRN = core.StringPtr("testString")
				createOfferingOptionsModel.PublishPublicCRN = core.StringPtr("testString")
				createOfferingOptionsModel.PortalApprovalRecord = core.StringPtr("testString")
				createOfferingOptionsModel.PortalUIURL = core.StringPtr("testString")
				createOfferingOptionsModel.CatalogID = core.StringPtr("testString")
				createOfferingOptionsModel.CatalogName = core.StringPtr("testString")
				createOfferingOptionsModel.Metadata = make(map[string]interface{})
				createOfferingOptionsModel.Disclaimer = core.StringPtr("testString")
				createOfferingOptionsModel.Hidden = core.BoolPtr(true)
				createOfferingOptionsModel.Provider = core.StringPtr("testString")
				createOfferingOptionsModel.ProviderInfo = providerInfoModel
				createOfferingOptionsModel.RepoInfo = repoInfoModel
				createOfferingOptionsModel.ImagePullKeys = []catalogmanagementv1.ImagePullKey{*imagePullKeyModel}
				createOfferingOptionsModel.Support = supportModel
				createOfferingOptionsModel.Media = []catalogmanagementv1.MediaItem{*mediaItemModel}
				createOfferingOptionsModel.DeprecatePending = deprecatePendingModel
				createOfferingOptionsModel.ProductKind = core.StringPtr("testString")
				createOfferingOptionsModel.Badges = []catalogmanagementv1.Badge{*badgeModel}
				createOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.CreateOffering(createOfferingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ImportOfferingVersion(importOfferingVersionOptions *ImportOfferingVersionOptions) - Operation response error`, func() {
		importOfferingVersionPath := "/catalogs/testString/offerings/testString/version"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(importOfferingVersionPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["X-Auth-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["zipurl"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["targetVersion"]).To(Equal([]string{"testString"}))
					// TODO: Add check for includeConfig query parameter
					// TODO: Add check for isVSI query parameter
					Expect(req.URL.Query()["repotype"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ImportOfferingVersion with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = make(map[string]string)
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the ImportOfferingBodyMetadataOperatingSystem model
				importOfferingBodyMetadataOperatingSystemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataOperatingSystem)
				importOfferingBodyMetadataOperatingSystemModel.DedicatedHostOnly = core.BoolPtr(true)
				importOfferingBodyMetadataOperatingSystemModel.Vendor = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Href = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.DisplayName = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Family = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Version = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Architecture = core.StringPtr("testString")

				// Construct an instance of the ImportOfferingBodyMetadataFile model
				importOfferingBodyMetadataFileModel := new(catalogmanagementv1.ImportOfferingBodyMetadataFile)
				importOfferingBodyMetadataFileModel.Size = core.Int64Ptr(int64(38))

				// Construct an instance of the ImportOfferingBodyMetadataImagesItem model
				importOfferingBodyMetadataImagesItemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataImagesItem)
				importOfferingBodyMetadataImagesItemModel.ID = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Region = core.StringPtr("testString")

				// Construct an instance of the ImportOfferingBodyMetadata model
				importOfferingBodyMetadataModel := new(catalogmanagementv1.ImportOfferingBodyMetadata)
				importOfferingBodyMetadataModel.OperatingSystem = importOfferingBodyMetadataOperatingSystemModel
				importOfferingBodyMetadataModel.File = importOfferingBodyMetadataFileModel
				importOfferingBodyMetadataModel.MinimumProvisionedSize = core.Int64Ptr(int64(38))
				importOfferingBodyMetadataModel.Images = []catalogmanagementv1.ImportOfferingBodyMetadataImagesItem{*importOfferingBodyMetadataImagesItemModel}

				// Construct an instance of the ImportOfferingVersionOptions model
				importOfferingVersionOptionsModel := new(catalogmanagementv1.ImportOfferingVersionOptions)
				importOfferingVersionOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				importOfferingVersionOptionsModel.OfferingID = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Tags = []string{"testString"}
				importOfferingVersionOptionsModel.Content = CreateMockByteArray("This is a mock byte array value.")
				importOfferingVersionOptionsModel.Name = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Label = core.StringPtr("testString")
				importOfferingVersionOptionsModel.InstallKind = core.StringPtr("testString")
				importOfferingVersionOptionsModel.TargetKinds = []string{"testString"}
				importOfferingVersionOptionsModel.FormatKind = core.StringPtr("testString")
				importOfferingVersionOptionsModel.ProductKind = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Sha = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Version = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Flavor = flavorModel
				importOfferingVersionOptionsModel.Metadata = importOfferingBodyMetadataModel
				importOfferingVersionOptionsModel.WorkingDirectory = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Zipurl = core.StringPtr("testString")
				importOfferingVersionOptionsModel.TargetVersion = core.StringPtr("testString")
				importOfferingVersionOptionsModel.IncludeConfig = core.BoolPtr(true)
				importOfferingVersionOptionsModel.IsVsi = core.BoolPtr(true)
				importOfferingVersionOptionsModel.Repotype = core.StringPtr("testString")
				importOfferingVersionOptionsModel.XAuthToken = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.ImportOfferingVersion(importOfferingVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.ImportOfferingVersion(importOfferingVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ImportOfferingVersion(importOfferingVersionOptions *ImportOfferingVersionOptions)`, func() {
		importOfferingVersionPath := "/catalogs/testString/offerings/testString/version"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(importOfferingVersionPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["X-Auth-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["zipurl"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["targetVersion"]).To(Equal([]string{"testString"}))
					// TODO: Add check for includeConfig query parameter
					// TODO: Add check for isVSI query parameter
					Expect(req.URL.Query()["repotype"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "offering_icon_url": "OfferingIconURL", "offering_docs_url": "OfferingDocsURL", "offering_support_url": "OfferingSupportURL", "tags": ["Tags"], "keywords": ["Keywords"], "rating": {"one_star_count": 12, "two_star_count": 12, "three_star_count": 14, "four_star_count": 13}, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "kinds": [{"id": "ID", "format_kind": "FormatKind", "install_kind": "InstallKind", "target_kind": "TargetKind", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"mapKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"mapKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "version": "Version", "flavors": ["Flavors"]}]}, "is_consumable": true}], "plans": [{"id": "ID", "label": "Label", "name": "Name", "short_description": "ShortDescription", "long_description": "LongDescription", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "deployments": [{"id": "ID", "label": "Label", "name": "Name", "short_description": "ShortDescription", "long_description": "LongDescription", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z"}]}]}], "pc_managed": false, "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "permit_request_ibm_public_publish": false, "ibm_publish_approved": true, "public_publish_approved": false, "public_original_crn": "PublicOriginalCRN", "publish_public_crn": "PublishPublicCRN", "portal_approval_record": "PortalApprovalRecord", "portal_ui_url": "PortalUIURL", "catalog_id": "CatalogID", "catalog_name": "CatalogName", "metadata": {"mapKey": "anyValue"}, "disclaimer": "Disclaimer", "hidden": true, "provider": "Provider", "provider_info": {"id": "ID", "name": "Name"}, "repo_info": {"token": "Token", "type": "Type"}, "image_pull_keys": [{"name": "Name", "value": "Value", "description": "Description"}], "support": {"url": "URL", "process": "Process", "process_i18n": {"mapKey": "Inner"}, "locations": ["Locations"], "support_details": [{"type": "Type", "contact": "Contact", "response_wait_time": {"value": 5, "type": "Type"}, "availability": {"times": [{"day": 3, "start_time": "StartTime", "end_time": "EndTime"}], "timezone": "Timezone", "always_available": false}}], "support_escalation": {"escalation_wait_time": {"value": 5, "type": "Type"}, "response_wait_time": {"value": 5, "type": "Type"}, "contact": "Contact"}, "support_type": "SupportType"}, "media": [{"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}], "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "product_kind": "ProductKind", "badges": [{"id": "ID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}, "icon": "Icon", "authority": "Authority", "tag": "Tag", "learn_more_links": {"first_party": "FirstParty", "third_party": "ThirdParty"}, "constraints": [{"type": "Type", "rule": "anyValue"}]}]}`)
				}))
			})
			It(`Invoke ImportOfferingVersion successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = make(map[string]string)
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the ImportOfferingBodyMetadataOperatingSystem model
				importOfferingBodyMetadataOperatingSystemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataOperatingSystem)
				importOfferingBodyMetadataOperatingSystemModel.DedicatedHostOnly = core.BoolPtr(true)
				importOfferingBodyMetadataOperatingSystemModel.Vendor = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Href = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.DisplayName = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Family = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Version = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Architecture = core.StringPtr("testString")

				// Construct an instance of the ImportOfferingBodyMetadataFile model
				importOfferingBodyMetadataFileModel := new(catalogmanagementv1.ImportOfferingBodyMetadataFile)
				importOfferingBodyMetadataFileModel.Size = core.Int64Ptr(int64(38))

				// Construct an instance of the ImportOfferingBodyMetadataImagesItem model
				importOfferingBodyMetadataImagesItemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataImagesItem)
				importOfferingBodyMetadataImagesItemModel.ID = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Region = core.StringPtr("testString")

				// Construct an instance of the ImportOfferingBodyMetadata model
				importOfferingBodyMetadataModel := new(catalogmanagementv1.ImportOfferingBodyMetadata)
				importOfferingBodyMetadataModel.OperatingSystem = importOfferingBodyMetadataOperatingSystemModel
				importOfferingBodyMetadataModel.File = importOfferingBodyMetadataFileModel
				importOfferingBodyMetadataModel.MinimumProvisionedSize = core.Int64Ptr(int64(38))
				importOfferingBodyMetadataModel.Images = []catalogmanagementv1.ImportOfferingBodyMetadataImagesItem{*importOfferingBodyMetadataImagesItemModel}

				// Construct an instance of the ImportOfferingVersionOptions model
				importOfferingVersionOptionsModel := new(catalogmanagementv1.ImportOfferingVersionOptions)
				importOfferingVersionOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				importOfferingVersionOptionsModel.OfferingID = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Tags = []string{"testString"}
				importOfferingVersionOptionsModel.Content = CreateMockByteArray("This is a mock byte array value.")
				importOfferingVersionOptionsModel.Name = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Label = core.StringPtr("testString")
				importOfferingVersionOptionsModel.InstallKind = core.StringPtr("testString")
				importOfferingVersionOptionsModel.TargetKinds = []string{"testString"}
				importOfferingVersionOptionsModel.FormatKind = core.StringPtr("testString")
				importOfferingVersionOptionsModel.ProductKind = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Sha = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Version = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Flavor = flavorModel
				importOfferingVersionOptionsModel.Metadata = importOfferingBodyMetadataModel
				importOfferingVersionOptionsModel.WorkingDirectory = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Zipurl = core.StringPtr("testString")
				importOfferingVersionOptionsModel.TargetVersion = core.StringPtr("testString")
				importOfferingVersionOptionsModel.IncludeConfig = core.BoolPtr(true)
				importOfferingVersionOptionsModel.IsVsi = core.BoolPtr(true)
				importOfferingVersionOptionsModel.Repotype = core.StringPtr("testString")
				importOfferingVersionOptionsModel.XAuthToken = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.ImportOfferingVersionWithContext(ctx, importOfferingVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.ImportOfferingVersion(importOfferingVersionOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.ImportOfferingVersionWithContext(ctx, importOfferingVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(importOfferingVersionPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["X-Auth-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["zipurl"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["targetVersion"]).To(Equal([]string{"testString"}))
					// TODO: Add check for includeConfig query parameter
					// TODO: Add check for isVSI query parameter
					Expect(req.URL.Query()["repotype"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "offering_icon_url": "OfferingIconURL", "offering_docs_url": "OfferingDocsURL", "offering_support_url": "OfferingSupportURL", "tags": ["Tags"], "keywords": ["Keywords"], "rating": {"one_star_count": 12, "two_star_count": 12, "three_star_count": 14, "four_star_count": 13}, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "kinds": [{"id": "ID", "format_kind": "FormatKind", "install_kind": "InstallKind", "target_kind": "TargetKind", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"mapKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"mapKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "version": "Version", "flavors": ["Flavors"]}]}, "is_consumable": true}], "plans": [{"id": "ID", "label": "Label", "name": "Name", "short_description": "ShortDescription", "long_description": "LongDescription", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "deployments": [{"id": "ID", "label": "Label", "name": "Name", "short_description": "ShortDescription", "long_description": "LongDescription", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z"}]}]}], "pc_managed": false, "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "permit_request_ibm_public_publish": false, "ibm_publish_approved": true, "public_publish_approved": false, "public_original_crn": "PublicOriginalCRN", "publish_public_crn": "PublishPublicCRN", "portal_approval_record": "PortalApprovalRecord", "portal_ui_url": "PortalUIURL", "catalog_id": "CatalogID", "catalog_name": "CatalogName", "metadata": {"mapKey": "anyValue"}, "disclaimer": "Disclaimer", "hidden": true, "provider": "Provider", "provider_info": {"id": "ID", "name": "Name"}, "repo_info": {"token": "Token", "type": "Type"}, "image_pull_keys": [{"name": "Name", "value": "Value", "description": "Description"}], "support": {"url": "URL", "process": "Process", "process_i18n": {"mapKey": "Inner"}, "locations": ["Locations"], "support_details": [{"type": "Type", "contact": "Contact", "response_wait_time": {"value": 5, "type": "Type"}, "availability": {"times": [{"day": 3, "start_time": "StartTime", "end_time": "EndTime"}], "timezone": "Timezone", "always_available": false}}], "support_escalation": {"escalation_wait_time": {"value": 5, "type": "Type"}, "response_wait_time": {"value": 5, "type": "Type"}, "contact": "Contact"}, "support_type": "SupportType"}, "media": [{"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}], "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "product_kind": "ProductKind", "badges": [{"id": "ID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}, "icon": "Icon", "authority": "Authority", "tag": "Tag", "learn_more_links": {"first_party": "FirstParty", "third_party": "ThirdParty"}, "constraints": [{"type": "Type", "rule": "anyValue"}]}]}`)
				}))
			})
			It(`Invoke ImportOfferingVersion successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.ImportOfferingVersion(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = make(map[string]string)
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the ImportOfferingBodyMetadataOperatingSystem model
				importOfferingBodyMetadataOperatingSystemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataOperatingSystem)
				importOfferingBodyMetadataOperatingSystemModel.DedicatedHostOnly = core.BoolPtr(true)
				importOfferingBodyMetadataOperatingSystemModel.Vendor = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Href = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.DisplayName = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Family = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Version = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Architecture = core.StringPtr("testString")

				// Construct an instance of the ImportOfferingBodyMetadataFile model
				importOfferingBodyMetadataFileModel := new(catalogmanagementv1.ImportOfferingBodyMetadataFile)
				importOfferingBodyMetadataFileModel.Size = core.Int64Ptr(int64(38))

				// Construct an instance of the ImportOfferingBodyMetadataImagesItem model
				importOfferingBodyMetadataImagesItemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataImagesItem)
				importOfferingBodyMetadataImagesItemModel.ID = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Region = core.StringPtr("testString")

				// Construct an instance of the ImportOfferingBodyMetadata model
				importOfferingBodyMetadataModel := new(catalogmanagementv1.ImportOfferingBodyMetadata)
				importOfferingBodyMetadataModel.OperatingSystem = importOfferingBodyMetadataOperatingSystemModel
				importOfferingBodyMetadataModel.File = importOfferingBodyMetadataFileModel
				importOfferingBodyMetadataModel.MinimumProvisionedSize = core.Int64Ptr(int64(38))
				importOfferingBodyMetadataModel.Images = []catalogmanagementv1.ImportOfferingBodyMetadataImagesItem{*importOfferingBodyMetadataImagesItemModel}

				// Construct an instance of the ImportOfferingVersionOptions model
				importOfferingVersionOptionsModel := new(catalogmanagementv1.ImportOfferingVersionOptions)
				importOfferingVersionOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				importOfferingVersionOptionsModel.OfferingID = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Tags = []string{"testString"}
				importOfferingVersionOptionsModel.Content = CreateMockByteArray("This is a mock byte array value.")
				importOfferingVersionOptionsModel.Name = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Label = core.StringPtr("testString")
				importOfferingVersionOptionsModel.InstallKind = core.StringPtr("testString")
				importOfferingVersionOptionsModel.TargetKinds = []string{"testString"}
				importOfferingVersionOptionsModel.FormatKind = core.StringPtr("testString")
				importOfferingVersionOptionsModel.ProductKind = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Sha = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Version = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Flavor = flavorModel
				importOfferingVersionOptionsModel.Metadata = importOfferingBodyMetadataModel
				importOfferingVersionOptionsModel.WorkingDirectory = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Zipurl = core.StringPtr("testString")
				importOfferingVersionOptionsModel.TargetVersion = core.StringPtr("testString")
				importOfferingVersionOptionsModel.IncludeConfig = core.BoolPtr(true)
				importOfferingVersionOptionsModel.IsVsi = core.BoolPtr(true)
				importOfferingVersionOptionsModel.Repotype = core.StringPtr("testString")
				importOfferingVersionOptionsModel.XAuthToken = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.ImportOfferingVersion(importOfferingVersionOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ImportOfferingVersion with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = make(map[string]string)
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the ImportOfferingBodyMetadataOperatingSystem model
				importOfferingBodyMetadataOperatingSystemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataOperatingSystem)
				importOfferingBodyMetadataOperatingSystemModel.DedicatedHostOnly = core.BoolPtr(true)
				importOfferingBodyMetadataOperatingSystemModel.Vendor = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Href = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.DisplayName = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Family = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Version = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Architecture = core.StringPtr("testString")

				// Construct an instance of the ImportOfferingBodyMetadataFile model
				importOfferingBodyMetadataFileModel := new(catalogmanagementv1.ImportOfferingBodyMetadataFile)
				importOfferingBodyMetadataFileModel.Size = core.Int64Ptr(int64(38))

				// Construct an instance of the ImportOfferingBodyMetadataImagesItem model
				importOfferingBodyMetadataImagesItemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataImagesItem)
				importOfferingBodyMetadataImagesItemModel.ID = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Region = core.StringPtr("testString")

				// Construct an instance of the ImportOfferingBodyMetadata model
				importOfferingBodyMetadataModel := new(catalogmanagementv1.ImportOfferingBodyMetadata)
				importOfferingBodyMetadataModel.OperatingSystem = importOfferingBodyMetadataOperatingSystemModel
				importOfferingBodyMetadataModel.File = importOfferingBodyMetadataFileModel
				importOfferingBodyMetadataModel.MinimumProvisionedSize = core.Int64Ptr(int64(38))
				importOfferingBodyMetadataModel.Images = []catalogmanagementv1.ImportOfferingBodyMetadataImagesItem{*importOfferingBodyMetadataImagesItemModel}

				// Construct an instance of the ImportOfferingVersionOptions model
				importOfferingVersionOptionsModel := new(catalogmanagementv1.ImportOfferingVersionOptions)
				importOfferingVersionOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				importOfferingVersionOptionsModel.OfferingID = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Tags = []string{"testString"}
				importOfferingVersionOptionsModel.Content = CreateMockByteArray("This is a mock byte array value.")
				importOfferingVersionOptionsModel.Name = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Label = core.StringPtr("testString")
				importOfferingVersionOptionsModel.InstallKind = core.StringPtr("testString")
				importOfferingVersionOptionsModel.TargetKinds = []string{"testString"}
				importOfferingVersionOptionsModel.FormatKind = core.StringPtr("testString")
				importOfferingVersionOptionsModel.ProductKind = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Sha = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Version = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Flavor = flavorModel
				importOfferingVersionOptionsModel.Metadata = importOfferingBodyMetadataModel
				importOfferingVersionOptionsModel.WorkingDirectory = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Zipurl = core.StringPtr("testString")
				importOfferingVersionOptionsModel.TargetVersion = core.StringPtr("testString")
				importOfferingVersionOptionsModel.IncludeConfig = core.BoolPtr(true)
				importOfferingVersionOptionsModel.IsVsi = core.BoolPtr(true)
				importOfferingVersionOptionsModel.Repotype = core.StringPtr("testString")
				importOfferingVersionOptionsModel.XAuthToken = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.ImportOfferingVersion(importOfferingVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ImportOfferingVersionOptions model with no property values
				importOfferingVersionOptionsModelNew := new(catalogmanagementv1.ImportOfferingVersionOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.ImportOfferingVersion(importOfferingVersionOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke ImportOfferingVersion successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = make(map[string]string)
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the ImportOfferingBodyMetadataOperatingSystem model
				importOfferingBodyMetadataOperatingSystemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataOperatingSystem)
				importOfferingBodyMetadataOperatingSystemModel.DedicatedHostOnly = core.BoolPtr(true)
				importOfferingBodyMetadataOperatingSystemModel.Vendor = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Href = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.DisplayName = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Family = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Version = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Architecture = core.StringPtr("testString")

				// Construct an instance of the ImportOfferingBodyMetadataFile model
				importOfferingBodyMetadataFileModel := new(catalogmanagementv1.ImportOfferingBodyMetadataFile)
				importOfferingBodyMetadataFileModel.Size = core.Int64Ptr(int64(38))

				// Construct an instance of the ImportOfferingBodyMetadataImagesItem model
				importOfferingBodyMetadataImagesItemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataImagesItem)
				importOfferingBodyMetadataImagesItemModel.ID = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Region = core.StringPtr("testString")

				// Construct an instance of the ImportOfferingBodyMetadata model
				importOfferingBodyMetadataModel := new(catalogmanagementv1.ImportOfferingBodyMetadata)
				importOfferingBodyMetadataModel.OperatingSystem = importOfferingBodyMetadataOperatingSystemModel
				importOfferingBodyMetadataModel.File = importOfferingBodyMetadataFileModel
				importOfferingBodyMetadataModel.MinimumProvisionedSize = core.Int64Ptr(int64(38))
				importOfferingBodyMetadataModel.Images = []catalogmanagementv1.ImportOfferingBodyMetadataImagesItem{*importOfferingBodyMetadataImagesItemModel}

				// Construct an instance of the ImportOfferingVersionOptions model
				importOfferingVersionOptionsModel := new(catalogmanagementv1.ImportOfferingVersionOptions)
				importOfferingVersionOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				importOfferingVersionOptionsModel.OfferingID = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Tags = []string{"testString"}
				importOfferingVersionOptionsModel.Content = CreateMockByteArray("This is a mock byte array value.")
				importOfferingVersionOptionsModel.Name = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Label = core.StringPtr("testString")
				importOfferingVersionOptionsModel.InstallKind = core.StringPtr("testString")
				importOfferingVersionOptionsModel.TargetKinds = []string{"testString"}
				importOfferingVersionOptionsModel.FormatKind = core.StringPtr("testString")
				importOfferingVersionOptionsModel.ProductKind = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Sha = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Version = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Flavor = flavorModel
				importOfferingVersionOptionsModel.Metadata = importOfferingBodyMetadataModel
				importOfferingVersionOptionsModel.WorkingDirectory = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Zipurl = core.StringPtr("testString")
				importOfferingVersionOptionsModel.TargetVersion = core.StringPtr("testString")
				importOfferingVersionOptionsModel.IncludeConfig = core.BoolPtr(true)
				importOfferingVersionOptionsModel.IsVsi = core.BoolPtr(true)
				importOfferingVersionOptionsModel.Repotype = core.StringPtr("testString")
				importOfferingVersionOptionsModel.XAuthToken = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.ImportOfferingVersion(importOfferingVersionOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ImportOffering(importOfferingOptions *ImportOfferingOptions) - Operation response error`, func() {
		importOfferingPath := "/catalogs/testString/import/offerings"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(importOfferingPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["X-Auth-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["zipurl"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["offeringID"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["targetVersion"]).To(Equal([]string{"testString"}))
					// TODO: Add check for includeConfig query parameter
					// TODO: Add check for isVSI query parameter
					Expect(req.URL.Query()["repotype"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ImportOffering with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = make(map[string]string)
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the ImportOfferingBodyMetadataOperatingSystem model
				importOfferingBodyMetadataOperatingSystemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataOperatingSystem)
				importOfferingBodyMetadataOperatingSystemModel.DedicatedHostOnly = core.BoolPtr(true)
				importOfferingBodyMetadataOperatingSystemModel.Vendor = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Href = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.DisplayName = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Family = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Version = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Architecture = core.StringPtr("testString")

				// Construct an instance of the ImportOfferingBodyMetadataFile model
				importOfferingBodyMetadataFileModel := new(catalogmanagementv1.ImportOfferingBodyMetadataFile)
				importOfferingBodyMetadataFileModel.Size = core.Int64Ptr(int64(38))

				// Construct an instance of the ImportOfferingBodyMetadataImagesItem model
				importOfferingBodyMetadataImagesItemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataImagesItem)
				importOfferingBodyMetadataImagesItemModel.ID = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Region = core.StringPtr("testString")

				// Construct an instance of the ImportOfferingBodyMetadata model
				importOfferingBodyMetadataModel := new(catalogmanagementv1.ImportOfferingBodyMetadata)
				importOfferingBodyMetadataModel.OperatingSystem = importOfferingBodyMetadataOperatingSystemModel
				importOfferingBodyMetadataModel.File = importOfferingBodyMetadataFileModel
				importOfferingBodyMetadataModel.MinimumProvisionedSize = core.Int64Ptr(int64(38))
				importOfferingBodyMetadataModel.Images = []catalogmanagementv1.ImportOfferingBodyMetadataImagesItem{*importOfferingBodyMetadataImagesItemModel}

				// Construct an instance of the ImportOfferingOptions model
				importOfferingOptionsModel := new(catalogmanagementv1.ImportOfferingOptions)
				importOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				importOfferingOptionsModel.Tags = []string{"testString"}
				importOfferingOptionsModel.Content = CreateMockByteArray("This is a mock byte array value.")
				importOfferingOptionsModel.Name = core.StringPtr("testString")
				importOfferingOptionsModel.Label = core.StringPtr("testString")
				importOfferingOptionsModel.InstallKind = core.StringPtr("testString")
				importOfferingOptionsModel.TargetKinds = []string{"testString"}
				importOfferingOptionsModel.FormatKind = core.StringPtr("testString")
				importOfferingOptionsModel.ProductKind = core.StringPtr("testString")
				importOfferingOptionsModel.Sha = core.StringPtr("testString")
				importOfferingOptionsModel.Version = core.StringPtr("testString")
				importOfferingOptionsModel.Flavor = flavorModel
				importOfferingOptionsModel.Metadata = importOfferingBodyMetadataModel
				importOfferingOptionsModel.WorkingDirectory = core.StringPtr("testString")
				importOfferingOptionsModel.Zipurl = core.StringPtr("testString")
				importOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				importOfferingOptionsModel.TargetVersion = core.StringPtr("testString")
				importOfferingOptionsModel.IncludeConfig = core.BoolPtr(true)
				importOfferingOptionsModel.IsVsi = core.BoolPtr(true)
				importOfferingOptionsModel.Repotype = core.StringPtr("testString")
				importOfferingOptionsModel.XAuthToken = core.StringPtr("testString")
				importOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.ImportOffering(importOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.ImportOffering(importOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ImportOffering(importOfferingOptions *ImportOfferingOptions)`, func() {
		importOfferingPath := "/catalogs/testString/import/offerings"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(importOfferingPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["X-Auth-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["zipurl"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["offeringID"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["targetVersion"]).To(Equal([]string{"testString"}))
					// TODO: Add check for includeConfig query parameter
					// TODO: Add check for isVSI query parameter
					Expect(req.URL.Query()["repotype"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "offering_icon_url": "OfferingIconURL", "offering_docs_url": "OfferingDocsURL", "offering_support_url": "OfferingSupportURL", "tags": ["Tags"], "keywords": ["Keywords"], "rating": {"one_star_count": 12, "two_star_count": 12, "three_star_count": 14, "four_star_count": 13}, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "kinds": [{"id": "ID", "format_kind": "FormatKind", "install_kind": "InstallKind", "target_kind": "TargetKind", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"mapKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"mapKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "version": "Version", "flavors": ["Flavors"]}]}, "is_consumable": true}], "plans": [{"id": "ID", "label": "Label", "name": "Name", "short_description": "ShortDescription", "long_description": "LongDescription", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "deployments": [{"id": "ID", "label": "Label", "name": "Name", "short_description": "ShortDescription", "long_description": "LongDescription", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z"}]}]}], "pc_managed": false, "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "permit_request_ibm_public_publish": false, "ibm_publish_approved": true, "public_publish_approved": false, "public_original_crn": "PublicOriginalCRN", "publish_public_crn": "PublishPublicCRN", "portal_approval_record": "PortalApprovalRecord", "portal_ui_url": "PortalUIURL", "catalog_id": "CatalogID", "catalog_name": "CatalogName", "metadata": {"mapKey": "anyValue"}, "disclaimer": "Disclaimer", "hidden": true, "provider": "Provider", "provider_info": {"id": "ID", "name": "Name"}, "repo_info": {"token": "Token", "type": "Type"}, "image_pull_keys": [{"name": "Name", "value": "Value", "description": "Description"}], "support": {"url": "URL", "process": "Process", "process_i18n": {"mapKey": "Inner"}, "locations": ["Locations"], "support_details": [{"type": "Type", "contact": "Contact", "response_wait_time": {"value": 5, "type": "Type"}, "availability": {"times": [{"day": 3, "start_time": "StartTime", "end_time": "EndTime"}], "timezone": "Timezone", "always_available": false}}], "support_escalation": {"escalation_wait_time": {"value": 5, "type": "Type"}, "response_wait_time": {"value": 5, "type": "Type"}, "contact": "Contact"}, "support_type": "SupportType"}, "media": [{"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}], "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "product_kind": "ProductKind", "badges": [{"id": "ID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}, "icon": "Icon", "authority": "Authority", "tag": "Tag", "learn_more_links": {"first_party": "FirstParty", "third_party": "ThirdParty"}, "constraints": [{"type": "Type", "rule": "anyValue"}]}]}`)
				}))
			})
			It(`Invoke ImportOffering successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = make(map[string]string)
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the ImportOfferingBodyMetadataOperatingSystem model
				importOfferingBodyMetadataOperatingSystemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataOperatingSystem)
				importOfferingBodyMetadataOperatingSystemModel.DedicatedHostOnly = core.BoolPtr(true)
				importOfferingBodyMetadataOperatingSystemModel.Vendor = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Href = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.DisplayName = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Family = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Version = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Architecture = core.StringPtr("testString")

				// Construct an instance of the ImportOfferingBodyMetadataFile model
				importOfferingBodyMetadataFileModel := new(catalogmanagementv1.ImportOfferingBodyMetadataFile)
				importOfferingBodyMetadataFileModel.Size = core.Int64Ptr(int64(38))

				// Construct an instance of the ImportOfferingBodyMetadataImagesItem model
				importOfferingBodyMetadataImagesItemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataImagesItem)
				importOfferingBodyMetadataImagesItemModel.ID = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Region = core.StringPtr("testString")

				// Construct an instance of the ImportOfferingBodyMetadata model
				importOfferingBodyMetadataModel := new(catalogmanagementv1.ImportOfferingBodyMetadata)
				importOfferingBodyMetadataModel.OperatingSystem = importOfferingBodyMetadataOperatingSystemModel
				importOfferingBodyMetadataModel.File = importOfferingBodyMetadataFileModel
				importOfferingBodyMetadataModel.MinimumProvisionedSize = core.Int64Ptr(int64(38))
				importOfferingBodyMetadataModel.Images = []catalogmanagementv1.ImportOfferingBodyMetadataImagesItem{*importOfferingBodyMetadataImagesItemModel}

				// Construct an instance of the ImportOfferingOptions model
				importOfferingOptionsModel := new(catalogmanagementv1.ImportOfferingOptions)
				importOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				importOfferingOptionsModel.Tags = []string{"testString"}
				importOfferingOptionsModel.Content = CreateMockByteArray("This is a mock byte array value.")
				importOfferingOptionsModel.Name = core.StringPtr("testString")
				importOfferingOptionsModel.Label = core.StringPtr("testString")
				importOfferingOptionsModel.InstallKind = core.StringPtr("testString")
				importOfferingOptionsModel.TargetKinds = []string{"testString"}
				importOfferingOptionsModel.FormatKind = core.StringPtr("testString")
				importOfferingOptionsModel.ProductKind = core.StringPtr("testString")
				importOfferingOptionsModel.Sha = core.StringPtr("testString")
				importOfferingOptionsModel.Version = core.StringPtr("testString")
				importOfferingOptionsModel.Flavor = flavorModel
				importOfferingOptionsModel.Metadata = importOfferingBodyMetadataModel
				importOfferingOptionsModel.WorkingDirectory = core.StringPtr("testString")
				importOfferingOptionsModel.Zipurl = core.StringPtr("testString")
				importOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				importOfferingOptionsModel.TargetVersion = core.StringPtr("testString")
				importOfferingOptionsModel.IncludeConfig = core.BoolPtr(true)
				importOfferingOptionsModel.IsVsi = core.BoolPtr(true)
				importOfferingOptionsModel.Repotype = core.StringPtr("testString")
				importOfferingOptionsModel.XAuthToken = core.StringPtr("testString")
				importOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.ImportOfferingWithContext(ctx, importOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.ImportOffering(importOfferingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.ImportOfferingWithContext(ctx, importOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(importOfferingPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["X-Auth-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["zipurl"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["offeringID"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["targetVersion"]).To(Equal([]string{"testString"}))
					// TODO: Add check for includeConfig query parameter
					// TODO: Add check for isVSI query parameter
					Expect(req.URL.Query()["repotype"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "offering_icon_url": "OfferingIconURL", "offering_docs_url": "OfferingDocsURL", "offering_support_url": "OfferingSupportURL", "tags": ["Tags"], "keywords": ["Keywords"], "rating": {"one_star_count": 12, "two_star_count": 12, "three_star_count": 14, "four_star_count": 13}, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "kinds": [{"id": "ID", "format_kind": "FormatKind", "install_kind": "InstallKind", "target_kind": "TargetKind", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"mapKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"mapKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "version": "Version", "flavors": ["Flavors"]}]}, "is_consumable": true}], "plans": [{"id": "ID", "label": "Label", "name": "Name", "short_description": "ShortDescription", "long_description": "LongDescription", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "deployments": [{"id": "ID", "label": "Label", "name": "Name", "short_description": "ShortDescription", "long_description": "LongDescription", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z"}]}]}], "pc_managed": false, "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "permit_request_ibm_public_publish": false, "ibm_publish_approved": true, "public_publish_approved": false, "public_original_crn": "PublicOriginalCRN", "publish_public_crn": "PublishPublicCRN", "portal_approval_record": "PortalApprovalRecord", "portal_ui_url": "PortalUIURL", "catalog_id": "CatalogID", "catalog_name": "CatalogName", "metadata": {"mapKey": "anyValue"}, "disclaimer": "Disclaimer", "hidden": true, "provider": "Provider", "provider_info": {"id": "ID", "name": "Name"}, "repo_info": {"token": "Token", "type": "Type"}, "image_pull_keys": [{"name": "Name", "value": "Value", "description": "Description"}], "support": {"url": "URL", "process": "Process", "process_i18n": {"mapKey": "Inner"}, "locations": ["Locations"], "support_details": [{"type": "Type", "contact": "Contact", "response_wait_time": {"value": 5, "type": "Type"}, "availability": {"times": [{"day": 3, "start_time": "StartTime", "end_time": "EndTime"}], "timezone": "Timezone", "always_available": false}}], "support_escalation": {"escalation_wait_time": {"value": 5, "type": "Type"}, "response_wait_time": {"value": 5, "type": "Type"}, "contact": "Contact"}, "support_type": "SupportType"}, "media": [{"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}], "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "product_kind": "ProductKind", "badges": [{"id": "ID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}, "icon": "Icon", "authority": "Authority", "tag": "Tag", "learn_more_links": {"first_party": "FirstParty", "third_party": "ThirdParty"}, "constraints": [{"type": "Type", "rule": "anyValue"}]}]}`)
				}))
			})
			It(`Invoke ImportOffering successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.ImportOffering(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = make(map[string]string)
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the ImportOfferingBodyMetadataOperatingSystem model
				importOfferingBodyMetadataOperatingSystemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataOperatingSystem)
				importOfferingBodyMetadataOperatingSystemModel.DedicatedHostOnly = core.BoolPtr(true)
				importOfferingBodyMetadataOperatingSystemModel.Vendor = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Href = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.DisplayName = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Family = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Version = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Architecture = core.StringPtr("testString")

				// Construct an instance of the ImportOfferingBodyMetadataFile model
				importOfferingBodyMetadataFileModel := new(catalogmanagementv1.ImportOfferingBodyMetadataFile)
				importOfferingBodyMetadataFileModel.Size = core.Int64Ptr(int64(38))

				// Construct an instance of the ImportOfferingBodyMetadataImagesItem model
				importOfferingBodyMetadataImagesItemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataImagesItem)
				importOfferingBodyMetadataImagesItemModel.ID = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Region = core.StringPtr("testString")

				// Construct an instance of the ImportOfferingBodyMetadata model
				importOfferingBodyMetadataModel := new(catalogmanagementv1.ImportOfferingBodyMetadata)
				importOfferingBodyMetadataModel.OperatingSystem = importOfferingBodyMetadataOperatingSystemModel
				importOfferingBodyMetadataModel.File = importOfferingBodyMetadataFileModel
				importOfferingBodyMetadataModel.MinimumProvisionedSize = core.Int64Ptr(int64(38))
				importOfferingBodyMetadataModel.Images = []catalogmanagementv1.ImportOfferingBodyMetadataImagesItem{*importOfferingBodyMetadataImagesItemModel}

				// Construct an instance of the ImportOfferingOptions model
				importOfferingOptionsModel := new(catalogmanagementv1.ImportOfferingOptions)
				importOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				importOfferingOptionsModel.Tags = []string{"testString"}
				importOfferingOptionsModel.Content = CreateMockByteArray("This is a mock byte array value.")
				importOfferingOptionsModel.Name = core.StringPtr("testString")
				importOfferingOptionsModel.Label = core.StringPtr("testString")
				importOfferingOptionsModel.InstallKind = core.StringPtr("testString")
				importOfferingOptionsModel.TargetKinds = []string{"testString"}
				importOfferingOptionsModel.FormatKind = core.StringPtr("testString")
				importOfferingOptionsModel.ProductKind = core.StringPtr("testString")
				importOfferingOptionsModel.Sha = core.StringPtr("testString")
				importOfferingOptionsModel.Version = core.StringPtr("testString")
				importOfferingOptionsModel.Flavor = flavorModel
				importOfferingOptionsModel.Metadata = importOfferingBodyMetadataModel
				importOfferingOptionsModel.WorkingDirectory = core.StringPtr("testString")
				importOfferingOptionsModel.Zipurl = core.StringPtr("testString")
				importOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				importOfferingOptionsModel.TargetVersion = core.StringPtr("testString")
				importOfferingOptionsModel.IncludeConfig = core.BoolPtr(true)
				importOfferingOptionsModel.IsVsi = core.BoolPtr(true)
				importOfferingOptionsModel.Repotype = core.StringPtr("testString")
				importOfferingOptionsModel.XAuthToken = core.StringPtr("testString")
				importOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.ImportOffering(importOfferingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ImportOffering with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = make(map[string]string)
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the ImportOfferingBodyMetadataOperatingSystem model
				importOfferingBodyMetadataOperatingSystemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataOperatingSystem)
				importOfferingBodyMetadataOperatingSystemModel.DedicatedHostOnly = core.BoolPtr(true)
				importOfferingBodyMetadataOperatingSystemModel.Vendor = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Href = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.DisplayName = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Family = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Version = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Architecture = core.StringPtr("testString")

				// Construct an instance of the ImportOfferingBodyMetadataFile model
				importOfferingBodyMetadataFileModel := new(catalogmanagementv1.ImportOfferingBodyMetadataFile)
				importOfferingBodyMetadataFileModel.Size = core.Int64Ptr(int64(38))

				// Construct an instance of the ImportOfferingBodyMetadataImagesItem model
				importOfferingBodyMetadataImagesItemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataImagesItem)
				importOfferingBodyMetadataImagesItemModel.ID = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Region = core.StringPtr("testString")

				// Construct an instance of the ImportOfferingBodyMetadata model
				importOfferingBodyMetadataModel := new(catalogmanagementv1.ImportOfferingBodyMetadata)
				importOfferingBodyMetadataModel.OperatingSystem = importOfferingBodyMetadataOperatingSystemModel
				importOfferingBodyMetadataModel.File = importOfferingBodyMetadataFileModel
				importOfferingBodyMetadataModel.MinimumProvisionedSize = core.Int64Ptr(int64(38))
				importOfferingBodyMetadataModel.Images = []catalogmanagementv1.ImportOfferingBodyMetadataImagesItem{*importOfferingBodyMetadataImagesItemModel}

				// Construct an instance of the ImportOfferingOptions model
				importOfferingOptionsModel := new(catalogmanagementv1.ImportOfferingOptions)
				importOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				importOfferingOptionsModel.Tags = []string{"testString"}
				importOfferingOptionsModel.Content = CreateMockByteArray("This is a mock byte array value.")
				importOfferingOptionsModel.Name = core.StringPtr("testString")
				importOfferingOptionsModel.Label = core.StringPtr("testString")
				importOfferingOptionsModel.InstallKind = core.StringPtr("testString")
				importOfferingOptionsModel.TargetKinds = []string{"testString"}
				importOfferingOptionsModel.FormatKind = core.StringPtr("testString")
				importOfferingOptionsModel.ProductKind = core.StringPtr("testString")
				importOfferingOptionsModel.Sha = core.StringPtr("testString")
				importOfferingOptionsModel.Version = core.StringPtr("testString")
				importOfferingOptionsModel.Flavor = flavorModel
				importOfferingOptionsModel.Metadata = importOfferingBodyMetadataModel
				importOfferingOptionsModel.WorkingDirectory = core.StringPtr("testString")
				importOfferingOptionsModel.Zipurl = core.StringPtr("testString")
				importOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				importOfferingOptionsModel.TargetVersion = core.StringPtr("testString")
				importOfferingOptionsModel.IncludeConfig = core.BoolPtr(true)
				importOfferingOptionsModel.IsVsi = core.BoolPtr(true)
				importOfferingOptionsModel.Repotype = core.StringPtr("testString")
				importOfferingOptionsModel.XAuthToken = core.StringPtr("testString")
				importOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.ImportOffering(importOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ImportOfferingOptions model with no property values
				importOfferingOptionsModelNew := new(catalogmanagementv1.ImportOfferingOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.ImportOffering(importOfferingOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke ImportOffering successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = make(map[string]string)
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the ImportOfferingBodyMetadataOperatingSystem model
				importOfferingBodyMetadataOperatingSystemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataOperatingSystem)
				importOfferingBodyMetadataOperatingSystemModel.DedicatedHostOnly = core.BoolPtr(true)
				importOfferingBodyMetadataOperatingSystemModel.Vendor = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Href = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.DisplayName = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Family = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Version = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Architecture = core.StringPtr("testString")

				// Construct an instance of the ImportOfferingBodyMetadataFile model
				importOfferingBodyMetadataFileModel := new(catalogmanagementv1.ImportOfferingBodyMetadataFile)
				importOfferingBodyMetadataFileModel.Size = core.Int64Ptr(int64(38))

				// Construct an instance of the ImportOfferingBodyMetadataImagesItem model
				importOfferingBodyMetadataImagesItemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataImagesItem)
				importOfferingBodyMetadataImagesItemModel.ID = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Region = core.StringPtr("testString")

				// Construct an instance of the ImportOfferingBodyMetadata model
				importOfferingBodyMetadataModel := new(catalogmanagementv1.ImportOfferingBodyMetadata)
				importOfferingBodyMetadataModel.OperatingSystem = importOfferingBodyMetadataOperatingSystemModel
				importOfferingBodyMetadataModel.File = importOfferingBodyMetadataFileModel
				importOfferingBodyMetadataModel.MinimumProvisionedSize = core.Int64Ptr(int64(38))
				importOfferingBodyMetadataModel.Images = []catalogmanagementv1.ImportOfferingBodyMetadataImagesItem{*importOfferingBodyMetadataImagesItemModel}

				// Construct an instance of the ImportOfferingOptions model
				importOfferingOptionsModel := new(catalogmanagementv1.ImportOfferingOptions)
				importOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				importOfferingOptionsModel.Tags = []string{"testString"}
				importOfferingOptionsModel.Content = CreateMockByteArray("This is a mock byte array value.")
				importOfferingOptionsModel.Name = core.StringPtr("testString")
				importOfferingOptionsModel.Label = core.StringPtr("testString")
				importOfferingOptionsModel.InstallKind = core.StringPtr("testString")
				importOfferingOptionsModel.TargetKinds = []string{"testString"}
				importOfferingOptionsModel.FormatKind = core.StringPtr("testString")
				importOfferingOptionsModel.ProductKind = core.StringPtr("testString")
				importOfferingOptionsModel.Sha = core.StringPtr("testString")
				importOfferingOptionsModel.Version = core.StringPtr("testString")
				importOfferingOptionsModel.Flavor = flavorModel
				importOfferingOptionsModel.Metadata = importOfferingBodyMetadataModel
				importOfferingOptionsModel.WorkingDirectory = core.StringPtr("testString")
				importOfferingOptionsModel.Zipurl = core.StringPtr("testString")
				importOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				importOfferingOptionsModel.TargetVersion = core.StringPtr("testString")
				importOfferingOptionsModel.IncludeConfig = core.BoolPtr(true)
				importOfferingOptionsModel.IsVsi = core.BoolPtr(true)
				importOfferingOptionsModel.Repotype = core.StringPtr("testString")
				importOfferingOptionsModel.XAuthToken = core.StringPtr("testString")
				importOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.ImportOffering(importOfferingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ReloadOffering(reloadOfferingOptions *ReloadOfferingOptions) - Operation response error`, func() {
		reloadOfferingPath := "/catalogs/testString/offerings/testString/reload"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(reloadOfferingPath))
					Expect(req.Method).To(Equal("PUT"))
					Expect(req.URL.Query()["targetVersion"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["zipurl"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["repoType"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ReloadOffering with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = make(map[string]string)
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the ReloadOfferingOptions model
				reloadOfferingOptionsModel := new(catalogmanagementv1.ReloadOfferingOptions)
				reloadOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				reloadOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				reloadOfferingOptionsModel.TargetVersion = core.StringPtr("testString")
				reloadOfferingOptionsModel.Tags = []string{"testString"}
				reloadOfferingOptionsModel.Content = CreateMockByteArray("This is a mock byte array value.")
				reloadOfferingOptionsModel.TargetKinds = []string{"testString"}
				reloadOfferingOptionsModel.FormatKind = core.StringPtr("testString")
				reloadOfferingOptionsModel.Flavor = flavorModel
				reloadOfferingOptionsModel.WorkingDirectory = core.StringPtr("testString")
				reloadOfferingOptionsModel.Zipurl = core.StringPtr("testString")
				reloadOfferingOptionsModel.RepoType = core.StringPtr("testString")
				reloadOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.ReloadOffering(reloadOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.ReloadOffering(reloadOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ReloadOffering(reloadOfferingOptions *ReloadOfferingOptions)`, func() {
		reloadOfferingPath := "/catalogs/testString/offerings/testString/reload"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(reloadOfferingPath))
					Expect(req.Method).To(Equal("PUT"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.URL.Query()["targetVersion"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["zipurl"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["repoType"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "offering_icon_url": "OfferingIconURL", "offering_docs_url": "OfferingDocsURL", "offering_support_url": "OfferingSupportURL", "tags": ["Tags"], "keywords": ["Keywords"], "rating": {"one_star_count": 12, "two_star_count": 12, "three_star_count": 14, "four_star_count": 13}, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "kinds": [{"id": "ID", "format_kind": "FormatKind", "install_kind": "InstallKind", "target_kind": "TargetKind", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"mapKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"mapKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "version": "Version", "flavors": ["Flavors"]}]}, "is_consumable": true}], "plans": [{"id": "ID", "label": "Label", "name": "Name", "short_description": "ShortDescription", "long_description": "LongDescription", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "deployments": [{"id": "ID", "label": "Label", "name": "Name", "short_description": "ShortDescription", "long_description": "LongDescription", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z"}]}]}], "pc_managed": false, "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "permit_request_ibm_public_publish": false, "ibm_publish_approved": true, "public_publish_approved": false, "public_original_crn": "PublicOriginalCRN", "publish_public_crn": "PublishPublicCRN", "portal_approval_record": "PortalApprovalRecord", "portal_ui_url": "PortalUIURL", "catalog_id": "CatalogID", "catalog_name": "CatalogName", "metadata": {"mapKey": "anyValue"}, "disclaimer": "Disclaimer", "hidden": true, "provider": "Provider", "provider_info": {"id": "ID", "name": "Name"}, "repo_info": {"token": "Token", "type": "Type"}, "image_pull_keys": [{"name": "Name", "value": "Value", "description": "Description"}], "support": {"url": "URL", "process": "Process", "process_i18n": {"mapKey": "Inner"}, "locations": ["Locations"], "support_details": [{"type": "Type", "contact": "Contact", "response_wait_time": {"value": 5, "type": "Type"}, "availability": {"times": [{"day": 3, "start_time": "StartTime", "end_time": "EndTime"}], "timezone": "Timezone", "always_available": false}}], "support_escalation": {"escalation_wait_time": {"value": 5, "type": "Type"}, "response_wait_time": {"value": 5, "type": "Type"}, "contact": "Contact"}, "support_type": "SupportType"}, "media": [{"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}], "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "product_kind": "ProductKind", "badges": [{"id": "ID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}, "icon": "Icon", "authority": "Authority", "tag": "Tag", "learn_more_links": {"first_party": "FirstParty", "third_party": "ThirdParty"}, "constraints": [{"type": "Type", "rule": "anyValue"}]}]}`)
				}))
			})
			It(`Invoke ReloadOffering successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = make(map[string]string)
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the ReloadOfferingOptions model
				reloadOfferingOptionsModel := new(catalogmanagementv1.ReloadOfferingOptions)
				reloadOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				reloadOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				reloadOfferingOptionsModel.TargetVersion = core.StringPtr("testString")
				reloadOfferingOptionsModel.Tags = []string{"testString"}
				reloadOfferingOptionsModel.Content = CreateMockByteArray("This is a mock byte array value.")
				reloadOfferingOptionsModel.TargetKinds = []string{"testString"}
				reloadOfferingOptionsModel.FormatKind = core.StringPtr("testString")
				reloadOfferingOptionsModel.Flavor = flavorModel
				reloadOfferingOptionsModel.WorkingDirectory = core.StringPtr("testString")
				reloadOfferingOptionsModel.Zipurl = core.StringPtr("testString")
				reloadOfferingOptionsModel.RepoType = core.StringPtr("testString")
				reloadOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.ReloadOfferingWithContext(ctx, reloadOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.ReloadOffering(reloadOfferingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.ReloadOfferingWithContext(ctx, reloadOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(reloadOfferingPath))
					Expect(req.Method).To(Equal("PUT"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.URL.Query()["targetVersion"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["zipurl"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["repoType"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "offering_icon_url": "OfferingIconURL", "offering_docs_url": "OfferingDocsURL", "offering_support_url": "OfferingSupportURL", "tags": ["Tags"], "keywords": ["Keywords"], "rating": {"one_star_count": 12, "two_star_count": 12, "three_star_count": 14, "four_star_count": 13}, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "kinds": [{"id": "ID", "format_kind": "FormatKind", "install_kind": "InstallKind", "target_kind": "TargetKind", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"mapKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"mapKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "version": "Version", "flavors": ["Flavors"]}]}, "is_consumable": true}], "plans": [{"id": "ID", "label": "Label", "name": "Name", "short_description": "ShortDescription", "long_description": "LongDescription", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "deployments": [{"id": "ID", "label": "Label", "name": "Name", "short_description": "ShortDescription", "long_description": "LongDescription", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z"}]}]}], "pc_managed": false, "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "permit_request_ibm_public_publish": false, "ibm_publish_approved": true, "public_publish_approved": false, "public_original_crn": "PublicOriginalCRN", "publish_public_crn": "PublishPublicCRN", "portal_approval_record": "PortalApprovalRecord", "portal_ui_url": "PortalUIURL", "catalog_id": "CatalogID", "catalog_name": "CatalogName", "metadata": {"mapKey": "anyValue"}, "disclaimer": "Disclaimer", "hidden": true, "provider": "Provider", "provider_info": {"id": "ID", "name": "Name"}, "repo_info": {"token": "Token", "type": "Type"}, "image_pull_keys": [{"name": "Name", "value": "Value", "description": "Description"}], "support": {"url": "URL", "process": "Process", "process_i18n": {"mapKey": "Inner"}, "locations": ["Locations"], "support_details": [{"type": "Type", "contact": "Contact", "response_wait_time": {"value": 5, "type": "Type"}, "availability": {"times": [{"day": 3, "start_time": "StartTime", "end_time": "EndTime"}], "timezone": "Timezone", "always_available": false}}], "support_escalation": {"escalation_wait_time": {"value": 5, "type": "Type"}, "response_wait_time": {"value": 5, "type": "Type"}, "contact": "Contact"}, "support_type": "SupportType"}, "media": [{"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}], "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "product_kind": "ProductKind", "badges": [{"id": "ID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}, "icon": "Icon", "authority": "Authority", "tag": "Tag", "learn_more_links": {"first_party": "FirstParty", "third_party": "ThirdParty"}, "constraints": [{"type": "Type", "rule": "anyValue"}]}]}`)
				}))
			})
			It(`Invoke ReloadOffering successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.ReloadOffering(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = make(map[string]string)
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the ReloadOfferingOptions model
				reloadOfferingOptionsModel := new(catalogmanagementv1.ReloadOfferingOptions)
				reloadOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				reloadOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				reloadOfferingOptionsModel.TargetVersion = core.StringPtr("testString")
				reloadOfferingOptionsModel.Tags = []string{"testString"}
				reloadOfferingOptionsModel.Content = CreateMockByteArray("This is a mock byte array value.")
				reloadOfferingOptionsModel.TargetKinds = []string{"testString"}
				reloadOfferingOptionsModel.FormatKind = core.StringPtr("testString")
				reloadOfferingOptionsModel.Flavor = flavorModel
				reloadOfferingOptionsModel.WorkingDirectory = core.StringPtr("testString")
				reloadOfferingOptionsModel.Zipurl = core.StringPtr("testString")
				reloadOfferingOptionsModel.RepoType = core.StringPtr("testString")
				reloadOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.ReloadOffering(reloadOfferingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ReloadOffering with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = make(map[string]string)
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the ReloadOfferingOptions model
				reloadOfferingOptionsModel := new(catalogmanagementv1.ReloadOfferingOptions)
				reloadOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				reloadOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				reloadOfferingOptionsModel.TargetVersion = core.StringPtr("testString")
				reloadOfferingOptionsModel.Tags = []string{"testString"}
				reloadOfferingOptionsModel.Content = CreateMockByteArray("This is a mock byte array value.")
				reloadOfferingOptionsModel.TargetKinds = []string{"testString"}
				reloadOfferingOptionsModel.FormatKind = core.StringPtr("testString")
				reloadOfferingOptionsModel.Flavor = flavorModel
				reloadOfferingOptionsModel.WorkingDirectory = core.StringPtr("testString")
				reloadOfferingOptionsModel.Zipurl = core.StringPtr("testString")
				reloadOfferingOptionsModel.RepoType = core.StringPtr("testString")
				reloadOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.ReloadOffering(reloadOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ReloadOfferingOptions model with no property values
				reloadOfferingOptionsModelNew := new(catalogmanagementv1.ReloadOfferingOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.ReloadOffering(reloadOfferingOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ReloadOffering successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = make(map[string]string)
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the ReloadOfferingOptions model
				reloadOfferingOptionsModel := new(catalogmanagementv1.ReloadOfferingOptions)
				reloadOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				reloadOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				reloadOfferingOptionsModel.TargetVersion = core.StringPtr("testString")
				reloadOfferingOptionsModel.Tags = []string{"testString"}
				reloadOfferingOptionsModel.Content = CreateMockByteArray("This is a mock byte array value.")
				reloadOfferingOptionsModel.TargetKinds = []string{"testString"}
				reloadOfferingOptionsModel.FormatKind = core.StringPtr("testString")
				reloadOfferingOptionsModel.Flavor = flavorModel
				reloadOfferingOptionsModel.WorkingDirectory = core.StringPtr("testString")
				reloadOfferingOptionsModel.Zipurl = core.StringPtr("testString")
				reloadOfferingOptionsModel.RepoType = core.StringPtr("testString")
				reloadOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.ReloadOffering(reloadOfferingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetOffering(getOfferingOptions *GetOfferingOptions) - Operation response error`, func() {
		getOfferingPath := "/catalogs/testString/offerings/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.URL.Query()["type"]).To(Equal([]string{"testString"}))
					// TODO: Add check for digest query parameter
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetOffering with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingOptions model
				getOfferingOptionsModel := new(catalogmanagementv1.GetOfferingOptions)
				getOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingOptionsModel.Type = core.StringPtr("testString")
				getOfferingOptionsModel.Digest = core.BoolPtr(true)
				getOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetOffering(getOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetOffering(getOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetOffering(getOfferingOptions *GetOfferingOptions)`, func() {
		getOfferingPath := "/catalogs/testString/offerings/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["type"]).To(Equal([]string{"testString"}))
					// TODO: Add check for digest query parameter
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "offering_icon_url": "OfferingIconURL", "offering_docs_url": "OfferingDocsURL", "offering_support_url": "OfferingSupportURL", "tags": ["Tags"], "keywords": ["Keywords"], "rating": {"one_star_count": 12, "two_star_count": 12, "three_star_count": 14, "four_star_count": 13}, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "kinds": [{"id": "ID", "format_kind": "FormatKind", "install_kind": "InstallKind", "target_kind": "TargetKind", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"mapKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"mapKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "version": "Version", "flavors": ["Flavors"]}]}, "is_consumable": true}], "plans": [{"id": "ID", "label": "Label", "name": "Name", "short_description": "ShortDescription", "long_description": "LongDescription", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "deployments": [{"id": "ID", "label": "Label", "name": "Name", "short_description": "ShortDescription", "long_description": "LongDescription", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z"}]}]}], "pc_managed": false, "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "permit_request_ibm_public_publish": false, "ibm_publish_approved": true, "public_publish_approved": false, "public_original_crn": "PublicOriginalCRN", "publish_public_crn": "PublishPublicCRN", "portal_approval_record": "PortalApprovalRecord", "portal_ui_url": "PortalUIURL", "catalog_id": "CatalogID", "catalog_name": "CatalogName", "metadata": {"mapKey": "anyValue"}, "disclaimer": "Disclaimer", "hidden": true, "provider": "Provider", "provider_info": {"id": "ID", "name": "Name"}, "repo_info": {"token": "Token", "type": "Type"}, "image_pull_keys": [{"name": "Name", "value": "Value", "description": "Description"}], "support": {"url": "URL", "process": "Process", "process_i18n": {"mapKey": "Inner"}, "locations": ["Locations"], "support_details": [{"type": "Type", "contact": "Contact", "response_wait_time": {"value": 5, "type": "Type"}, "availability": {"times": [{"day": 3, "start_time": "StartTime", "end_time": "EndTime"}], "timezone": "Timezone", "always_available": false}}], "support_escalation": {"escalation_wait_time": {"value": 5, "type": "Type"}, "response_wait_time": {"value": 5, "type": "Type"}, "contact": "Contact"}, "support_type": "SupportType"}, "media": [{"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}], "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "product_kind": "ProductKind", "badges": [{"id": "ID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}, "icon": "Icon", "authority": "Authority", "tag": "Tag", "learn_more_links": {"first_party": "FirstParty", "third_party": "ThirdParty"}, "constraints": [{"type": "Type", "rule": "anyValue"}]}]}`)
				}))
			})
			It(`Invoke GetOffering successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetOfferingOptions model
				getOfferingOptionsModel := new(catalogmanagementv1.GetOfferingOptions)
				getOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingOptionsModel.Type = core.StringPtr("testString")
				getOfferingOptionsModel.Digest = core.BoolPtr(true)
				getOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetOfferingWithContext(ctx, getOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetOffering(getOfferingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetOfferingWithContext(ctx, getOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["type"]).To(Equal([]string{"testString"}))
					// TODO: Add check for digest query parameter
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "offering_icon_url": "OfferingIconURL", "offering_docs_url": "OfferingDocsURL", "offering_support_url": "OfferingSupportURL", "tags": ["Tags"], "keywords": ["Keywords"], "rating": {"one_star_count": 12, "two_star_count": 12, "three_star_count": 14, "four_star_count": 13}, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "kinds": [{"id": "ID", "format_kind": "FormatKind", "install_kind": "InstallKind", "target_kind": "TargetKind", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"mapKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"mapKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "version": "Version", "flavors": ["Flavors"]}]}, "is_consumable": true}], "plans": [{"id": "ID", "label": "Label", "name": "Name", "short_description": "ShortDescription", "long_description": "LongDescription", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "deployments": [{"id": "ID", "label": "Label", "name": "Name", "short_description": "ShortDescription", "long_description": "LongDescription", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z"}]}]}], "pc_managed": false, "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "permit_request_ibm_public_publish": false, "ibm_publish_approved": true, "public_publish_approved": false, "public_original_crn": "PublicOriginalCRN", "publish_public_crn": "PublishPublicCRN", "portal_approval_record": "PortalApprovalRecord", "portal_ui_url": "PortalUIURL", "catalog_id": "CatalogID", "catalog_name": "CatalogName", "metadata": {"mapKey": "anyValue"}, "disclaimer": "Disclaimer", "hidden": true, "provider": "Provider", "provider_info": {"id": "ID", "name": "Name"}, "repo_info": {"token": "Token", "type": "Type"}, "image_pull_keys": [{"name": "Name", "value": "Value", "description": "Description"}], "support": {"url": "URL", "process": "Process", "process_i18n": {"mapKey": "Inner"}, "locations": ["Locations"], "support_details": [{"type": "Type", "contact": "Contact", "response_wait_time": {"value": 5, "type": "Type"}, "availability": {"times": [{"day": 3, "start_time": "StartTime", "end_time": "EndTime"}], "timezone": "Timezone", "always_available": false}}], "support_escalation": {"escalation_wait_time": {"value": 5, "type": "Type"}, "response_wait_time": {"value": 5, "type": "Type"}, "contact": "Contact"}, "support_type": "SupportType"}, "media": [{"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}], "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "product_kind": "ProductKind", "badges": [{"id": "ID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}, "icon": "Icon", "authority": "Authority", "tag": "Tag", "learn_more_links": {"first_party": "FirstParty", "third_party": "ThirdParty"}, "constraints": [{"type": "Type", "rule": "anyValue"}]}]}`)
				}))
			})
			It(`Invoke GetOffering successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetOffering(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetOfferingOptions model
				getOfferingOptionsModel := new(catalogmanagementv1.GetOfferingOptions)
				getOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingOptionsModel.Type = core.StringPtr("testString")
				getOfferingOptionsModel.Digest = core.BoolPtr(true)
				getOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetOffering(getOfferingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetOffering with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingOptions model
				getOfferingOptionsModel := new(catalogmanagementv1.GetOfferingOptions)
				getOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingOptionsModel.Type = core.StringPtr("testString")
				getOfferingOptionsModel.Digest = core.BoolPtr(true)
				getOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetOffering(getOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetOfferingOptions model with no property values
				getOfferingOptionsModelNew := new(catalogmanagementv1.GetOfferingOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetOffering(getOfferingOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetOffering successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingOptions model
				getOfferingOptionsModel := new(catalogmanagementv1.GetOfferingOptions)
				getOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingOptionsModel.Type = core.StringPtr("testString")
				getOfferingOptionsModel.Digest = core.BoolPtr(true)
				getOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetOffering(getOfferingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ReplaceOffering(replaceOfferingOptions *ReplaceOfferingOptions) - Operation response error`, func() {
		replaceOfferingPath := "/catalogs/testString/offerings/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(replaceOfferingPath))
					Expect(req.Method).To(Equal("PUT"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ReplaceOffering with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Rating model
				ratingModel := new(catalogmanagementv1.Rating)
				ratingModel.OneStarCount = core.Int64Ptr(int64(38))
				ratingModel.TwoStarCount = core.Int64Ptr(int64(38))
				ratingModel.ThreeStarCount = core.Int64Ptr(int64(38))
				ratingModel.FourStarCount = core.Int64Ptr(int64(38))

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = make(map[string]string)
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = make(map[string]string)

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = make(map[string]string)
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the RenderTypeAssociationsParametersItem model
				renderTypeAssociationsParametersItemModel := new(catalogmanagementv1.RenderTypeAssociationsParametersItem)
				renderTypeAssociationsParametersItemModel.Name = core.StringPtr("testString")
				renderTypeAssociationsParametersItemModel.OptionsRefresh = core.BoolPtr(true)

				// Construct an instance of the RenderTypeAssociations model
				renderTypeAssociationsModel := new(catalogmanagementv1.RenderTypeAssociations)
				renderTypeAssociationsModel.Parameters = []catalogmanagementv1.RenderTypeAssociationsParametersItem{*renderTypeAssociationsParametersItemModel}

				// Construct an instance of the RenderType model
				renderTypeModel := new(catalogmanagementv1.RenderType)
				renderTypeModel.Type = core.StringPtr("testString")
				renderTypeModel.Grouping = core.StringPtr("testString")
				renderTypeModel.OriginalGrouping = core.StringPtr("testString")
				renderTypeModel.GroupingIndex = core.Int64Ptr(int64(38))
				renderTypeModel.ConfigConstraints = map[string]interface{}{"anyKey": "anyValue"}
				renderTypeModel.Associations = renderTypeAssociationsModel

				// Construct an instance of the Configuration model
				configurationModel := new(catalogmanagementv1.Configuration)
				configurationModel.Key = core.StringPtr("testString")
				configurationModel.Type = core.StringPtr("testString")
				configurationModel.DefaultValue = core.StringPtr("testString")
				configurationModel.DisplayName = core.StringPtr("testString")
				configurationModel.ValueConstraint = core.StringPtr("testString")
				configurationModel.Description = core.StringPtr("testString")
				configurationModel.Required = core.BoolPtr(true)
				configurationModel.Options = []interface{}{"testString"}
				configurationModel.Hidden = core.BoolPtr(true)
				configurationModel.CustomConfig = renderTypeModel
				configurationModel.TypeMetadata = core.StringPtr("testString")

				// Construct an instance of the Output model
				outputModel := new(catalogmanagementv1.Output)
				outputModel.Key = core.StringPtr("testString")
				outputModel.Description = core.StringPtr("testString")

				// Construct an instance of the IamResource model
				iamResourceModel := new(catalogmanagementv1.IamResource)
				iamResourceModel.Name = core.StringPtr("testString")
				iamResourceModel.Description = core.StringPtr("testString")
				iamResourceModel.RoleCrns = []string{"testString"}

				// Construct an instance of the IamPermission model
				iamPermissionModel := new(catalogmanagementv1.IamPermission)
				iamPermissionModel.ServiceName = core.StringPtr("testString")
				iamPermissionModel.RoleCrns = []string{"testString"}
				iamPermissionModel.Resources = []catalogmanagementv1.IamResource{*iamResourceModel}

				// Construct an instance of the Validation model
				validationModel := new(catalogmanagementv1.Validation)
				validationModel.Validated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.Requested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.State = core.StringPtr("testString")
				validationModel.LastOperation = core.StringPtr("testString")
				validationModel.Target = make(map[string]interface{})
				validationModel.Message = core.StringPtr("testString")

				// Construct an instance of the Resource model
				resourceModel := new(catalogmanagementv1.Resource)
				resourceModel.Type = core.StringPtr("mem")
				resourceModel.Value = core.StringPtr("testString")

				// Construct an instance of the Script model
				scriptModel := new(catalogmanagementv1.Script)
				scriptModel.Instructions = core.StringPtr("testString")
				scriptModel.InstructionsI18n = make(map[string]string)
				scriptModel.Script = core.StringPtr("testString")
				scriptModel.ScriptPermission = core.StringPtr("testString")
				scriptModel.DeleteScript = core.StringPtr("testString")
				scriptModel.Scope = core.StringPtr("testString")

				// Construct an instance of the VersionEntitlement model
				versionEntitlementModel := new(catalogmanagementv1.VersionEntitlement)
				versionEntitlementModel.ProviderName = core.StringPtr("testString")
				versionEntitlementModel.ProviderID = core.StringPtr("testString")
				versionEntitlementModel.ProductID = core.StringPtr("testString")
				versionEntitlementModel.PartNumbers = []string{"testString"}
				versionEntitlementModel.ImageRepoName = core.StringPtr("testString")

				// Construct an instance of the License model
				licenseModel := new(catalogmanagementv1.License)
				licenseModel.ID = core.StringPtr("testString")
				licenseModel.Name = core.StringPtr("testString")
				licenseModel.Type = core.StringPtr("testString")
				licenseModel.URL = core.StringPtr("testString")
				licenseModel.Description = core.StringPtr("testString")

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")

				// Construct an instance of the DeprecatePending model
				deprecatePendingModel := new(catalogmanagementv1.DeprecatePending)
				deprecatePendingModel.DeprecateDate = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				deprecatePendingModel.DeprecateState = core.StringPtr("testString")
				deprecatePendingModel.Description = core.StringPtr("testString")

				// Construct an instance of the URLProxy model
				urlProxyModel := new(catalogmanagementv1.URLProxy)
				urlProxyModel.URL = core.StringPtr("testString")
				urlProxyModel.Sha = core.StringPtr("testString")

				// Construct an instance of the MediaItem model
				mediaItemModel := new(catalogmanagementv1.MediaItem)
				mediaItemModel.URL = core.StringPtr("testString")
				mediaItemModel.APIURL = core.StringPtr("testString")
				mediaItemModel.URLProxy = urlProxyModel
				mediaItemModel.Caption = core.StringPtr("testString")
				mediaItemModel.CaptionI18n = make(map[string]string)
				mediaItemModel.Type = core.StringPtr("testString")
				mediaItemModel.ThumbnailURL = core.StringPtr("testString")

				// Construct an instance of the ArchitectureDiagram model
				architectureDiagramModel := new(catalogmanagementv1.ArchitectureDiagram)
				architectureDiagramModel.Diagram = mediaItemModel
				architectureDiagramModel.Description = core.StringPtr("testString")
				architectureDiagramModel.DescriptionI18n = make(map[string]string)

				// Construct an instance of the CostComponent model
				costComponentModel := new(catalogmanagementv1.CostComponent)
				costComponentModel.Name = core.StringPtr("testString")
				costComponentModel.Unit = core.StringPtr("testString")
				costComponentModel.HourlyQuantity = core.StringPtr("testString")
				costComponentModel.MonthlyQuantity = core.StringPtr("testString")
				costComponentModel.Price = core.StringPtr("testString")
				costComponentModel.HourlyCost = core.StringPtr("testString")
				costComponentModel.MonthlyCost = core.StringPtr("testString")

				// Construct an instance of the CostResource model
				costResourceModel := new(catalogmanagementv1.CostResource)
				costResourceModel.Name = core.StringPtr("testString")
				costResourceModel.Metadata = make(map[string]interface{})
				costResourceModel.HourlyCost = core.StringPtr("testString")
				costResourceModel.MonthlyCost = core.StringPtr("testString")
				costResourceModel.CostComponents = []catalogmanagementv1.CostComponent{*costComponentModel}

				// Construct an instance of the CostBreakdown model
				costBreakdownModel := new(catalogmanagementv1.CostBreakdown)
				costBreakdownModel.TotalHourlyCost = core.StringPtr("testString")
				costBreakdownModel.TotalMonthlyCOst = core.StringPtr("testString")
				costBreakdownModel.Resources = []catalogmanagementv1.CostResource{*costResourceModel}

				// Construct an instance of the CostSummary model
				costSummaryModel := new(catalogmanagementv1.CostSummary)
				costSummaryModel.TotalDetectedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalSupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUnsupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUsageBasedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalNoPriceResources = core.Int64Ptr(int64(38))
				costSummaryModel.UnsupportedResourceCounts = make(map[string]int64)
				costSummaryModel.NoPriceResourceCounts = make(map[string]int64)

				// Construct an instance of the Project model
				projectModel := new(catalogmanagementv1.Project)
				projectModel.Name = core.StringPtr("testString")
				projectModel.Metadata = make(map[string]interface{})
				projectModel.PastBreakdown = costBreakdownModel
				projectModel.Breakdown = costBreakdownModel
				projectModel.Diff = costBreakdownModel
				projectModel.Summary = costSummaryModel

				// Construct an instance of the CostEstimate model
				costEstimateModel := new(catalogmanagementv1.CostEstimate)
				costEstimateModel.Version = core.StringPtr("testString")
				costEstimateModel.Currency = core.StringPtr("testString")
				costEstimateModel.Projects = []catalogmanagementv1.Project{*projectModel}
				costEstimateModel.Summary = costSummaryModel
				costEstimateModel.TotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.TotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.TimeGenerated = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the Dependency model
				dependencyModel := new(catalogmanagementv1.Dependency)
				dependencyModel.CatalogID = core.StringPtr("testString")
				dependencyModel.ID = core.StringPtr("testString")
				dependencyModel.Name = core.StringPtr("testString")
				dependencyModel.Version = core.StringPtr("testString")
				dependencyModel.Flavors = []string{"testString"}

				// Construct an instance of the SolutionInfo model
				solutionInfoModel := new(catalogmanagementv1.SolutionInfo)
				solutionInfoModel.ArchitectureDiagrams = []catalogmanagementv1.ArchitectureDiagram{*architectureDiagramModel}
				solutionInfoModel.Features = []catalogmanagementv1.Feature{*featureModel}
				solutionInfoModel.CostEstimate = costEstimateModel
				solutionInfoModel.Dependencies = []catalogmanagementv1.Dependency{*dependencyModel}

				// Construct an instance of the Version model
				versionModel := new(catalogmanagementv1.Version)
				versionModel.ID = core.StringPtr("testString")
				versionModel.Rev = core.StringPtr("testString")
				versionModel.CRN = core.StringPtr("testString")
				versionModel.Version = core.StringPtr("testString")
				versionModel.Flavor = flavorModel
				versionModel.Sha = core.StringPtr("testString")
				versionModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.OfferingID = core.StringPtr("testString")
				versionModel.CatalogID = core.StringPtr("testString")
				versionModel.KindID = core.StringPtr("testString")
				versionModel.Tags = []string{"testString"}
				versionModel.RepoURL = core.StringPtr("testString")
				versionModel.SourceURL = core.StringPtr("testString")
				versionModel.TgzURL = core.StringPtr("testString")
				versionModel.Configuration = []catalogmanagementv1.Configuration{*configurationModel}
				versionModel.Outputs = []catalogmanagementv1.Output{*outputModel}
				versionModel.IamPermissions = []catalogmanagementv1.IamPermission{*iamPermissionModel}
				versionModel.Metadata = make(map[string]interface{})
				versionModel.Validation = validationModel
				versionModel.RequiredResources = []catalogmanagementv1.Resource{*resourceModel}
				versionModel.SingleInstance = core.BoolPtr(true)
				versionModel.Install = scriptModel
				versionModel.PreInstall = []catalogmanagementv1.Script{*scriptModel}
				versionModel.Entitlement = versionEntitlementModel
				versionModel.Licenses = []catalogmanagementv1.License{*licenseModel}
				versionModel.ImageManifestURL = core.StringPtr("testString")
				versionModel.Deprecated = core.BoolPtr(true)
				versionModel.PackageVersion = core.StringPtr("testString")
				versionModel.State = stateModel
				versionModel.VersionLocator = core.StringPtr("testString")
				versionModel.LongDescription = core.StringPtr("testString")
				versionModel.LongDescriptionI18n = make(map[string]string)
				versionModel.WhitelistedAccounts = []string{"testString"}
				versionModel.ImagePullKeyName = core.StringPtr("testString")
				versionModel.DeprecatePending = deprecatePendingModel
				versionModel.SolutionInfo = solutionInfoModel
				versionModel.IsConsumable = core.BoolPtr(true)

				// Construct an instance of the Deployment model
				deploymentModel := new(catalogmanagementv1.Deployment)
				deploymentModel.ID = core.StringPtr("testString")
				deploymentModel.Label = core.StringPtr("testString")
				deploymentModel.Name = core.StringPtr("testString")
				deploymentModel.ShortDescription = core.StringPtr("testString")
				deploymentModel.LongDescription = core.StringPtr("testString")
				deploymentModel.Metadata = make(map[string]interface{})
				deploymentModel.Tags = []string{"testString"}
				deploymentModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				deploymentModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the Plan model
				planModel := new(catalogmanagementv1.Plan)
				planModel.ID = core.StringPtr("testString")
				planModel.Label = core.StringPtr("testString")
				planModel.Name = core.StringPtr("testString")
				planModel.ShortDescription = core.StringPtr("testString")
				planModel.LongDescription = core.StringPtr("testString")
				planModel.Metadata = make(map[string]interface{})
				planModel.Tags = []string{"testString"}
				planModel.AdditionalFeatures = []catalogmanagementv1.Feature{*featureModel}
				planModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.Deployments = []catalogmanagementv1.Deployment{*deploymentModel}

				// Construct an instance of the Kind model
				kindModel := new(catalogmanagementv1.Kind)
				kindModel.ID = core.StringPtr("testString")
				kindModel.FormatKind = core.StringPtr("testString")
				kindModel.InstallKind = core.StringPtr("testString")
				kindModel.TargetKind = core.StringPtr("testString")
				kindModel.Metadata = make(map[string]interface{})
				kindModel.Tags = []string{"testString"}
				kindModel.AdditionalFeatures = []catalogmanagementv1.Feature{*featureModel}
				kindModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Versions = []catalogmanagementv1.Version{*versionModel}
				kindModel.Plans = []catalogmanagementv1.Plan{*planModel}

				// Construct an instance of the ProviderInfo model
				providerInfoModel := new(catalogmanagementv1.ProviderInfo)
				providerInfoModel.ID = core.StringPtr("testString")
				providerInfoModel.Name = core.StringPtr("testString")

				// Construct an instance of the RepoInfo model
				repoInfoModel := new(catalogmanagementv1.RepoInfo)
				repoInfoModel.Token = core.StringPtr("testString")
				repoInfoModel.Type = core.StringPtr("testString")

				// Construct an instance of the ImagePullKey model
				imagePullKeyModel := new(catalogmanagementv1.ImagePullKey)
				imagePullKeyModel.Name = core.StringPtr("testString")
				imagePullKeyModel.Value = core.StringPtr("testString")
				imagePullKeyModel.Description = core.StringPtr("testString")

				// Construct an instance of the SupportWaitTime model
				supportWaitTimeModel := new(catalogmanagementv1.SupportWaitTime)
				supportWaitTimeModel.Value = core.Int64Ptr(int64(38))
				supportWaitTimeModel.Type = core.StringPtr("testString")

				// Construct an instance of the SupportTime model
				supportTimeModel := new(catalogmanagementv1.SupportTime)
				supportTimeModel.Day = core.Int64Ptr(int64(38))
				supportTimeModel.StartTime = core.StringPtr("testString")
				supportTimeModel.EndTime = core.StringPtr("testString")

				// Construct an instance of the SupportAvailability model
				supportAvailabilityModel := new(catalogmanagementv1.SupportAvailability)
				supportAvailabilityModel.Times = []catalogmanagementv1.SupportTime{*supportTimeModel}
				supportAvailabilityModel.Timezone = core.StringPtr("testString")
				supportAvailabilityModel.AlwaysAvailable = core.BoolPtr(true)

				// Construct an instance of the SupportDetail model
				supportDetailModel := new(catalogmanagementv1.SupportDetail)
				supportDetailModel.Type = core.StringPtr("testString")
				supportDetailModel.Contact = core.StringPtr("testString")
				supportDetailModel.ResponseWaitTime = supportWaitTimeModel
				supportDetailModel.Availability = supportAvailabilityModel

				// Construct an instance of the SupportEscalation model
				supportEscalationModel := new(catalogmanagementv1.SupportEscalation)
				supportEscalationModel.EscalationWaitTime = supportWaitTimeModel
				supportEscalationModel.ResponseWaitTime = supportWaitTimeModel
				supportEscalationModel.Contact = core.StringPtr("testString")

				// Construct an instance of the Support model
				supportModel := new(catalogmanagementv1.Support)
				supportModel.URL = core.StringPtr("testString")
				supportModel.Process = core.StringPtr("testString")
				supportModel.ProcessI18n = make(map[string]string)
				supportModel.Locations = []string{"testString"}
				supportModel.SupportDetails = []catalogmanagementv1.SupportDetail{*supportDetailModel}
				supportModel.SupportEscalation = supportEscalationModel
				supportModel.SupportType = core.StringPtr("testString")

				// Construct an instance of the LearnMoreLinks model
				learnMoreLinksModel := new(catalogmanagementv1.LearnMoreLinks)
				learnMoreLinksModel.FirstParty = core.StringPtr("testString")
				learnMoreLinksModel.ThirdParty = core.StringPtr("testString")

				// Construct an instance of the Constraint model
				constraintModel := new(catalogmanagementv1.Constraint)
				constraintModel.Type = core.StringPtr("testString")
				constraintModel.Rule = core.StringPtr("testString")

				// Construct an instance of the Badge model
				badgeModel := new(catalogmanagementv1.Badge)
				badgeModel.ID = core.StringPtr("testString")
				badgeModel.Label = core.StringPtr("testString")
				badgeModel.LabelI18n = make(map[string]string)
				badgeModel.Description = core.StringPtr("testString")
				badgeModel.DescriptionI18n = make(map[string]string)
				badgeModel.Icon = core.StringPtr("testString")
				badgeModel.Authority = core.StringPtr("testString")
				badgeModel.Tag = core.StringPtr("testString")
				badgeModel.LearnMoreLinks = learnMoreLinksModel
				badgeModel.Constraints = []catalogmanagementv1.Constraint{*constraintModel}

				// Construct an instance of the ReplaceOfferingOptions model
				replaceOfferingOptionsModel := new(catalogmanagementv1.ReplaceOfferingOptions)
				replaceOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				replaceOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				replaceOfferingOptionsModel.ID = core.StringPtr("testString")
				replaceOfferingOptionsModel.Rev = core.StringPtr("testString")
				replaceOfferingOptionsModel.URL = core.StringPtr("testString")
				replaceOfferingOptionsModel.CRN = core.StringPtr("testString")
				replaceOfferingOptionsModel.Label = core.StringPtr("testString")
				replaceOfferingOptionsModel.LabelI18n = make(map[string]string)
				replaceOfferingOptionsModel.Name = core.StringPtr("testString")
				replaceOfferingOptionsModel.OfferingIconURL = core.StringPtr("testString")
				replaceOfferingOptionsModel.OfferingDocsURL = core.StringPtr("testString")
				replaceOfferingOptionsModel.OfferingSupportURL = core.StringPtr("testString")
				replaceOfferingOptionsModel.Tags = []string{"testString"}
				replaceOfferingOptionsModel.Keywords = []string{"testString"}
				replaceOfferingOptionsModel.Rating = ratingModel
				replaceOfferingOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				replaceOfferingOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				replaceOfferingOptionsModel.ShortDescription = core.StringPtr("testString")
				replaceOfferingOptionsModel.ShortDescriptionI18n = make(map[string]string)
				replaceOfferingOptionsModel.LongDescription = core.StringPtr("testString")
				replaceOfferingOptionsModel.LongDescriptionI18n = make(map[string]string)
				replaceOfferingOptionsModel.Features = []catalogmanagementv1.Feature{*featureModel}
				replaceOfferingOptionsModel.Kinds = []catalogmanagementv1.Kind{*kindModel}
				replaceOfferingOptionsModel.PcManaged = core.BoolPtr(true)
				replaceOfferingOptionsModel.PublishApproved = core.BoolPtr(true)
				replaceOfferingOptionsModel.ShareWithAll = core.BoolPtr(true)
				replaceOfferingOptionsModel.ShareWithIBM = core.BoolPtr(true)
				replaceOfferingOptionsModel.ShareEnabled = core.BoolPtr(true)
				replaceOfferingOptionsModel.PermitRequestIBMPublicPublish = core.BoolPtr(true)
				replaceOfferingOptionsModel.IBMPublishApproved = core.BoolPtr(true)
				replaceOfferingOptionsModel.PublicPublishApproved = core.BoolPtr(true)
				replaceOfferingOptionsModel.PublicOriginalCRN = core.StringPtr("testString")
				replaceOfferingOptionsModel.PublishPublicCRN = core.StringPtr("testString")
				replaceOfferingOptionsModel.PortalApprovalRecord = core.StringPtr("testString")
				replaceOfferingOptionsModel.PortalUIURL = core.StringPtr("testString")
				replaceOfferingOptionsModel.CatalogID = core.StringPtr("testString")
				replaceOfferingOptionsModel.CatalogName = core.StringPtr("testString")
				replaceOfferingOptionsModel.Metadata = make(map[string]interface{})
				replaceOfferingOptionsModel.Disclaimer = core.StringPtr("testString")
				replaceOfferingOptionsModel.Hidden = core.BoolPtr(true)
				replaceOfferingOptionsModel.Provider = core.StringPtr("testString")
				replaceOfferingOptionsModel.ProviderInfo = providerInfoModel
				replaceOfferingOptionsModel.RepoInfo = repoInfoModel
				replaceOfferingOptionsModel.ImagePullKeys = []catalogmanagementv1.ImagePullKey{*imagePullKeyModel}
				replaceOfferingOptionsModel.Support = supportModel
				replaceOfferingOptionsModel.Media = []catalogmanagementv1.MediaItem{*mediaItemModel}
				replaceOfferingOptionsModel.DeprecatePending = deprecatePendingModel
				replaceOfferingOptionsModel.ProductKind = core.StringPtr("testString")
				replaceOfferingOptionsModel.Badges = []catalogmanagementv1.Badge{*badgeModel}
				replaceOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.ReplaceOffering(replaceOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.ReplaceOffering(replaceOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ReplaceOffering(replaceOfferingOptions *ReplaceOfferingOptions)`, func() {
		replaceOfferingPath := "/catalogs/testString/offerings/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(replaceOfferingPath))
					Expect(req.Method).To(Equal("PUT"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "offering_icon_url": "OfferingIconURL", "offering_docs_url": "OfferingDocsURL", "offering_support_url": "OfferingSupportURL", "tags": ["Tags"], "keywords": ["Keywords"], "rating": {"one_star_count": 12, "two_star_count": 12, "three_star_count": 14, "four_star_count": 13}, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "kinds": [{"id": "ID", "format_kind": "FormatKind", "install_kind": "InstallKind", "target_kind": "TargetKind", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"mapKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"mapKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "version": "Version", "flavors": ["Flavors"]}]}, "is_consumable": true}], "plans": [{"id": "ID", "label": "Label", "name": "Name", "short_description": "ShortDescription", "long_description": "LongDescription", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "deployments": [{"id": "ID", "label": "Label", "name": "Name", "short_description": "ShortDescription", "long_description": "LongDescription", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z"}]}]}], "pc_managed": false, "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "permit_request_ibm_public_publish": false, "ibm_publish_approved": true, "public_publish_approved": false, "public_original_crn": "PublicOriginalCRN", "publish_public_crn": "PublishPublicCRN", "portal_approval_record": "PortalApprovalRecord", "portal_ui_url": "PortalUIURL", "catalog_id": "CatalogID", "catalog_name": "CatalogName", "metadata": {"mapKey": "anyValue"}, "disclaimer": "Disclaimer", "hidden": true, "provider": "Provider", "provider_info": {"id": "ID", "name": "Name"}, "repo_info": {"token": "Token", "type": "Type"}, "image_pull_keys": [{"name": "Name", "value": "Value", "description": "Description"}], "support": {"url": "URL", "process": "Process", "process_i18n": {"mapKey": "Inner"}, "locations": ["Locations"], "support_details": [{"type": "Type", "contact": "Contact", "response_wait_time": {"value": 5, "type": "Type"}, "availability": {"times": [{"day": 3, "start_time": "StartTime", "end_time": "EndTime"}], "timezone": "Timezone", "always_available": false}}], "support_escalation": {"escalation_wait_time": {"value": 5, "type": "Type"}, "response_wait_time": {"value": 5, "type": "Type"}, "contact": "Contact"}, "support_type": "SupportType"}, "media": [{"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}], "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "product_kind": "ProductKind", "badges": [{"id": "ID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}, "icon": "Icon", "authority": "Authority", "tag": "Tag", "learn_more_links": {"first_party": "FirstParty", "third_party": "ThirdParty"}, "constraints": [{"type": "Type", "rule": "anyValue"}]}]}`)
				}))
			})
			It(`Invoke ReplaceOffering successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the Rating model
				ratingModel := new(catalogmanagementv1.Rating)
				ratingModel.OneStarCount = core.Int64Ptr(int64(38))
				ratingModel.TwoStarCount = core.Int64Ptr(int64(38))
				ratingModel.ThreeStarCount = core.Int64Ptr(int64(38))
				ratingModel.FourStarCount = core.Int64Ptr(int64(38))

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = make(map[string]string)
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = make(map[string]string)

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = make(map[string]string)
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the RenderTypeAssociationsParametersItem model
				renderTypeAssociationsParametersItemModel := new(catalogmanagementv1.RenderTypeAssociationsParametersItem)
				renderTypeAssociationsParametersItemModel.Name = core.StringPtr("testString")
				renderTypeAssociationsParametersItemModel.OptionsRefresh = core.BoolPtr(true)

				// Construct an instance of the RenderTypeAssociations model
				renderTypeAssociationsModel := new(catalogmanagementv1.RenderTypeAssociations)
				renderTypeAssociationsModel.Parameters = []catalogmanagementv1.RenderTypeAssociationsParametersItem{*renderTypeAssociationsParametersItemModel}

				// Construct an instance of the RenderType model
				renderTypeModel := new(catalogmanagementv1.RenderType)
				renderTypeModel.Type = core.StringPtr("testString")
				renderTypeModel.Grouping = core.StringPtr("testString")
				renderTypeModel.OriginalGrouping = core.StringPtr("testString")
				renderTypeModel.GroupingIndex = core.Int64Ptr(int64(38))
				renderTypeModel.ConfigConstraints = map[string]interface{}{"anyKey": "anyValue"}
				renderTypeModel.Associations = renderTypeAssociationsModel

				// Construct an instance of the Configuration model
				configurationModel := new(catalogmanagementv1.Configuration)
				configurationModel.Key = core.StringPtr("testString")
				configurationModel.Type = core.StringPtr("testString")
				configurationModel.DefaultValue = core.StringPtr("testString")
				configurationModel.DisplayName = core.StringPtr("testString")
				configurationModel.ValueConstraint = core.StringPtr("testString")
				configurationModel.Description = core.StringPtr("testString")
				configurationModel.Required = core.BoolPtr(true)
				configurationModel.Options = []interface{}{"testString"}
				configurationModel.Hidden = core.BoolPtr(true)
				configurationModel.CustomConfig = renderTypeModel
				configurationModel.TypeMetadata = core.StringPtr("testString")

				// Construct an instance of the Output model
				outputModel := new(catalogmanagementv1.Output)
				outputModel.Key = core.StringPtr("testString")
				outputModel.Description = core.StringPtr("testString")

				// Construct an instance of the IamResource model
				iamResourceModel := new(catalogmanagementv1.IamResource)
				iamResourceModel.Name = core.StringPtr("testString")
				iamResourceModel.Description = core.StringPtr("testString")
				iamResourceModel.RoleCrns = []string{"testString"}

				// Construct an instance of the IamPermission model
				iamPermissionModel := new(catalogmanagementv1.IamPermission)
				iamPermissionModel.ServiceName = core.StringPtr("testString")
				iamPermissionModel.RoleCrns = []string{"testString"}
				iamPermissionModel.Resources = []catalogmanagementv1.IamResource{*iamResourceModel}

				// Construct an instance of the Validation model
				validationModel := new(catalogmanagementv1.Validation)
				validationModel.Validated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.Requested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.State = core.StringPtr("testString")
				validationModel.LastOperation = core.StringPtr("testString")
				validationModel.Target = make(map[string]interface{})
				validationModel.Message = core.StringPtr("testString")

				// Construct an instance of the Resource model
				resourceModel := new(catalogmanagementv1.Resource)
				resourceModel.Type = core.StringPtr("mem")
				resourceModel.Value = core.StringPtr("testString")

				// Construct an instance of the Script model
				scriptModel := new(catalogmanagementv1.Script)
				scriptModel.Instructions = core.StringPtr("testString")
				scriptModel.InstructionsI18n = make(map[string]string)
				scriptModel.Script = core.StringPtr("testString")
				scriptModel.ScriptPermission = core.StringPtr("testString")
				scriptModel.DeleteScript = core.StringPtr("testString")
				scriptModel.Scope = core.StringPtr("testString")

				// Construct an instance of the VersionEntitlement model
				versionEntitlementModel := new(catalogmanagementv1.VersionEntitlement)
				versionEntitlementModel.ProviderName = core.StringPtr("testString")
				versionEntitlementModel.ProviderID = core.StringPtr("testString")
				versionEntitlementModel.ProductID = core.StringPtr("testString")
				versionEntitlementModel.PartNumbers = []string{"testString"}
				versionEntitlementModel.ImageRepoName = core.StringPtr("testString")

				// Construct an instance of the License model
				licenseModel := new(catalogmanagementv1.License)
				licenseModel.ID = core.StringPtr("testString")
				licenseModel.Name = core.StringPtr("testString")
				licenseModel.Type = core.StringPtr("testString")
				licenseModel.URL = core.StringPtr("testString")
				licenseModel.Description = core.StringPtr("testString")

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")

				// Construct an instance of the DeprecatePending model
				deprecatePendingModel := new(catalogmanagementv1.DeprecatePending)
				deprecatePendingModel.DeprecateDate = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				deprecatePendingModel.DeprecateState = core.StringPtr("testString")
				deprecatePendingModel.Description = core.StringPtr("testString")

				// Construct an instance of the URLProxy model
				urlProxyModel := new(catalogmanagementv1.URLProxy)
				urlProxyModel.URL = core.StringPtr("testString")
				urlProxyModel.Sha = core.StringPtr("testString")

				// Construct an instance of the MediaItem model
				mediaItemModel := new(catalogmanagementv1.MediaItem)
				mediaItemModel.URL = core.StringPtr("testString")
				mediaItemModel.APIURL = core.StringPtr("testString")
				mediaItemModel.URLProxy = urlProxyModel
				mediaItemModel.Caption = core.StringPtr("testString")
				mediaItemModel.CaptionI18n = make(map[string]string)
				mediaItemModel.Type = core.StringPtr("testString")
				mediaItemModel.ThumbnailURL = core.StringPtr("testString")

				// Construct an instance of the ArchitectureDiagram model
				architectureDiagramModel := new(catalogmanagementv1.ArchitectureDiagram)
				architectureDiagramModel.Diagram = mediaItemModel
				architectureDiagramModel.Description = core.StringPtr("testString")
				architectureDiagramModel.DescriptionI18n = make(map[string]string)

				// Construct an instance of the CostComponent model
				costComponentModel := new(catalogmanagementv1.CostComponent)
				costComponentModel.Name = core.StringPtr("testString")
				costComponentModel.Unit = core.StringPtr("testString")
				costComponentModel.HourlyQuantity = core.StringPtr("testString")
				costComponentModel.MonthlyQuantity = core.StringPtr("testString")
				costComponentModel.Price = core.StringPtr("testString")
				costComponentModel.HourlyCost = core.StringPtr("testString")
				costComponentModel.MonthlyCost = core.StringPtr("testString")

				// Construct an instance of the CostResource model
				costResourceModel := new(catalogmanagementv1.CostResource)
				costResourceModel.Name = core.StringPtr("testString")
				costResourceModel.Metadata = make(map[string]interface{})
				costResourceModel.HourlyCost = core.StringPtr("testString")
				costResourceModel.MonthlyCost = core.StringPtr("testString")
				costResourceModel.CostComponents = []catalogmanagementv1.CostComponent{*costComponentModel}

				// Construct an instance of the CostBreakdown model
				costBreakdownModel := new(catalogmanagementv1.CostBreakdown)
				costBreakdownModel.TotalHourlyCost = core.StringPtr("testString")
				costBreakdownModel.TotalMonthlyCOst = core.StringPtr("testString")
				costBreakdownModel.Resources = []catalogmanagementv1.CostResource{*costResourceModel}

				// Construct an instance of the CostSummary model
				costSummaryModel := new(catalogmanagementv1.CostSummary)
				costSummaryModel.TotalDetectedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalSupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUnsupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUsageBasedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalNoPriceResources = core.Int64Ptr(int64(38))
				costSummaryModel.UnsupportedResourceCounts = make(map[string]int64)
				costSummaryModel.NoPriceResourceCounts = make(map[string]int64)

				// Construct an instance of the Project model
				projectModel := new(catalogmanagementv1.Project)
				projectModel.Name = core.StringPtr("testString")
				projectModel.Metadata = make(map[string]interface{})
				projectModel.PastBreakdown = costBreakdownModel
				projectModel.Breakdown = costBreakdownModel
				projectModel.Diff = costBreakdownModel
				projectModel.Summary = costSummaryModel

				// Construct an instance of the CostEstimate model
				costEstimateModel := new(catalogmanagementv1.CostEstimate)
				costEstimateModel.Version = core.StringPtr("testString")
				costEstimateModel.Currency = core.StringPtr("testString")
				costEstimateModel.Projects = []catalogmanagementv1.Project{*projectModel}
				costEstimateModel.Summary = costSummaryModel
				costEstimateModel.TotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.TotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.TimeGenerated = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the Dependency model
				dependencyModel := new(catalogmanagementv1.Dependency)
				dependencyModel.CatalogID = core.StringPtr("testString")
				dependencyModel.ID = core.StringPtr("testString")
				dependencyModel.Name = core.StringPtr("testString")
				dependencyModel.Version = core.StringPtr("testString")
				dependencyModel.Flavors = []string{"testString"}

				// Construct an instance of the SolutionInfo model
				solutionInfoModel := new(catalogmanagementv1.SolutionInfo)
				solutionInfoModel.ArchitectureDiagrams = []catalogmanagementv1.ArchitectureDiagram{*architectureDiagramModel}
				solutionInfoModel.Features = []catalogmanagementv1.Feature{*featureModel}
				solutionInfoModel.CostEstimate = costEstimateModel
				solutionInfoModel.Dependencies = []catalogmanagementv1.Dependency{*dependencyModel}

				// Construct an instance of the Version model
				versionModel := new(catalogmanagementv1.Version)
				versionModel.ID = core.StringPtr("testString")
				versionModel.Rev = core.StringPtr("testString")
				versionModel.CRN = core.StringPtr("testString")
				versionModel.Version = core.StringPtr("testString")
				versionModel.Flavor = flavorModel
				versionModel.Sha = core.StringPtr("testString")
				versionModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.OfferingID = core.StringPtr("testString")
				versionModel.CatalogID = core.StringPtr("testString")
				versionModel.KindID = core.StringPtr("testString")
				versionModel.Tags = []string{"testString"}
				versionModel.RepoURL = core.StringPtr("testString")
				versionModel.SourceURL = core.StringPtr("testString")
				versionModel.TgzURL = core.StringPtr("testString")
				versionModel.Configuration = []catalogmanagementv1.Configuration{*configurationModel}
				versionModel.Outputs = []catalogmanagementv1.Output{*outputModel}
				versionModel.IamPermissions = []catalogmanagementv1.IamPermission{*iamPermissionModel}
				versionModel.Metadata = make(map[string]interface{})
				versionModel.Validation = validationModel
				versionModel.RequiredResources = []catalogmanagementv1.Resource{*resourceModel}
				versionModel.SingleInstance = core.BoolPtr(true)
				versionModel.Install = scriptModel
				versionModel.PreInstall = []catalogmanagementv1.Script{*scriptModel}
				versionModel.Entitlement = versionEntitlementModel
				versionModel.Licenses = []catalogmanagementv1.License{*licenseModel}
				versionModel.ImageManifestURL = core.StringPtr("testString")
				versionModel.Deprecated = core.BoolPtr(true)
				versionModel.PackageVersion = core.StringPtr("testString")
				versionModel.State = stateModel
				versionModel.VersionLocator = core.StringPtr("testString")
				versionModel.LongDescription = core.StringPtr("testString")
				versionModel.LongDescriptionI18n = make(map[string]string)
				versionModel.WhitelistedAccounts = []string{"testString"}
				versionModel.ImagePullKeyName = core.StringPtr("testString")
				versionModel.DeprecatePending = deprecatePendingModel
				versionModel.SolutionInfo = solutionInfoModel
				versionModel.IsConsumable = core.BoolPtr(true)

				// Construct an instance of the Deployment model
				deploymentModel := new(catalogmanagementv1.Deployment)
				deploymentModel.ID = core.StringPtr("testString")
				deploymentModel.Label = core.StringPtr("testString")
				deploymentModel.Name = core.StringPtr("testString")
				deploymentModel.ShortDescription = core.StringPtr("testString")
				deploymentModel.LongDescription = core.StringPtr("testString")
				deploymentModel.Metadata = make(map[string]interface{})
				deploymentModel.Tags = []string{"testString"}
				deploymentModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				deploymentModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the Plan model
				planModel := new(catalogmanagementv1.Plan)
				planModel.ID = core.StringPtr("testString")
				planModel.Label = core.StringPtr("testString")
				planModel.Name = core.StringPtr("testString")
				planModel.ShortDescription = core.StringPtr("testString")
				planModel.LongDescription = core.StringPtr("testString")
				planModel.Metadata = make(map[string]interface{})
				planModel.Tags = []string{"testString"}
				planModel.AdditionalFeatures = []catalogmanagementv1.Feature{*featureModel}
				planModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.Deployments = []catalogmanagementv1.Deployment{*deploymentModel}

				// Construct an instance of the Kind model
				kindModel := new(catalogmanagementv1.Kind)
				kindModel.ID = core.StringPtr("testString")
				kindModel.FormatKind = core.StringPtr("testString")
				kindModel.InstallKind = core.StringPtr("testString")
				kindModel.TargetKind = core.StringPtr("testString")
				kindModel.Metadata = make(map[string]interface{})
				kindModel.Tags = []string{"testString"}
				kindModel.AdditionalFeatures = []catalogmanagementv1.Feature{*featureModel}
				kindModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Versions = []catalogmanagementv1.Version{*versionModel}
				kindModel.Plans = []catalogmanagementv1.Plan{*planModel}

				// Construct an instance of the ProviderInfo model
				providerInfoModel := new(catalogmanagementv1.ProviderInfo)
				providerInfoModel.ID = core.StringPtr("testString")
				providerInfoModel.Name = core.StringPtr("testString")

				// Construct an instance of the RepoInfo model
				repoInfoModel := new(catalogmanagementv1.RepoInfo)
				repoInfoModel.Token = core.StringPtr("testString")
				repoInfoModel.Type = core.StringPtr("testString")

				// Construct an instance of the ImagePullKey model
				imagePullKeyModel := new(catalogmanagementv1.ImagePullKey)
				imagePullKeyModel.Name = core.StringPtr("testString")
				imagePullKeyModel.Value = core.StringPtr("testString")
				imagePullKeyModel.Description = core.StringPtr("testString")

				// Construct an instance of the SupportWaitTime model
				supportWaitTimeModel := new(catalogmanagementv1.SupportWaitTime)
				supportWaitTimeModel.Value = core.Int64Ptr(int64(38))
				supportWaitTimeModel.Type = core.StringPtr("testString")

				// Construct an instance of the SupportTime model
				supportTimeModel := new(catalogmanagementv1.SupportTime)
				supportTimeModel.Day = core.Int64Ptr(int64(38))
				supportTimeModel.StartTime = core.StringPtr("testString")
				supportTimeModel.EndTime = core.StringPtr("testString")

				// Construct an instance of the SupportAvailability model
				supportAvailabilityModel := new(catalogmanagementv1.SupportAvailability)
				supportAvailabilityModel.Times = []catalogmanagementv1.SupportTime{*supportTimeModel}
				supportAvailabilityModel.Timezone = core.StringPtr("testString")
				supportAvailabilityModel.AlwaysAvailable = core.BoolPtr(true)

				// Construct an instance of the SupportDetail model
				supportDetailModel := new(catalogmanagementv1.SupportDetail)
				supportDetailModel.Type = core.StringPtr("testString")
				supportDetailModel.Contact = core.StringPtr("testString")
				supportDetailModel.ResponseWaitTime = supportWaitTimeModel
				supportDetailModel.Availability = supportAvailabilityModel

				// Construct an instance of the SupportEscalation model
				supportEscalationModel := new(catalogmanagementv1.SupportEscalation)
				supportEscalationModel.EscalationWaitTime = supportWaitTimeModel
				supportEscalationModel.ResponseWaitTime = supportWaitTimeModel
				supportEscalationModel.Contact = core.StringPtr("testString")

				// Construct an instance of the Support model
				supportModel := new(catalogmanagementv1.Support)
				supportModel.URL = core.StringPtr("testString")
				supportModel.Process = core.StringPtr("testString")
				supportModel.ProcessI18n = make(map[string]string)
				supportModel.Locations = []string{"testString"}
				supportModel.SupportDetails = []catalogmanagementv1.SupportDetail{*supportDetailModel}
				supportModel.SupportEscalation = supportEscalationModel
				supportModel.SupportType = core.StringPtr("testString")

				// Construct an instance of the LearnMoreLinks model
				learnMoreLinksModel := new(catalogmanagementv1.LearnMoreLinks)
				learnMoreLinksModel.FirstParty = core.StringPtr("testString")
				learnMoreLinksModel.ThirdParty = core.StringPtr("testString")

				// Construct an instance of the Constraint model
				constraintModel := new(catalogmanagementv1.Constraint)
				constraintModel.Type = core.StringPtr("testString")
				constraintModel.Rule = core.StringPtr("testString")

				// Construct an instance of the Badge model
				badgeModel := new(catalogmanagementv1.Badge)
				badgeModel.ID = core.StringPtr("testString")
				badgeModel.Label = core.StringPtr("testString")
				badgeModel.LabelI18n = make(map[string]string)
				badgeModel.Description = core.StringPtr("testString")
				badgeModel.DescriptionI18n = make(map[string]string)
				badgeModel.Icon = core.StringPtr("testString")
				badgeModel.Authority = core.StringPtr("testString")
				badgeModel.Tag = core.StringPtr("testString")
				badgeModel.LearnMoreLinks = learnMoreLinksModel
				badgeModel.Constraints = []catalogmanagementv1.Constraint{*constraintModel}

				// Construct an instance of the ReplaceOfferingOptions model
				replaceOfferingOptionsModel := new(catalogmanagementv1.ReplaceOfferingOptions)
				replaceOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				replaceOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				replaceOfferingOptionsModel.ID = core.StringPtr("testString")
				replaceOfferingOptionsModel.Rev = core.StringPtr("testString")
				replaceOfferingOptionsModel.URL = core.StringPtr("testString")
				replaceOfferingOptionsModel.CRN = core.StringPtr("testString")
				replaceOfferingOptionsModel.Label = core.StringPtr("testString")
				replaceOfferingOptionsModel.LabelI18n = make(map[string]string)
				replaceOfferingOptionsModel.Name = core.StringPtr("testString")
				replaceOfferingOptionsModel.OfferingIconURL = core.StringPtr("testString")
				replaceOfferingOptionsModel.OfferingDocsURL = core.StringPtr("testString")
				replaceOfferingOptionsModel.OfferingSupportURL = core.StringPtr("testString")
				replaceOfferingOptionsModel.Tags = []string{"testString"}
				replaceOfferingOptionsModel.Keywords = []string{"testString"}
				replaceOfferingOptionsModel.Rating = ratingModel
				replaceOfferingOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				replaceOfferingOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				replaceOfferingOptionsModel.ShortDescription = core.StringPtr("testString")
				replaceOfferingOptionsModel.ShortDescriptionI18n = make(map[string]string)
				replaceOfferingOptionsModel.LongDescription = core.StringPtr("testString")
				replaceOfferingOptionsModel.LongDescriptionI18n = make(map[string]string)
				replaceOfferingOptionsModel.Features = []catalogmanagementv1.Feature{*featureModel}
				replaceOfferingOptionsModel.Kinds = []catalogmanagementv1.Kind{*kindModel}
				replaceOfferingOptionsModel.PcManaged = core.BoolPtr(true)
				replaceOfferingOptionsModel.PublishApproved = core.BoolPtr(true)
				replaceOfferingOptionsModel.ShareWithAll = core.BoolPtr(true)
				replaceOfferingOptionsModel.ShareWithIBM = core.BoolPtr(true)
				replaceOfferingOptionsModel.ShareEnabled = core.BoolPtr(true)
				replaceOfferingOptionsModel.PermitRequestIBMPublicPublish = core.BoolPtr(true)
				replaceOfferingOptionsModel.IBMPublishApproved = core.BoolPtr(true)
				replaceOfferingOptionsModel.PublicPublishApproved = core.BoolPtr(true)
				replaceOfferingOptionsModel.PublicOriginalCRN = core.StringPtr("testString")
				replaceOfferingOptionsModel.PublishPublicCRN = core.StringPtr("testString")
				replaceOfferingOptionsModel.PortalApprovalRecord = core.StringPtr("testString")
				replaceOfferingOptionsModel.PortalUIURL = core.StringPtr("testString")
				replaceOfferingOptionsModel.CatalogID = core.StringPtr("testString")
				replaceOfferingOptionsModel.CatalogName = core.StringPtr("testString")
				replaceOfferingOptionsModel.Metadata = make(map[string]interface{})
				replaceOfferingOptionsModel.Disclaimer = core.StringPtr("testString")
				replaceOfferingOptionsModel.Hidden = core.BoolPtr(true)
				replaceOfferingOptionsModel.Provider = core.StringPtr("testString")
				replaceOfferingOptionsModel.ProviderInfo = providerInfoModel
				replaceOfferingOptionsModel.RepoInfo = repoInfoModel
				replaceOfferingOptionsModel.ImagePullKeys = []catalogmanagementv1.ImagePullKey{*imagePullKeyModel}
				replaceOfferingOptionsModel.Support = supportModel
				replaceOfferingOptionsModel.Media = []catalogmanagementv1.MediaItem{*mediaItemModel}
				replaceOfferingOptionsModel.DeprecatePending = deprecatePendingModel
				replaceOfferingOptionsModel.ProductKind = core.StringPtr("testString")
				replaceOfferingOptionsModel.Badges = []catalogmanagementv1.Badge{*badgeModel}
				replaceOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.ReplaceOfferingWithContext(ctx, replaceOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.ReplaceOffering(replaceOfferingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.ReplaceOfferingWithContext(ctx, replaceOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(replaceOfferingPath))
					Expect(req.Method).To(Equal("PUT"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "offering_icon_url": "OfferingIconURL", "offering_docs_url": "OfferingDocsURL", "offering_support_url": "OfferingSupportURL", "tags": ["Tags"], "keywords": ["Keywords"], "rating": {"one_star_count": 12, "two_star_count": 12, "three_star_count": 14, "four_star_count": 13}, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "kinds": [{"id": "ID", "format_kind": "FormatKind", "install_kind": "InstallKind", "target_kind": "TargetKind", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"mapKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"mapKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "version": "Version", "flavors": ["Flavors"]}]}, "is_consumable": true}], "plans": [{"id": "ID", "label": "Label", "name": "Name", "short_description": "ShortDescription", "long_description": "LongDescription", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "deployments": [{"id": "ID", "label": "Label", "name": "Name", "short_description": "ShortDescription", "long_description": "LongDescription", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z"}]}]}], "pc_managed": false, "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "permit_request_ibm_public_publish": false, "ibm_publish_approved": true, "public_publish_approved": false, "public_original_crn": "PublicOriginalCRN", "publish_public_crn": "PublishPublicCRN", "portal_approval_record": "PortalApprovalRecord", "portal_ui_url": "PortalUIURL", "catalog_id": "CatalogID", "catalog_name": "CatalogName", "metadata": {"mapKey": "anyValue"}, "disclaimer": "Disclaimer", "hidden": true, "provider": "Provider", "provider_info": {"id": "ID", "name": "Name"}, "repo_info": {"token": "Token", "type": "Type"}, "image_pull_keys": [{"name": "Name", "value": "Value", "description": "Description"}], "support": {"url": "URL", "process": "Process", "process_i18n": {"mapKey": "Inner"}, "locations": ["Locations"], "support_details": [{"type": "Type", "contact": "Contact", "response_wait_time": {"value": 5, "type": "Type"}, "availability": {"times": [{"day": 3, "start_time": "StartTime", "end_time": "EndTime"}], "timezone": "Timezone", "always_available": false}}], "support_escalation": {"escalation_wait_time": {"value": 5, "type": "Type"}, "response_wait_time": {"value": 5, "type": "Type"}, "contact": "Contact"}, "support_type": "SupportType"}, "media": [{"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}], "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "product_kind": "ProductKind", "badges": [{"id": "ID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}, "icon": "Icon", "authority": "Authority", "tag": "Tag", "learn_more_links": {"first_party": "FirstParty", "third_party": "ThirdParty"}, "constraints": [{"type": "Type", "rule": "anyValue"}]}]}`)
				}))
			})
			It(`Invoke ReplaceOffering successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.ReplaceOffering(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the Rating model
				ratingModel := new(catalogmanagementv1.Rating)
				ratingModel.OneStarCount = core.Int64Ptr(int64(38))
				ratingModel.TwoStarCount = core.Int64Ptr(int64(38))
				ratingModel.ThreeStarCount = core.Int64Ptr(int64(38))
				ratingModel.FourStarCount = core.Int64Ptr(int64(38))

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = make(map[string]string)
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = make(map[string]string)

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = make(map[string]string)
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the RenderTypeAssociationsParametersItem model
				renderTypeAssociationsParametersItemModel := new(catalogmanagementv1.RenderTypeAssociationsParametersItem)
				renderTypeAssociationsParametersItemModel.Name = core.StringPtr("testString")
				renderTypeAssociationsParametersItemModel.OptionsRefresh = core.BoolPtr(true)

				// Construct an instance of the RenderTypeAssociations model
				renderTypeAssociationsModel := new(catalogmanagementv1.RenderTypeAssociations)
				renderTypeAssociationsModel.Parameters = []catalogmanagementv1.RenderTypeAssociationsParametersItem{*renderTypeAssociationsParametersItemModel}

				// Construct an instance of the RenderType model
				renderTypeModel := new(catalogmanagementv1.RenderType)
				renderTypeModel.Type = core.StringPtr("testString")
				renderTypeModel.Grouping = core.StringPtr("testString")
				renderTypeModel.OriginalGrouping = core.StringPtr("testString")
				renderTypeModel.GroupingIndex = core.Int64Ptr(int64(38))
				renderTypeModel.ConfigConstraints = map[string]interface{}{"anyKey": "anyValue"}
				renderTypeModel.Associations = renderTypeAssociationsModel

				// Construct an instance of the Configuration model
				configurationModel := new(catalogmanagementv1.Configuration)
				configurationModel.Key = core.StringPtr("testString")
				configurationModel.Type = core.StringPtr("testString")
				configurationModel.DefaultValue = core.StringPtr("testString")
				configurationModel.DisplayName = core.StringPtr("testString")
				configurationModel.ValueConstraint = core.StringPtr("testString")
				configurationModel.Description = core.StringPtr("testString")
				configurationModel.Required = core.BoolPtr(true)
				configurationModel.Options = []interface{}{"testString"}
				configurationModel.Hidden = core.BoolPtr(true)
				configurationModel.CustomConfig = renderTypeModel
				configurationModel.TypeMetadata = core.StringPtr("testString")

				// Construct an instance of the Output model
				outputModel := new(catalogmanagementv1.Output)
				outputModel.Key = core.StringPtr("testString")
				outputModel.Description = core.StringPtr("testString")

				// Construct an instance of the IamResource model
				iamResourceModel := new(catalogmanagementv1.IamResource)
				iamResourceModel.Name = core.StringPtr("testString")
				iamResourceModel.Description = core.StringPtr("testString")
				iamResourceModel.RoleCrns = []string{"testString"}

				// Construct an instance of the IamPermission model
				iamPermissionModel := new(catalogmanagementv1.IamPermission)
				iamPermissionModel.ServiceName = core.StringPtr("testString")
				iamPermissionModel.RoleCrns = []string{"testString"}
				iamPermissionModel.Resources = []catalogmanagementv1.IamResource{*iamResourceModel}

				// Construct an instance of the Validation model
				validationModel := new(catalogmanagementv1.Validation)
				validationModel.Validated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.Requested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.State = core.StringPtr("testString")
				validationModel.LastOperation = core.StringPtr("testString")
				validationModel.Target = make(map[string]interface{})
				validationModel.Message = core.StringPtr("testString")

				// Construct an instance of the Resource model
				resourceModel := new(catalogmanagementv1.Resource)
				resourceModel.Type = core.StringPtr("mem")
				resourceModel.Value = core.StringPtr("testString")

				// Construct an instance of the Script model
				scriptModel := new(catalogmanagementv1.Script)
				scriptModel.Instructions = core.StringPtr("testString")
				scriptModel.InstructionsI18n = make(map[string]string)
				scriptModel.Script = core.StringPtr("testString")
				scriptModel.ScriptPermission = core.StringPtr("testString")
				scriptModel.DeleteScript = core.StringPtr("testString")
				scriptModel.Scope = core.StringPtr("testString")

				// Construct an instance of the VersionEntitlement model
				versionEntitlementModel := new(catalogmanagementv1.VersionEntitlement)
				versionEntitlementModel.ProviderName = core.StringPtr("testString")
				versionEntitlementModel.ProviderID = core.StringPtr("testString")
				versionEntitlementModel.ProductID = core.StringPtr("testString")
				versionEntitlementModel.PartNumbers = []string{"testString"}
				versionEntitlementModel.ImageRepoName = core.StringPtr("testString")

				// Construct an instance of the License model
				licenseModel := new(catalogmanagementv1.License)
				licenseModel.ID = core.StringPtr("testString")
				licenseModel.Name = core.StringPtr("testString")
				licenseModel.Type = core.StringPtr("testString")
				licenseModel.URL = core.StringPtr("testString")
				licenseModel.Description = core.StringPtr("testString")

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")

				// Construct an instance of the DeprecatePending model
				deprecatePendingModel := new(catalogmanagementv1.DeprecatePending)
				deprecatePendingModel.DeprecateDate = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				deprecatePendingModel.DeprecateState = core.StringPtr("testString")
				deprecatePendingModel.Description = core.StringPtr("testString")

				// Construct an instance of the URLProxy model
				urlProxyModel := new(catalogmanagementv1.URLProxy)
				urlProxyModel.URL = core.StringPtr("testString")
				urlProxyModel.Sha = core.StringPtr("testString")

				// Construct an instance of the MediaItem model
				mediaItemModel := new(catalogmanagementv1.MediaItem)
				mediaItemModel.URL = core.StringPtr("testString")
				mediaItemModel.APIURL = core.StringPtr("testString")
				mediaItemModel.URLProxy = urlProxyModel
				mediaItemModel.Caption = core.StringPtr("testString")
				mediaItemModel.CaptionI18n = make(map[string]string)
				mediaItemModel.Type = core.StringPtr("testString")
				mediaItemModel.ThumbnailURL = core.StringPtr("testString")

				// Construct an instance of the ArchitectureDiagram model
				architectureDiagramModel := new(catalogmanagementv1.ArchitectureDiagram)
				architectureDiagramModel.Diagram = mediaItemModel
				architectureDiagramModel.Description = core.StringPtr("testString")
				architectureDiagramModel.DescriptionI18n = make(map[string]string)

				// Construct an instance of the CostComponent model
				costComponentModel := new(catalogmanagementv1.CostComponent)
				costComponentModel.Name = core.StringPtr("testString")
				costComponentModel.Unit = core.StringPtr("testString")
				costComponentModel.HourlyQuantity = core.StringPtr("testString")
				costComponentModel.MonthlyQuantity = core.StringPtr("testString")
				costComponentModel.Price = core.StringPtr("testString")
				costComponentModel.HourlyCost = core.StringPtr("testString")
				costComponentModel.MonthlyCost = core.StringPtr("testString")

				// Construct an instance of the CostResource model
				costResourceModel := new(catalogmanagementv1.CostResource)
				costResourceModel.Name = core.StringPtr("testString")
				costResourceModel.Metadata = make(map[string]interface{})
				costResourceModel.HourlyCost = core.StringPtr("testString")
				costResourceModel.MonthlyCost = core.StringPtr("testString")
				costResourceModel.CostComponents = []catalogmanagementv1.CostComponent{*costComponentModel}

				// Construct an instance of the CostBreakdown model
				costBreakdownModel := new(catalogmanagementv1.CostBreakdown)
				costBreakdownModel.TotalHourlyCost = core.StringPtr("testString")
				costBreakdownModel.TotalMonthlyCOst = core.StringPtr("testString")
				costBreakdownModel.Resources = []catalogmanagementv1.CostResource{*costResourceModel}

				// Construct an instance of the CostSummary model
				costSummaryModel := new(catalogmanagementv1.CostSummary)
				costSummaryModel.TotalDetectedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalSupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUnsupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUsageBasedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalNoPriceResources = core.Int64Ptr(int64(38))
				costSummaryModel.UnsupportedResourceCounts = make(map[string]int64)
				costSummaryModel.NoPriceResourceCounts = make(map[string]int64)

				// Construct an instance of the Project model
				projectModel := new(catalogmanagementv1.Project)
				projectModel.Name = core.StringPtr("testString")
				projectModel.Metadata = make(map[string]interface{})
				projectModel.PastBreakdown = costBreakdownModel
				projectModel.Breakdown = costBreakdownModel
				projectModel.Diff = costBreakdownModel
				projectModel.Summary = costSummaryModel

				// Construct an instance of the CostEstimate model
				costEstimateModel := new(catalogmanagementv1.CostEstimate)
				costEstimateModel.Version = core.StringPtr("testString")
				costEstimateModel.Currency = core.StringPtr("testString")
				costEstimateModel.Projects = []catalogmanagementv1.Project{*projectModel}
				costEstimateModel.Summary = costSummaryModel
				costEstimateModel.TotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.TotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.TimeGenerated = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the Dependency model
				dependencyModel := new(catalogmanagementv1.Dependency)
				dependencyModel.CatalogID = core.StringPtr("testString")
				dependencyModel.ID = core.StringPtr("testString")
				dependencyModel.Name = core.StringPtr("testString")
				dependencyModel.Version = core.StringPtr("testString")
				dependencyModel.Flavors = []string{"testString"}

				// Construct an instance of the SolutionInfo model
				solutionInfoModel := new(catalogmanagementv1.SolutionInfo)
				solutionInfoModel.ArchitectureDiagrams = []catalogmanagementv1.ArchitectureDiagram{*architectureDiagramModel}
				solutionInfoModel.Features = []catalogmanagementv1.Feature{*featureModel}
				solutionInfoModel.CostEstimate = costEstimateModel
				solutionInfoModel.Dependencies = []catalogmanagementv1.Dependency{*dependencyModel}

				// Construct an instance of the Version model
				versionModel := new(catalogmanagementv1.Version)
				versionModel.ID = core.StringPtr("testString")
				versionModel.Rev = core.StringPtr("testString")
				versionModel.CRN = core.StringPtr("testString")
				versionModel.Version = core.StringPtr("testString")
				versionModel.Flavor = flavorModel
				versionModel.Sha = core.StringPtr("testString")
				versionModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.OfferingID = core.StringPtr("testString")
				versionModel.CatalogID = core.StringPtr("testString")
				versionModel.KindID = core.StringPtr("testString")
				versionModel.Tags = []string{"testString"}
				versionModel.RepoURL = core.StringPtr("testString")
				versionModel.SourceURL = core.StringPtr("testString")
				versionModel.TgzURL = core.StringPtr("testString")
				versionModel.Configuration = []catalogmanagementv1.Configuration{*configurationModel}
				versionModel.Outputs = []catalogmanagementv1.Output{*outputModel}
				versionModel.IamPermissions = []catalogmanagementv1.IamPermission{*iamPermissionModel}
				versionModel.Metadata = make(map[string]interface{})
				versionModel.Validation = validationModel
				versionModel.RequiredResources = []catalogmanagementv1.Resource{*resourceModel}
				versionModel.SingleInstance = core.BoolPtr(true)
				versionModel.Install = scriptModel
				versionModel.PreInstall = []catalogmanagementv1.Script{*scriptModel}
				versionModel.Entitlement = versionEntitlementModel
				versionModel.Licenses = []catalogmanagementv1.License{*licenseModel}
				versionModel.ImageManifestURL = core.StringPtr("testString")
				versionModel.Deprecated = core.BoolPtr(true)
				versionModel.PackageVersion = core.StringPtr("testString")
				versionModel.State = stateModel
				versionModel.VersionLocator = core.StringPtr("testString")
				versionModel.LongDescription = core.StringPtr("testString")
				versionModel.LongDescriptionI18n = make(map[string]string)
				versionModel.WhitelistedAccounts = []string{"testString"}
				versionModel.ImagePullKeyName = core.StringPtr("testString")
				versionModel.DeprecatePending = deprecatePendingModel
				versionModel.SolutionInfo = solutionInfoModel
				versionModel.IsConsumable = core.BoolPtr(true)

				// Construct an instance of the Deployment model
				deploymentModel := new(catalogmanagementv1.Deployment)
				deploymentModel.ID = core.StringPtr("testString")
				deploymentModel.Label = core.StringPtr("testString")
				deploymentModel.Name = core.StringPtr("testString")
				deploymentModel.ShortDescription = core.StringPtr("testString")
				deploymentModel.LongDescription = core.StringPtr("testString")
				deploymentModel.Metadata = make(map[string]interface{})
				deploymentModel.Tags = []string{"testString"}
				deploymentModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				deploymentModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the Plan model
				planModel := new(catalogmanagementv1.Plan)
				planModel.ID = core.StringPtr("testString")
				planModel.Label = core.StringPtr("testString")
				planModel.Name = core.StringPtr("testString")
				planModel.ShortDescription = core.StringPtr("testString")
				planModel.LongDescription = core.StringPtr("testString")
				planModel.Metadata = make(map[string]interface{})
				planModel.Tags = []string{"testString"}
				planModel.AdditionalFeatures = []catalogmanagementv1.Feature{*featureModel}
				planModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.Deployments = []catalogmanagementv1.Deployment{*deploymentModel}

				// Construct an instance of the Kind model
				kindModel := new(catalogmanagementv1.Kind)
				kindModel.ID = core.StringPtr("testString")
				kindModel.FormatKind = core.StringPtr("testString")
				kindModel.InstallKind = core.StringPtr("testString")
				kindModel.TargetKind = core.StringPtr("testString")
				kindModel.Metadata = make(map[string]interface{})
				kindModel.Tags = []string{"testString"}
				kindModel.AdditionalFeatures = []catalogmanagementv1.Feature{*featureModel}
				kindModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Versions = []catalogmanagementv1.Version{*versionModel}
				kindModel.Plans = []catalogmanagementv1.Plan{*planModel}

				// Construct an instance of the ProviderInfo model
				providerInfoModel := new(catalogmanagementv1.ProviderInfo)
				providerInfoModel.ID = core.StringPtr("testString")
				providerInfoModel.Name = core.StringPtr("testString")

				// Construct an instance of the RepoInfo model
				repoInfoModel := new(catalogmanagementv1.RepoInfo)
				repoInfoModel.Token = core.StringPtr("testString")
				repoInfoModel.Type = core.StringPtr("testString")

				// Construct an instance of the ImagePullKey model
				imagePullKeyModel := new(catalogmanagementv1.ImagePullKey)
				imagePullKeyModel.Name = core.StringPtr("testString")
				imagePullKeyModel.Value = core.StringPtr("testString")
				imagePullKeyModel.Description = core.StringPtr("testString")

				// Construct an instance of the SupportWaitTime model
				supportWaitTimeModel := new(catalogmanagementv1.SupportWaitTime)
				supportWaitTimeModel.Value = core.Int64Ptr(int64(38))
				supportWaitTimeModel.Type = core.StringPtr("testString")

				// Construct an instance of the SupportTime model
				supportTimeModel := new(catalogmanagementv1.SupportTime)
				supportTimeModel.Day = core.Int64Ptr(int64(38))
				supportTimeModel.StartTime = core.StringPtr("testString")
				supportTimeModel.EndTime = core.StringPtr("testString")

				// Construct an instance of the SupportAvailability model
				supportAvailabilityModel := new(catalogmanagementv1.SupportAvailability)
				supportAvailabilityModel.Times = []catalogmanagementv1.SupportTime{*supportTimeModel}
				supportAvailabilityModel.Timezone = core.StringPtr("testString")
				supportAvailabilityModel.AlwaysAvailable = core.BoolPtr(true)

				// Construct an instance of the SupportDetail model
				supportDetailModel := new(catalogmanagementv1.SupportDetail)
				supportDetailModel.Type = core.StringPtr("testString")
				supportDetailModel.Contact = core.StringPtr("testString")
				supportDetailModel.ResponseWaitTime = supportWaitTimeModel
				supportDetailModel.Availability = supportAvailabilityModel

				// Construct an instance of the SupportEscalation model
				supportEscalationModel := new(catalogmanagementv1.SupportEscalation)
				supportEscalationModel.EscalationWaitTime = supportWaitTimeModel
				supportEscalationModel.ResponseWaitTime = supportWaitTimeModel
				supportEscalationModel.Contact = core.StringPtr("testString")

				// Construct an instance of the Support model
				supportModel := new(catalogmanagementv1.Support)
				supportModel.URL = core.StringPtr("testString")
				supportModel.Process = core.StringPtr("testString")
				supportModel.ProcessI18n = make(map[string]string)
				supportModel.Locations = []string{"testString"}
				supportModel.SupportDetails = []catalogmanagementv1.SupportDetail{*supportDetailModel}
				supportModel.SupportEscalation = supportEscalationModel
				supportModel.SupportType = core.StringPtr("testString")

				// Construct an instance of the LearnMoreLinks model
				learnMoreLinksModel := new(catalogmanagementv1.LearnMoreLinks)
				learnMoreLinksModel.FirstParty = core.StringPtr("testString")
				learnMoreLinksModel.ThirdParty = core.StringPtr("testString")

				// Construct an instance of the Constraint model
				constraintModel := new(catalogmanagementv1.Constraint)
				constraintModel.Type = core.StringPtr("testString")
				constraintModel.Rule = core.StringPtr("testString")

				// Construct an instance of the Badge model
				badgeModel := new(catalogmanagementv1.Badge)
				badgeModel.ID = core.StringPtr("testString")
				badgeModel.Label = core.StringPtr("testString")
				badgeModel.LabelI18n = make(map[string]string)
				badgeModel.Description = core.StringPtr("testString")
				badgeModel.DescriptionI18n = make(map[string]string)
				badgeModel.Icon = core.StringPtr("testString")
				badgeModel.Authority = core.StringPtr("testString")
				badgeModel.Tag = core.StringPtr("testString")
				badgeModel.LearnMoreLinks = learnMoreLinksModel
				badgeModel.Constraints = []catalogmanagementv1.Constraint{*constraintModel}

				// Construct an instance of the ReplaceOfferingOptions model
				replaceOfferingOptionsModel := new(catalogmanagementv1.ReplaceOfferingOptions)
				replaceOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				replaceOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				replaceOfferingOptionsModel.ID = core.StringPtr("testString")
				replaceOfferingOptionsModel.Rev = core.StringPtr("testString")
				replaceOfferingOptionsModel.URL = core.StringPtr("testString")
				replaceOfferingOptionsModel.CRN = core.StringPtr("testString")
				replaceOfferingOptionsModel.Label = core.StringPtr("testString")
				replaceOfferingOptionsModel.LabelI18n = make(map[string]string)
				replaceOfferingOptionsModel.Name = core.StringPtr("testString")
				replaceOfferingOptionsModel.OfferingIconURL = core.StringPtr("testString")
				replaceOfferingOptionsModel.OfferingDocsURL = core.StringPtr("testString")
				replaceOfferingOptionsModel.OfferingSupportURL = core.StringPtr("testString")
				replaceOfferingOptionsModel.Tags = []string{"testString"}
				replaceOfferingOptionsModel.Keywords = []string{"testString"}
				replaceOfferingOptionsModel.Rating = ratingModel
				replaceOfferingOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				replaceOfferingOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				replaceOfferingOptionsModel.ShortDescription = core.StringPtr("testString")
				replaceOfferingOptionsModel.ShortDescriptionI18n = make(map[string]string)
				replaceOfferingOptionsModel.LongDescription = core.StringPtr("testString")
				replaceOfferingOptionsModel.LongDescriptionI18n = make(map[string]string)
				replaceOfferingOptionsModel.Features = []catalogmanagementv1.Feature{*featureModel}
				replaceOfferingOptionsModel.Kinds = []catalogmanagementv1.Kind{*kindModel}
				replaceOfferingOptionsModel.PcManaged = core.BoolPtr(true)
				replaceOfferingOptionsModel.PublishApproved = core.BoolPtr(true)
				replaceOfferingOptionsModel.ShareWithAll = core.BoolPtr(true)
				replaceOfferingOptionsModel.ShareWithIBM = core.BoolPtr(true)
				replaceOfferingOptionsModel.ShareEnabled = core.BoolPtr(true)
				replaceOfferingOptionsModel.PermitRequestIBMPublicPublish = core.BoolPtr(true)
				replaceOfferingOptionsModel.IBMPublishApproved = core.BoolPtr(true)
				replaceOfferingOptionsModel.PublicPublishApproved = core.BoolPtr(true)
				replaceOfferingOptionsModel.PublicOriginalCRN = core.StringPtr("testString")
				replaceOfferingOptionsModel.PublishPublicCRN = core.StringPtr("testString")
				replaceOfferingOptionsModel.PortalApprovalRecord = core.StringPtr("testString")
				replaceOfferingOptionsModel.PortalUIURL = core.StringPtr("testString")
				replaceOfferingOptionsModel.CatalogID = core.StringPtr("testString")
				replaceOfferingOptionsModel.CatalogName = core.StringPtr("testString")
				replaceOfferingOptionsModel.Metadata = make(map[string]interface{})
				replaceOfferingOptionsModel.Disclaimer = core.StringPtr("testString")
				replaceOfferingOptionsModel.Hidden = core.BoolPtr(true)
				replaceOfferingOptionsModel.Provider = core.StringPtr("testString")
				replaceOfferingOptionsModel.ProviderInfo = providerInfoModel
				replaceOfferingOptionsModel.RepoInfo = repoInfoModel
				replaceOfferingOptionsModel.ImagePullKeys = []catalogmanagementv1.ImagePullKey{*imagePullKeyModel}
				replaceOfferingOptionsModel.Support = supportModel
				replaceOfferingOptionsModel.Media = []catalogmanagementv1.MediaItem{*mediaItemModel}
				replaceOfferingOptionsModel.DeprecatePending = deprecatePendingModel
				replaceOfferingOptionsModel.ProductKind = core.StringPtr("testString")
				replaceOfferingOptionsModel.Badges = []catalogmanagementv1.Badge{*badgeModel}
				replaceOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.ReplaceOffering(replaceOfferingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ReplaceOffering with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Rating model
				ratingModel := new(catalogmanagementv1.Rating)
				ratingModel.OneStarCount = core.Int64Ptr(int64(38))
				ratingModel.TwoStarCount = core.Int64Ptr(int64(38))
				ratingModel.ThreeStarCount = core.Int64Ptr(int64(38))
				ratingModel.FourStarCount = core.Int64Ptr(int64(38))

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = make(map[string]string)
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = make(map[string]string)

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = make(map[string]string)
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the RenderTypeAssociationsParametersItem model
				renderTypeAssociationsParametersItemModel := new(catalogmanagementv1.RenderTypeAssociationsParametersItem)
				renderTypeAssociationsParametersItemModel.Name = core.StringPtr("testString")
				renderTypeAssociationsParametersItemModel.OptionsRefresh = core.BoolPtr(true)

				// Construct an instance of the RenderTypeAssociations model
				renderTypeAssociationsModel := new(catalogmanagementv1.RenderTypeAssociations)
				renderTypeAssociationsModel.Parameters = []catalogmanagementv1.RenderTypeAssociationsParametersItem{*renderTypeAssociationsParametersItemModel}

				// Construct an instance of the RenderType model
				renderTypeModel := new(catalogmanagementv1.RenderType)
				renderTypeModel.Type = core.StringPtr("testString")
				renderTypeModel.Grouping = core.StringPtr("testString")
				renderTypeModel.OriginalGrouping = core.StringPtr("testString")
				renderTypeModel.GroupingIndex = core.Int64Ptr(int64(38))
				renderTypeModel.ConfigConstraints = map[string]interface{}{"anyKey": "anyValue"}
				renderTypeModel.Associations = renderTypeAssociationsModel

				// Construct an instance of the Configuration model
				configurationModel := new(catalogmanagementv1.Configuration)
				configurationModel.Key = core.StringPtr("testString")
				configurationModel.Type = core.StringPtr("testString")
				configurationModel.DefaultValue = core.StringPtr("testString")
				configurationModel.DisplayName = core.StringPtr("testString")
				configurationModel.ValueConstraint = core.StringPtr("testString")
				configurationModel.Description = core.StringPtr("testString")
				configurationModel.Required = core.BoolPtr(true)
				configurationModel.Options = []interface{}{"testString"}
				configurationModel.Hidden = core.BoolPtr(true)
				configurationModel.CustomConfig = renderTypeModel
				configurationModel.TypeMetadata = core.StringPtr("testString")

				// Construct an instance of the Output model
				outputModel := new(catalogmanagementv1.Output)
				outputModel.Key = core.StringPtr("testString")
				outputModel.Description = core.StringPtr("testString")

				// Construct an instance of the IamResource model
				iamResourceModel := new(catalogmanagementv1.IamResource)
				iamResourceModel.Name = core.StringPtr("testString")
				iamResourceModel.Description = core.StringPtr("testString")
				iamResourceModel.RoleCrns = []string{"testString"}

				// Construct an instance of the IamPermission model
				iamPermissionModel := new(catalogmanagementv1.IamPermission)
				iamPermissionModel.ServiceName = core.StringPtr("testString")
				iamPermissionModel.RoleCrns = []string{"testString"}
				iamPermissionModel.Resources = []catalogmanagementv1.IamResource{*iamResourceModel}

				// Construct an instance of the Validation model
				validationModel := new(catalogmanagementv1.Validation)
				validationModel.Validated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.Requested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.State = core.StringPtr("testString")
				validationModel.LastOperation = core.StringPtr("testString")
				validationModel.Target = make(map[string]interface{})
				validationModel.Message = core.StringPtr("testString")

				// Construct an instance of the Resource model
				resourceModel := new(catalogmanagementv1.Resource)
				resourceModel.Type = core.StringPtr("mem")
				resourceModel.Value = core.StringPtr("testString")

				// Construct an instance of the Script model
				scriptModel := new(catalogmanagementv1.Script)
				scriptModel.Instructions = core.StringPtr("testString")
				scriptModel.InstructionsI18n = make(map[string]string)
				scriptModel.Script = core.StringPtr("testString")
				scriptModel.ScriptPermission = core.StringPtr("testString")
				scriptModel.DeleteScript = core.StringPtr("testString")
				scriptModel.Scope = core.StringPtr("testString")

				// Construct an instance of the VersionEntitlement model
				versionEntitlementModel := new(catalogmanagementv1.VersionEntitlement)
				versionEntitlementModel.ProviderName = core.StringPtr("testString")
				versionEntitlementModel.ProviderID = core.StringPtr("testString")
				versionEntitlementModel.ProductID = core.StringPtr("testString")
				versionEntitlementModel.PartNumbers = []string{"testString"}
				versionEntitlementModel.ImageRepoName = core.StringPtr("testString")

				// Construct an instance of the License model
				licenseModel := new(catalogmanagementv1.License)
				licenseModel.ID = core.StringPtr("testString")
				licenseModel.Name = core.StringPtr("testString")
				licenseModel.Type = core.StringPtr("testString")
				licenseModel.URL = core.StringPtr("testString")
				licenseModel.Description = core.StringPtr("testString")

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")

				// Construct an instance of the DeprecatePending model
				deprecatePendingModel := new(catalogmanagementv1.DeprecatePending)
				deprecatePendingModel.DeprecateDate = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				deprecatePendingModel.DeprecateState = core.StringPtr("testString")
				deprecatePendingModel.Description = core.StringPtr("testString")

				// Construct an instance of the URLProxy model
				urlProxyModel := new(catalogmanagementv1.URLProxy)
				urlProxyModel.URL = core.StringPtr("testString")
				urlProxyModel.Sha = core.StringPtr("testString")

				// Construct an instance of the MediaItem model
				mediaItemModel := new(catalogmanagementv1.MediaItem)
				mediaItemModel.URL = core.StringPtr("testString")
				mediaItemModel.APIURL = core.StringPtr("testString")
				mediaItemModel.URLProxy = urlProxyModel
				mediaItemModel.Caption = core.StringPtr("testString")
				mediaItemModel.CaptionI18n = make(map[string]string)
				mediaItemModel.Type = core.StringPtr("testString")
				mediaItemModel.ThumbnailURL = core.StringPtr("testString")

				// Construct an instance of the ArchitectureDiagram model
				architectureDiagramModel := new(catalogmanagementv1.ArchitectureDiagram)
				architectureDiagramModel.Diagram = mediaItemModel
				architectureDiagramModel.Description = core.StringPtr("testString")
				architectureDiagramModel.DescriptionI18n = make(map[string]string)

				// Construct an instance of the CostComponent model
				costComponentModel := new(catalogmanagementv1.CostComponent)
				costComponentModel.Name = core.StringPtr("testString")
				costComponentModel.Unit = core.StringPtr("testString")
				costComponentModel.HourlyQuantity = core.StringPtr("testString")
				costComponentModel.MonthlyQuantity = core.StringPtr("testString")
				costComponentModel.Price = core.StringPtr("testString")
				costComponentModel.HourlyCost = core.StringPtr("testString")
				costComponentModel.MonthlyCost = core.StringPtr("testString")

				// Construct an instance of the CostResource model
				costResourceModel := new(catalogmanagementv1.CostResource)
				costResourceModel.Name = core.StringPtr("testString")
				costResourceModel.Metadata = make(map[string]interface{})
				costResourceModel.HourlyCost = core.StringPtr("testString")
				costResourceModel.MonthlyCost = core.StringPtr("testString")
				costResourceModel.CostComponents = []catalogmanagementv1.CostComponent{*costComponentModel}

				// Construct an instance of the CostBreakdown model
				costBreakdownModel := new(catalogmanagementv1.CostBreakdown)
				costBreakdownModel.TotalHourlyCost = core.StringPtr("testString")
				costBreakdownModel.TotalMonthlyCOst = core.StringPtr("testString")
				costBreakdownModel.Resources = []catalogmanagementv1.CostResource{*costResourceModel}

				// Construct an instance of the CostSummary model
				costSummaryModel := new(catalogmanagementv1.CostSummary)
				costSummaryModel.TotalDetectedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalSupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUnsupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUsageBasedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalNoPriceResources = core.Int64Ptr(int64(38))
				costSummaryModel.UnsupportedResourceCounts = make(map[string]int64)
				costSummaryModel.NoPriceResourceCounts = make(map[string]int64)

				// Construct an instance of the Project model
				projectModel := new(catalogmanagementv1.Project)
				projectModel.Name = core.StringPtr("testString")
				projectModel.Metadata = make(map[string]interface{})
				projectModel.PastBreakdown = costBreakdownModel
				projectModel.Breakdown = costBreakdownModel
				projectModel.Diff = costBreakdownModel
				projectModel.Summary = costSummaryModel

				// Construct an instance of the CostEstimate model
				costEstimateModel := new(catalogmanagementv1.CostEstimate)
				costEstimateModel.Version = core.StringPtr("testString")
				costEstimateModel.Currency = core.StringPtr("testString")
				costEstimateModel.Projects = []catalogmanagementv1.Project{*projectModel}
				costEstimateModel.Summary = costSummaryModel
				costEstimateModel.TotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.TotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.TimeGenerated = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the Dependency model
				dependencyModel := new(catalogmanagementv1.Dependency)
				dependencyModel.CatalogID = core.StringPtr("testString")
				dependencyModel.ID = core.StringPtr("testString")
				dependencyModel.Name = core.StringPtr("testString")
				dependencyModel.Version = core.StringPtr("testString")
				dependencyModel.Flavors = []string{"testString"}

				// Construct an instance of the SolutionInfo model
				solutionInfoModel := new(catalogmanagementv1.SolutionInfo)
				solutionInfoModel.ArchitectureDiagrams = []catalogmanagementv1.ArchitectureDiagram{*architectureDiagramModel}
				solutionInfoModel.Features = []catalogmanagementv1.Feature{*featureModel}
				solutionInfoModel.CostEstimate = costEstimateModel
				solutionInfoModel.Dependencies = []catalogmanagementv1.Dependency{*dependencyModel}

				// Construct an instance of the Version model
				versionModel := new(catalogmanagementv1.Version)
				versionModel.ID = core.StringPtr("testString")
				versionModel.Rev = core.StringPtr("testString")
				versionModel.CRN = core.StringPtr("testString")
				versionModel.Version = core.StringPtr("testString")
				versionModel.Flavor = flavorModel
				versionModel.Sha = core.StringPtr("testString")
				versionModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.OfferingID = core.StringPtr("testString")
				versionModel.CatalogID = core.StringPtr("testString")
				versionModel.KindID = core.StringPtr("testString")
				versionModel.Tags = []string{"testString"}
				versionModel.RepoURL = core.StringPtr("testString")
				versionModel.SourceURL = core.StringPtr("testString")
				versionModel.TgzURL = core.StringPtr("testString")
				versionModel.Configuration = []catalogmanagementv1.Configuration{*configurationModel}
				versionModel.Outputs = []catalogmanagementv1.Output{*outputModel}
				versionModel.IamPermissions = []catalogmanagementv1.IamPermission{*iamPermissionModel}
				versionModel.Metadata = make(map[string]interface{})
				versionModel.Validation = validationModel
				versionModel.RequiredResources = []catalogmanagementv1.Resource{*resourceModel}
				versionModel.SingleInstance = core.BoolPtr(true)
				versionModel.Install = scriptModel
				versionModel.PreInstall = []catalogmanagementv1.Script{*scriptModel}
				versionModel.Entitlement = versionEntitlementModel
				versionModel.Licenses = []catalogmanagementv1.License{*licenseModel}
				versionModel.ImageManifestURL = core.StringPtr("testString")
				versionModel.Deprecated = core.BoolPtr(true)
				versionModel.PackageVersion = core.StringPtr("testString")
				versionModel.State = stateModel
				versionModel.VersionLocator = core.StringPtr("testString")
				versionModel.LongDescription = core.StringPtr("testString")
				versionModel.LongDescriptionI18n = make(map[string]string)
				versionModel.WhitelistedAccounts = []string{"testString"}
				versionModel.ImagePullKeyName = core.StringPtr("testString")
				versionModel.DeprecatePending = deprecatePendingModel
				versionModel.SolutionInfo = solutionInfoModel
				versionModel.IsConsumable = core.BoolPtr(true)

				// Construct an instance of the Deployment model
				deploymentModel := new(catalogmanagementv1.Deployment)
				deploymentModel.ID = core.StringPtr("testString")
				deploymentModel.Label = core.StringPtr("testString")
				deploymentModel.Name = core.StringPtr("testString")
				deploymentModel.ShortDescription = core.StringPtr("testString")
				deploymentModel.LongDescription = core.StringPtr("testString")
				deploymentModel.Metadata = make(map[string]interface{})
				deploymentModel.Tags = []string{"testString"}
				deploymentModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				deploymentModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the Plan model
				planModel := new(catalogmanagementv1.Plan)
				planModel.ID = core.StringPtr("testString")
				planModel.Label = core.StringPtr("testString")
				planModel.Name = core.StringPtr("testString")
				planModel.ShortDescription = core.StringPtr("testString")
				planModel.LongDescription = core.StringPtr("testString")
				planModel.Metadata = make(map[string]interface{})
				planModel.Tags = []string{"testString"}
				planModel.AdditionalFeatures = []catalogmanagementv1.Feature{*featureModel}
				planModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.Deployments = []catalogmanagementv1.Deployment{*deploymentModel}

				// Construct an instance of the Kind model
				kindModel := new(catalogmanagementv1.Kind)
				kindModel.ID = core.StringPtr("testString")
				kindModel.FormatKind = core.StringPtr("testString")
				kindModel.InstallKind = core.StringPtr("testString")
				kindModel.TargetKind = core.StringPtr("testString")
				kindModel.Metadata = make(map[string]interface{})
				kindModel.Tags = []string{"testString"}
				kindModel.AdditionalFeatures = []catalogmanagementv1.Feature{*featureModel}
				kindModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Versions = []catalogmanagementv1.Version{*versionModel}
				kindModel.Plans = []catalogmanagementv1.Plan{*planModel}

				// Construct an instance of the ProviderInfo model
				providerInfoModel := new(catalogmanagementv1.ProviderInfo)
				providerInfoModel.ID = core.StringPtr("testString")
				providerInfoModel.Name = core.StringPtr("testString")

				// Construct an instance of the RepoInfo model
				repoInfoModel := new(catalogmanagementv1.RepoInfo)
				repoInfoModel.Token = core.StringPtr("testString")
				repoInfoModel.Type = core.StringPtr("testString")

				// Construct an instance of the ImagePullKey model
				imagePullKeyModel := new(catalogmanagementv1.ImagePullKey)
				imagePullKeyModel.Name = core.StringPtr("testString")
				imagePullKeyModel.Value = core.StringPtr("testString")
				imagePullKeyModel.Description = core.StringPtr("testString")

				// Construct an instance of the SupportWaitTime model
				supportWaitTimeModel := new(catalogmanagementv1.SupportWaitTime)
				supportWaitTimeModel.Value = core.Int64Ptr(int64(38))
				supportWaitTimeModel.Type = core.StringPtr("testString")

				// Construct an instance of the SupportTime model
				supportTimeModel := new(catalogmanagementv1.SupportTime)
				supportTimeModel.Day = core.Int64Ptr(int64(38))
				supportTimeModel.StartTime = core.StringPtr("testString")
				supportTimeModel.EndTime = core.StringPtr("testString")

				// Construct an instance of the SupportAvailability model
				supportAvailabilityModel := new(catalogmanagementv1.SupportAvailability)
				supportAvailabilityModel.Times = []catalogmanagementv1.SupportTime{*supportTimeModel}
				supportAvailabilityModel.Timezone = core.StringPtr("testString")
				supportAvailabilityModel.AlwaysAvailable = core.BoolPtr(true)

				// Construct an instance of the SupportDetail model
				supportDetailModel := new(catalogmanagementv1.SupportDetail)
				supportDetailModel.Type = core.StringPtr("testString")
				supportDetailModel.Contact = core.StringPtr("testString")
				supportDetailModel.ResponseWaitTime = supportWaitTimeModel
				supportDetailModel.Availability = supportAvailabilityModel

				// Construct an instance of the SupportEscalation model
				supportEscalationModel := new(catalogmanagementv1.SupportEscalation)
				supportEscalationModel.EscalationWaitTime = supportWaitTimeModel
				supportEscalationModel.ResponseWaitTime = supportWaitTimeModel
				supportEscalationModel.Contact = core.StringPtr("testString")

				// Construct an instance of the Support model
				supportModel := new(catalogmanagementv1.Support)
				supportModel.URL = core.StringPtr("testString")
				supportModel.Process = core.StringPtr("testString")
				supportModel.ProcessI18n = make(map[string]string)
				supportModel.Locations = []string{"testString"}
				supportModel.SupportDetails = []catalogmanagementv1.SupportDetail{*supportDetailModel}
				supportModel.SupportEscalation = supportEscalationModel
				supportModel.SupportType = core.StringPtr("testString")

				// Construct an instance of the LearnMoreLinks model
				learnMoreLinksModel := new(catalogmanagementv1.LearnMoreLinks)
				learnMoreLinksModel.FirstParty = core.StringPtr("testString")
				learnMoreLinksModel.ThirdParty = core.StringPtr("testString")

				// Construct an instance of the Constraint model
				constraintModel := new(catalogmanagementv1.Constraint)
				constraintModel.Type = core.StringPtr("testString")
				constraintModel.Rule = core.StringPtr("testString")

				// Construct an instance of the Badge model
				badgeModel := new(catalogmanagementv1.Badge)
				badgeModel.ID = core.StringPtr("testString")
				badgeModel.Label = core.StringPtr("testString")
				badgeModel.LabelI18n = make(map[string]string)
				badgeModel.Description = core.StringPtr("testString")
				badgeModel.DescriptionI18n = make(map[string]string)
				badgeModel.Icon = core.StringPtr("testString")
				badgeModel.Authority = core.StringPtr("testString")
				badgeModel.Tag = core.StringPtr("testString")
				badgeModel.LearnMoreLinks = learnMoreLinksModel
				badgeModel.Constraints = []catalogmanagementv1.Constraint{*constraintModel}

				// Construct an instance of the ReplaceOfferingOptions model
				replaceOfferingOptionsModel := new(catalogmanagementv1.ReplaceOfferingOptions)
				replaceOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				replaceOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				replaceOfferingOptionsModel.ID = core.StringPtr("testString")
				replaceOfferingOptionsModel.Rev = core.StringPtr("testString")
				replaceOfferingOptionsModel.URL = core.StringPtr("testString")
				replaceOfferingOptionsModel.CRN = core.StringPtr("testString")
				replaceOfferingOptionsModel.Label = core.StringPtr("testString")
				replaceOfferingOptionsModel.LabelI18n = make(map[string]string)
				replaceOfferingOptionsModel.Name = core.StringPtr("testString")
				replaceOfferingOptionsModel.OfferingIconURL = core.StringPtr("testString")
				replaceOfferingOptionsModel.OfferingDocsURL = core.StringPtr("testString")
				replaceOfferingOptionsModel.OfferingSupportURL = core.StringPtr("testString")
				replaceOfferingOptionsModel.Tags = []string{"testString"}
				replaceOfferingOptionsModel.Keywords = []string{"testString"}
				replaceOfferingOptionsModel.Rating = ratingModel
				replaceOfferingOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				replaceOfferingOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				replaceOfferingOptionsModel.ShortDescription = core.StringPtr("testString")
				replaceOfferingOptionsModel.ShortDescriptionI18n = make(map[string]string)
				replaceOfferingOptionsModel.LongDescription = core.StringPtr("testString")
				replaceOfferingOptionsModel.LongDescriptionI18n = make(map[string]string)
				replaceOfferingOptionsModel.Features = []catalogmanagementv1.Feature{*featureModel}
				replaceOfferingOptionsModel.Kinds = []catalogmanagementv1.Kind{*kindModel}
				replaceOfferingOptionsModel.PcManaged = core.BoolPtr(true)
				replaceOfferingOptionsModel.PublishApproved = core.BoolPtr(true)
				replaceOfferingOptionsModel.ShareWithAll = core.BoolPtr(true)
				replaceOfferingOptionsModel.ShareWithIBM = core.BoolPtr(true)
				replaceOfferingOptionsModel.ShareEnabled = core.BoolPtr(true)
				replaceOfferingOptionsModel.PermitRequestIBMPublicPublish = core.BoolPtr(true)
				replaceOfferingOptionsModel.IBMPublishApproved = core.BoolPtr(true)
				replaceOfferingOptionsModel.PublicPublishApproved = core.BoolPtr(true)
				replaceOfferingOptionsModel.PublicOriginalCRN = core.StringPtr("testString")
				replaceOfferingOptionsModel.PublishPublicCRN = core.StringPtr("testString")
				replaceOfferingOptionsModel.PortalApprovalRecord = core.StringPtr("testString")
				replaceOfferingOptionsModel.PortalUIURL = core.StringPtr("testString")
				replaceOfferingOptionsModel.CatalogID = core.StringPtr("testString")
				replaceOfferingOptionsModel.CatalogName = core.StringPtr("testString")
				replaceOfferingOptionsModel.Metadata = make(map[string]interface{})
				replaceOfferingOptionsModel.Disclaimer = core.StringPtr("testString")
				replaceOfferingOptionsModel.Hidden = core.BoolPtr(true)
				replaceOfferingOptionsModel.Provider = core.StringPtr("testString")
				replaceOfferingOptionsModel.ProviderInfo = providerInfoModel
				replaceOfferingOptionsModel.RepoInfo = repoInfoModel
				replaceOfferingOptionsModel.ImagePullKeys = []catalogmanagementv1.ImagePullKey{*imagePullKeyModel}
				replaceOfferingOptionsModel.Support = supportModel
				replaceOfferingOptionsModel.Media = []catalogmanagementv1.MediaItem{*mediaItemModel}
				replaceOfferingOptionsModel.DeprecatePending = deprecatePendingModel
				replaceOfferingOptionsModel.ProductKind = core.StringPtr("testString")
				replaceOfferingOptionsModel.Badges = []catalogmanagementv1.Badge{*badgeModel}
				replaceOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.ReplaceOffering(replaceOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ReplaceOfferingOptions model with no property values
				replaceOfferingOptionsModelNew := new(catalogmanagementv1.ReplaceOfferingOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.ReplaceOffering(replaceOfferingOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ReplaceOffering successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Rating model
				ratingModel := new(catalogmanagementv1.Rating)
				ratingModel.OneStarCount = core.Int64Ptr(int64(38))
				ratingModel.TwoStarCount = core.Int64Ptr(int64(38))
				ratingModel.ThreeStarCount = core.Int64Ptr(int64(38))
				ratingModel.FourStarCount = core.Int64Ptr(int64(38))

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = make(map[string]string)
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = make(map[string]string)

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = make(map[string]string)
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the RenderTypeAssociationsParametersItem model
				renderTypeAssociationsParametersItemModel := new(catalogmanagementv1.RenderTypeAssociationsParametersItem)
				renderTypeAssociationsParametersItemModel.Name = core.StringPtr("testString")
				renderTypeAssociationsParametersItemModel.OptionsRefresh = core.BoolPtr(true)

				// Construct an instance of the RenderTypeAssociations model
				renderTypeAssociationsModel := new(catalogmanagementv1.RenderTypeAssociations)
				renderTypeAssociationsModel.Parameters = []catalogmanagementv1.RenderTypeAssociationsParametersItem{*renderTypeAssociationsParametersItemModel}

				// Construct an instance of the RenderType model
				renderTypeModel := new(catalogmanagementv1.RenderType)
				renderTypeModel.Type = core.StringPtr("testString")
				renderTypeModel.Grouping = core.StringPtr("testString")
				renderTypeModel.OriginalGrouping = core.StringPtr("testString")
				renderTypeModel.GroupingIndex = core.Int64Ptr(int64(38))
				renderTypeModel.ConfigConstraints = map[string]interface{}{"anyKey": "anyValue"}
				renderTypeModel.Associations = renderTypeAssociationsModel

				// Construct an instance of the Configuration model
				configurationModel := new(catalogmanagementv1.Configuration)
				configurationModel.Key = core.StringPtr("testString")
				configurationModel.Type = core.StringPtr("testString")
				configurationModel.DefaultValue = core.StringPtr("testString")
				configurationModel.DisplayName = core.StringPtr("testString")
				configurationModel.ValueConstraint = core.StringPtr("testString")
				configurationModel.Description = core.StringPtr("testString")
				configurationModel.Required = core.BoolPtr(true)
				configurationModel.Options = []interface{}{"testString"}
				configurationModel.Hidden = core.BoolPtr(true)
				configurationModel.CustomConfig = renderTypeModel
				configurationModel.TypeMetadata = core.StringPtr("testString")

				// Construct an instance of the Output model
				outputModel := new(catalogmanagementv1.Output)
				outputModel.Key = core.StringPtr("testString")
				outputModel.Description = core.StringPtr("testString")

				// Construct an instance of the IamResource model
				iamResourceModel := new(catalogmanagementv1.IamResource)
				iamResourceModel.Name = core.StringPtr("testString")
				iamResourceModel.Description = core.StringPtr("testString")
				iamResourceModel.RoleCrns = []string{"testString"}

				// Construct an instance of the IamPermission model
				iamPermissionModel := new(catalogmanagementv1.IamPermission)
				iamPermissionModel.ServiceName = core.StringPtr("testString")
				iamPermissionModel.RoleCrns = []string{"testString"}
				iamPermissionModel.Resources = []catalogmanagementv1.IamResource{*iamResourceModel}

				// Construct an instance of the Validation model
				validationModel := new(catalogmanagementv1.Validation)
				validationModel.Validated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.Requested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.State = core.StringPtr("testString")
				validationModel.LastOperation = core.StringPtr("testString")
				validationModel.Target = make(map[string]interface{})
				validationModel.Message = core.StringPtr("testString")

				// Construct an instance of the Resource model
				resourceModel := new(catalogmanagementv1.Resource)
				resourceModel.Type = core.StringPtr("mem")
				resourceModel.Value = core.StringPtr("testString")

				// Construct an instance of the Script model
				scriptModel := new(catalogmanagementv1.Script)
				scriptModel.Instructions = core.StringPtr("testString")
				scriptModel.InstructionsI18n = make(map[string]string)
				scriptModel.Script = core.StringPtr("testString")
				scriptModel.ScriptPermission = core.StringPtr("testString")
				scriptModel.DeleteScript = core.StringPtr("testString")
				scriptModel.Scope = core.StringPtr("testString")

				// Construct an instance of the VersionEntitlement model
				versionEntitlementModel := new(catalogmanagementv1.VersionEntitlement)
				versionEntitlementModel.ProviderName = core.StringPtr("testString")
				versionEntitlementModel.ProviderID = core.StringPtr("testString")
				versionEntitlementModel.ProductID = core.StringPtr("testString")
				versionEntitlementModel.PartNumbers = []string{"testString"}
				versionEntitlementModel.ImageRepoName = core.StringPtr("testString")

				// Construct an instance of the License model
				licenseModel := new(catalogmanagementv1.License)
				licenseModel.ID = core.StringPtr("testString")
				licenseModel.Name = core.StringPtr("testString")
				licenseModel.Type = core.StringPtr("testString")
				licenseModel.URL = core.StringPtr("testString")
				licenseModel.Description = core.StringPtr("testString")

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")

				// Construct an instance of the DeprecatePending model
				deprecatePendingModel := new(catalogmanagementv1.DeprecatePending)
				deprecatePendingModel.DeprecateDate = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				deprecatePendingModel.DeprecateState = core.StringPtr("testString")
				deprecatePendingModel.Description = core.StringPtr("testString")

				// Construct an instance of the URLProxy model
				urlProxyModel := new(catalogmanagementv1.URLProxy)
				urlProxyModel.URL = core.StringPtr("testString")
				urlProxyModel.Sha = core.StringPtr("testString")

				// Construct an instance of the MediaItem model
				mediaItemModel := new(catalogmanagementv1.MediaItem)
				mediaItemModel.URL = core.StringPtr("testString")
				mediaItemModel.APIURL = core.StringPtr("testString")
				mediaItemModel.URLProxy = urlProxyModel
				mediaItemModel.Caption = core.StringPtr("testString")
				mediaItemModel.CaptionI18n = make(map[string]string)
				mediaItemModel.Type = core.StringPtr("testString")
				mediaItemModel.ThumbnailURL = core.StringPtr("testString")

				// Construct an instance of the ArchitectureDiagram model
				architectureDiagramModel := new(catalogmanagementv1.ArchitectureDiagram)
				architectureDiagramModel.Diagram = mediaItemModel
				architectureDiagramModel.Description = core.StringPtr("testString")
				architectureDiagramModel.DescriptionI18n = make(map[string]string)

				// Construct an instance of the CostComponent model
				costComponentModel := new(catalogmanagementv1.CostComponent)
				costComponentModel.Name = core.StringPtr("testString")
				costComponentModel.Unit = core.StringPtr("testString")
				costComponentModel.HourlyQuantity = core.StringPtr("testString")
				costComponentModel.MonthlyQuantity = core.StringPtr("testString")
				costComponentModel.Price = core.StringPtr("testString")
				costComponentModel.HourlyCost = core.StringPtr("testString")
				costComponentModel.MonthlyCost = core.StringPtr("testString")

				// Construct an instance of the CostResource model
				costResourceModel := new(catalogmanagementv1.CostResource)
				costResourceModel.Name = core.StringPtr("testString")
				costResourceModel.Metadata = make(map[string]interface{})
				costResourceModel.HourlyCost = core.StringPtr("testString")
				costResourceModel.MonthlyCost = core.StringPtr("testString")
				costResourceModel.CostComponents = []catalogmanagementv1.CostComponent{*costComponentModel}

				// Construct an instance of the CostBreakdown model
				costBreakdownModel := new(catalogmanagementv1.CostBreakdown)
				costBreakdownModel.TotalHourlyCost = core.StringPtr("testString")
				costBreakdownModel.TotalMonthlyCOst = core.StringPtr("testString")
				costBreakdownModel.Resources = []catalogmanagementv1.CostResource{*costResourceModel}

				// Construct an instance of the CostSummary model
				costSummaryModel := new(catalogmanagementv1.CostSummary)
				costSummaryModel.TotalDetectedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalSupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUnsupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUsageBasedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalNoPriceResources = core.Int64Ptr(int64(38))
				costSummaryModel.UnsupportedResourceCounts = make(map[string]int64)
				costSummaryModel.NoPriceResourceCounts = make(map[string]int64)

				// Construct an instance of the Project model
				projectModel := new(catalogmanagementv1.Project)
				projectModel.Name = core.StringPtr("testString")
				projectModel.Metadata = make(map[string]interface{})
				projectModel.PastBreakdown = costBreakdownModel
				projectModel.Breakdown = costBreakdownModel
				projectModel.Diff = costBreakdownModel
				projectModel.Summary = costSummaryModel

				// Construct an instance of the CostEstimate model
				costEstimateModel := new(catalogmanagementv1.CostEstimate)
				costEstimateModel.Version = core.StringPtr("testString")
				costEstimateModel.Currency = core.StringPtr("testString")
				costEstimateModel.Projects = []catalogmanagementv1.Project{*projectModel}
				costEstimateModel.Summary = costSummaryModel
				costEstimateModel.TotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.TotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.TimeGenerated = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the Dependency model
				dependencyModel := new(catalogmanagementv1.Dependency)
				dependencyModel.CatalogID = core.StringPtr("testString")
				dependencyModel.ID = core.StringPtr("testString")
				dependencyModel.Name = core.StringPtr("testString")
				dependencyModel.Version = core.StringPtr("testString")
				dependencyModel.Flavors = []string{"testString"}

				// Construct an instance of the SolutionInfo model
				solutionInfoModel := new(catalogmanagementv1.SolutionInfo)
				solutionInfoModel.ArchitectureDiagrams = []catalogmanagementv1.ArchitectureDiagram{*architectureDiagramModel}
				solutionInfoModel.Features = []catalogmanagementv1.Feature{*featureModel}
				solutionInfoModel.CostEstimate = costEstimateModel
				solutionInfoModel.Dependencies = []catalogmanagementv1.Dependency{*dependencyModel}

				// Construct an instance of the Version model
				versionModel := new(catalogmanagementv1.Version)
				versionModel.ID = core.StringPtr("testString")
				versionModel.Rev = core.StringPtr("testString")
				versionModel.CRN = core.StringPtr("testString")
				versionModel.Version = core.StringPtr("testString")
				versionModel.Flavor = flavorModel
				versionModel.Sha = core.StringPtr("testString")
				versionModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.OfferingID = core.StringPtr("testString")
				versionModel.CatalogID = core.StringPtr("testString")
				versionModel.KindID = core.StringPtr("testString")
				versionModel.Tags = []string{"testString"}
				versionModel.RepoURL = core.StringPtr("testString")
				versionModel.SourceURL = core.StringPtr("testString")
				versionModel.TgzURL = core.StringPtr("testString")
				versionModel.Configuration = []catalogmanagementv1.Configuration{*configurationModel}
				versionModel.Outputs = []catalogmanagementv1.Output{*outputModel}
				versionModel.IamPermissions = []catalogmanagementv1.IamPermission{*iamPermissionModel}
				versionModel.Metadata = make(map[string]interface{})
				versionModel.Validation = validationModel
				versionModel.RequiredResources = []catalogmanagementv1.Resource{*resourceModel}
				versionModel.SingleInstance = core.BoolPtr(true)
				versionModel.Install = scriptModel
				versionModel.PreInstall = []catalogmanagementv1.Script{*scriptModel}
				versionModel.Entitlement = versionEntitlementModel
				versionModel.Licenses = []catalogmanagementv1.License{*licenseModel}
				versionModel.ImageManifestURL = core.StringPtr("testString")
				versionModel.Deprecated = core.BoolPtr(true)
				versionModel.PackageVersion = core.StringPtr("testString")
				versionModel.State = stateModel
				versionModel.VersionLocator = core.StringPtr("testString")
				versionModel.LongDescription = core.StringPtr("testString")
				versionModel.LongDescriptionI18n = make(map[string]string)
				versionModel.WhitelistedAccounts = []string{"testString"}
				versionModel.ImagePullKeyName = core.StringPtr("testString")
				versionModel.DeprecatePending = deprecatePendingModel
				versionModel.SolutionInfo = solutionInfoModel
				versionModel.IsConsumable = core.BoolPtr(true)

				// Construct an instance of the Deployment model
				deploymentModel := new(catalogmanagementv1.Deployment)
				deploymentModel.ID = core.StringPtr("testString")
				deploymentModel.Label = core.StringPtr("testString")
				deploymentModel.Name = core.StringPtr("testString")
				deploymentModel.ShortDescription = core.StringPtr("testString")
				deploymentModel.LongDescription = core.StringPtr("testString")
				deploymentModel.Metadata = make(map[string]interface{})
				deploymentModel.Tags = []string{"testString"}
				deploymentModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				deploymentModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the Plan model
				planModel := new(catalogmanagementv1.Plan)
				planModel.ID = core.StringPtr("testString")
				planModel.Label = core.StringPtr("testString")
				planModel.Name = core.StringPtr("testString")
				planModel.ShortDescription = core.StringPtr("testString")
				planModel.LongDescription = core.StringPtr("testString")
				planModel.Metadata = make(map[string]interface{})
				planModel.Tags = []string{"testString"}
				planModel.AdditionalFeatures = []catalogmanagementv1.Feature{*featureModel}
				planModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.Deployments = []catalogmanagementv1.Deployment{*deploymentModel}

				// Construct an instance of the Kind model
				kindModel := new(catalogmanagementv1.Kind)
				kindModel.ID = core.StringPtr("testString")
				kindModel.FormatKind = core.StringPtr("testString")
				kindModel.InstallKind = core.StringPtr("testString")
				kindModel.TargetKind = core.StringPtr("testString")
				kindModel.Metadata = make(map[string]interface{})
				kindModel.Tags = []string{"testString"}
				kindModel.AdditionalFeatures = []catalogmanagementv1.Feature{*featureModel}
				kindModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Versions = []catalogmanagementv1.Version{*versionModel}
				kindModel.Plans = []catalogmanagementv1.Plan{*planModel}

				// Construct an instance of the ProviderInfo model
				providerInfoModel := new(catalogmanagementv1.ProviderInfo)
				providerInfoModel.ID = core.StringPtr("testString")
				providerInfoModel.Name = core.StringPtr("testString")

				// Construct an instance of the RepoInfo model
				repoInfoModel := new(catalogmanagementv1.RepoInfo)
				repoInfoModel.Token = core.StringPtr("testString")
				repoInfoModel.Type = core.StringPtr("testString")

				// Construct an instance of the ImagePullKey model
				imagePullKeyModel := new(catalogmanagementv1.ImagePullKey)
				imagePullKeyModel.Name = core.StringPtr("testString")
				imagePullKeyModel.Value = core.StringPtr("testString")
				imagePullKeyModel.Description = core.StringPtr("testString")

				// Construct an instance of the SupportWaitTime model
				supportWaitTimeModel := new(catalogmanagementv1.SupportWaitTime)
				supportWaitTimeModel.Value = core.Int64Ptr(int64(38))
				supportWaitTimeModel.Type = core.StringPtr("testString")

				// Construct an instance of the SupportTime model
				supportTimeModel := new(catalogmanagementv1.SupportTime)
				supportTimeModel.Day = core.Int64Ptr(int64(38))
				supportTimeModel.StartTime = core.StringPtr("testString")
				supportTimeModel.EndTime = core.StringPtr("testString")

				// Construct an instance of the SupportAvailability model
				supportAvailabilityModel := new(catalogmanagementv1.SupportAvailability)
				supportAvailabilityModel.Times = []catalogmanagementv1.SupportTime{*supportTimeModel}
				supportAvailabilityModel.Timezone = core.StringPtr("testString")
				supportAvailabilityModel.AlwaysAvailable = core.BoolPtr(true)

				// Construct an instance of the SupportDetail model
				supportDetailModel := new(catalogmanagementv1.SupportDetail)
				supportDetailModel.Type = core.StringPtr("testString")
				supportDetailModel.Contact = core.StringPtr("testString")
				supportDetailModel.ResponseWaitTime = supportWaitTimeModel
				supportDetailModel.Availability = supportAvailabilityModel

				// Construct an instance of the SupportEscalation model
				supportEscalationModel := new(catalogmanagementv1.SupportEscalation)
				supportEscalationModel.EscalationWaitTime = supportWaitTimeModel
				supportEscalationModel.ResponseWaitTime = supportWaitTimeModel
				supportEscalationModel.Contact = core.StringPtr("testString")

				// Construct an instance of the Support model
				supportModel := new(catalogmanagementv1.Support)
				supportModel.URL = core.StringPtr("testString")
				supportModel.Process = core.StringPtr("testString")
				supportModel.ProcessI18n = make(map[string]string)
				supportModel.Locations = []string{"testString"}
				supportModel.SupportDetails = []catalogmanagementv1.SupportDetail{*supportDetailModel}
				supportModel.SupportEscalation = supportEscalationModel
				supportModel.SupportType = core.StringPtr("testString")

				// Construct an instance of the LearnMoreLinks model
				learnMoreLinksModel := new(catalogmanagementv1.LearnMoreLinks)
				learnMoreLinksModel.FirstParty = core.StringPtr("testString")
				learnMoreLinksModel.ThirdParty = core.StringPtr("testString")

				// Construct an instance of the Constraint model
				constraintModel := new(catalogmanagementv1.Constraint)
				constraintModel.Type = core.StringPtr("testString")
				constraintModel.Rule = core.StringPtr("testString")

				// Construct an instance of the Badge model
				badgeModel := new(catalogmanagementv1.Badge)
				badgeModel.ID = core.StringPtr("testString")
				badgeModel.Label = core.StringPtr("testString")
				badgeModel.LabelI18n = make(map[string]string)
				badgeModel.Description = core.StringPtr("testString")
				badgeModel.DescriptionI18n = make(map[string]string)
				badgeModel.Icon = core.StringPtr("testString")
				badgeModel.Authority = core.StringPtr("testString")
				badgeModel.Tag = core.StringPtr("testString")
				badgeModel.LearnMoreLinks = learnMoreLinksModel
				badgeModel.Constraints = []catalogmanagementv1.Constraint{*constraintModel}

				// Construct an instance of the ReplaceOfferingOptions model
				replaceOfferingOptionsModel := new(catalogmanagementv1.ReplaceOfferingOptions)
				replaceOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				replaceOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				replaceOfferingOptionsModel.ID = core.StringPtr("testString")
				replaceOfferingOptionsModel.Rev = core.StringPtr("testString")
				replaceOfferingOptionsModel.URL = core.StringPtr("testString")
				replaceOfferingOptionsModel.CRN = core.StringPtr("testString")
				replaceOfferingOptionsModel.Label = core.StringPtr("testString")
				replaceOfferingOptionsModel.LabelI18n = make(map[string]string)
				replaceOfferingOptionsModel.Name = core.StringPtr("testString")
				replaceOfferingOptionsModel.OfferingIconURL = core.StringPtr("testString")
				replaceOfferingOptionsModel.OfferingDocsURL = core.StringPtr("testString")
				replaceOfferingOptionsModel.OfferingSupportURL = core.StringPtr("testString")
				replaceOfferingOptionsModel.Tags = []string{"testString"}
				replaceOfferingOptionsModel.Keywords = []string{"testString"}
				replaceOfferingOptionsModel.Rating = ratingModel
				replaceOfferingOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				replaceOfferingOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				replaceOfferingOptionsModel.ShortDescription = core.StringPtr("testString")
				replaceOfferingOptionsModel.ShortDescriptionI18n = make(map[string]string)
				replaceOfferingOptionsModel.LongDescription = core.StringPtr("testString")
				replaceOfferingOptionsModel.LongDescriptionI18n = make(map[string]string)
				replaceOfferingOptionsModel.Features = []catalogmanagementv1.Feature{*featureModel}
				replaceOfferingOptionsModel.Kinds = []catalogmanagementv1.Kind{*kindModel}
				replaceOfferingOptionsModel.PcManaged = core.BoolPtr(true)
				replaceOfferingOptionsModel.PublishApproved = core.BoolPtr(true)
				replaceOfferingOptionsModel.ShareWithAll = core.BoolPtr(true)
				replaceOfferingOptionsModel.ShareWithIBM = core.BoolPtr(true)
				replaceOfferingOptionsModel.ShareEnabled = core.BoolPtr(true)
				replaceOfferingOptionsModel.PermitRequestIBMPublicPublish = core.BoolPtr(true)
				replaceOfferingOptionsModel.IBMPublishApproved = core.BoolPtr(true)
				replaceOfferingOptionsModel.PublicPublishApproved = core.BoolPtr(true)
				replaceOfferingOptionsModel.PublicOriginalCRN = core.StringPtr("testString")
				replaceOfferingOptionsModel.PublishPublicCRN = core.StringPtr("testString")
				replaceOfferingOptionsModel.PortalApprovalRecord = core.StringPtr("testString")
				replaceOfferingOptionsModel.PortalUIURL = core.StringPtr("testString")
				replaceOfferingOptionsModel.CatalogID = core.StringPtr("testString")
				replaceOfferingOptionsModel.CatalogName = core.StringPtr("testString")
				replaceOfferingOptionsModel.Metadata = make(map[string]interface{})
				replaceOfferingOptionsModel.Disclaimer = core.StringPtr("testString")
				replaceOfferingOptionsModel.Hidden = core.BoolPtr(true)
				replaceOfferingOptionsModel.Provider = core.StringPtr("testString")
				replaceOfferingOptionsModel.ProviderInfo = providerInfoModel
				replaceOfferingOptionsModel.RepoInfo = repoInfoModel
				replaceOfferingOptionsModel.ImagePullKeys = []catalogmanagementv1.ImagePullKey{*imagePullKeyModel}
				replaceOfferingOptionsModel.Support = supportModel
				replaceOfferingOptionsModel.Media = []catalogmanagementv1.MediaItem{*mediaItemModel}
				replaceOfferingOptionsModel.DeprecatePending = deprecatePendingModel
				replaceOfferingOptionsModel.ProductKind = core.StringPtr("testString")
				replaceOfferingOptionsModel.Badges = []catalogmanagementv1.Badge{*badgeModel}
				replaceOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.ReplaceOffering(replaceOfferingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateOffering(updateOfferingOptions *UpdateOfferingOptions) - Operation response error`, func() {
		updateOfferingPath := "/catalogs/testString/offerings/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateOfferingPath))
					Expect(req.Method).To(Equal("PATCH"))
					Expect(req.Header["If-Match"]).ToNot(BeNil())
					Expect(req.Header["If-Match"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke UpdateOffering with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the JSONPatchOperation model
				jsonPatchOperationModel := new(catalogmanagementv1.JSONPatchOperation)
				jsonPatchOperationModel.Op = core.StringPtr("add")
				jsonPatchOperationModel.Path = core.StringPtr("testString")
				jsonPatchOperationModel.Value = core.StringPtr("testString")
				jsonPatchOperationModel.From = core.StringPtr("testString")

				// Construct an instance of the UpdateOfferingOptions model
				updateOfferingOptionsModel := new(catalogmanagementv1.UpdateOfferingOptions)
				updateOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				updateOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				updateOfferingOptionsModel.IfMatch = core.StringPtr("testString")
				updateOfferingOptionsModel.Updates = []catalogmanagementv1.JSONPatchOperation{*jsonPatchOperationModel}
				updateOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.UpdateOffering(updateOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.UpdateOffering(updateOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateOffering(updateOfferingOptions *UpdateOfferingOptions)`, func() {
		updateOfferingPath := "/catalogs/testString/offerings/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateOfferingPath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["If-Match"]).ToNot(BeNil())
					Expect(req.Header["If-Match"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "offering_icon_url": "OfferingIconURL", "offering_docs_url": "OfferingDocsURL", "offering_support_url": "OfferingSupportURL", "tags": ["Tags"], "keywords": ["Keywords"], "rating": {"one_star_count": 12, "two_star_count": 12, "three_star_count": 14, "four_star_count": 13}, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "kinds": [{"id": "ID", "format_kind": "FormatKind", "install_kind": "InstallKind", "target_kind": "TargetKind", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"mapKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"mapKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "version": "Version", "flavors": ["Flavors"]}]}, "is_consumable": true}], "plans": [{"id": "ID", "label": "Label", "name": "Name", "short_description": "ShortDescription", "long_description": "LongDescription", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "deployments": [{"id": "ID", "label": "Label", "name": "Name", "short_description": "ShortDescription", "long_description": "LongDescription", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z"}]}]}], "pc_managed": false, "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "permit_request_ibm_public_publish": false, "ibm_publish_approved": true, "public_publish_approved": false, "public_original_crn": "PublicOriginalCRN", "publish_public_crn": "PublishPublicCRN", "portal_approval_record": "PortalApprovalRecord", "portal_ui_url": "PortalUIURL", "catalog_id": "CatalogID", "catalog_name": "CatalogName", "metadata": {"mapKey": "anyValue"}, "disclaimer": "Disclaimer", "hidden": true, "provider": "Provider", "provider_info": {"id": "ID", "name": "Name"}, "repo_info": {"token": "Token", "type": "Type"}, "image_pull_keys": [{"name": "Name", "value": "Value", "description": "Description"}], "support": {"url": "URL", "process": "Process", "process_i18n": {"mapKey": "Inner"}, "locations": ["Locations"], "support_details": [{"type": "Type", "contact": "Contact", "response_wait_time": {"value": 5, "type": "Type"}, "availability": {"times": [{"day": 3, "start_time": "StartTime", "end_time": "EndTime"}], "timezone": "Timezone", "always_available": false}}], "support_escalation": {"escalation_wait_time": {"value": 5, "type": "Type"}, "response_wait_time": {"value": 5, "type": "Type"}, "contact": "Contact"}, "support_type": "SupportType"}, "media": [{"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}], "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "product_kind": "ProductKind", "badges": [{"id": "ID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}, "icon": "Icon", "authority": "Authority", "tag": "Tag", "learn_more_links": {"first_party": "FirstParty", "third_party": "ThirdParty"}, "constraints": [{"type": "Type", "rule": "anyValue"}]}]}`)
				}))
			})
			It(`Invoke UpdateOffering successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the JSONPatchOperation model
				jsonPatchOperationModel := new(catalogmanagementv1.JSONPatchOperation)
				jsonPatchOperationModel.Op = core.StringPtr("add")
				jsonPatchOperationModel.Path = core.StringPtr("testString")
				jsonPatchOperationModel.Value = core.StringPtr("testString")
				jsonPatchOperationModel.From = core.StringPtr("testString")

				// Construct an instance of the UpdateOfferingOptions model
				updateOfferingOptionsModel := new(catalogmanagementv1.UpdateOfferingOptions)
				updateOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				updateOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				updateOfferingOptionsModel.IfMatch = core.StringPtr("testString")
				updateOfferingOptionsModel.Updates = []catalogmanagementv1.JSONPatchOperation{*jsonPatchOperationModel}
				updateOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.UpdateOfferingWithContext(ctx, updateOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.UpdateOffering(updateOfferingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.UpdateOfferingWithContext(ctx, updateOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateOfferingPath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["If-Match"]).ToNot(BeNil())
					Expect(req.Header["If-Match"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "offering_icon_url": "OfferingIconURL", "offering_docs_url": "OfferingDocsURL", "offering_support_url": "OfferingSupportURL", "tags": ["Tags"], "keywords": ["Keywords"], "rating": {"one_star_count": 12, "two_star_count": 12, "three_star_count": 14, "four_star_count": 13}, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "kinds": [{"id": "ID", "format_kind": "FormatKind", "install_kind": "InstallKind", "target_kind": "TargetKind", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"mapKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"mapKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "version": "Version", "flavors": ["Flavors"]}]}, "is_consumable": true}], "plans": [{"id": "ID", "label": "Label", "name": "Name", "short_description": "ShortDescription", "long_description": "LongDescription", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "deployments": [{"id": "ID", "label": "Label", "name": "Name", "short_description": "ShortDescription", "long_description": "LongDescription", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z"}]}]}], "pc_managed": false, "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "permit_request_ibm_public_publish": false, "ibm_publish_approved": true, "public_publish_approved": false, "public_original_crn": "PublicOriginalCRN", "publish_public_crn": "PublishPublicCRN", "portal_approval_record": "PortalApprovalRecord", "portal_ui_url": "PortalUIURL", "catalog_id": "CatalogID", "catalog_name": "CatalogName", "metadata": {"mapKey": "anyValue"}, "disclaimer": "Disclaimer", "hidden": true, "provider": "Provider", "provider_info": {"id": "ID", "name": "Name"}, "repo_info": {"token": "Token", "type": "Type"}, "image_pull_keys": [{"name": "Name", "value": "Value", "description": "Description"}], "support": {"url": "URL", "process": "Process", "process_i18n": {"mapKey": "Inner"}, "locations": ["Locations"], "support_details": [{"type": "Type", "contact": "Contact", "response_wait_time": {"value": 5, "type": "Type"}, "availability": {"times": [{"day": 3, "start_time": "StartTime", "end_time": "EndTime"}], "timezone": "Timezone", "always_available": false}}], "support_escalation": {"escalation_wait_time": {"value": 5, "type": "Type"}, "response_wait_time": {"value": 5, "type": "Type"}, "contact": "Contact"}, "support_type": "SupportType"}, "media": [{"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}], "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "product_kind": "ProductKind", "badges": [{"id": "ID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}, "icon": "Icon", "authority": "Authority", "tag": "Tag", "learn_more_links": {"first_party": "FirstParty", "third_party": "ThirdParty"}, "constraints": [{"type": "Type", "rule": "anyValue"}]}]}`)
				}))
			})
			It(`Invoke UpdateOffering successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.UpdateOffering(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the JSONPatchOperation model
				jsonPatchOperationModel := new(catalogmanagementv1.JSONPatchOperation)
				jsonPatchOperationModel.Op = core.StringPtr("add")
				jsonPatchOperationModel.Path = core.StringPtr("testString")
				jsonPatchOperationModel.Value = core.StringPtr("testString")
				jsonPatchOperationModel.From = core.StringPtr("testString")

				// Construct an instance of the UpdateOfferingOptions model
				updateOfferingOptionsModel := new(catalogmanagementv1.UpdateOfferingOptions)
				updateOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				updateOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				updateOfferingOptionsModel.IfMatch = core.StringPtr("testString")
				updateOfferingOptionsModel.Updates = []catalogmanagementv1.JSONPatchOperation{*jsonPatchOperationModel}
				updateOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.UpdateOffering(updateOfferingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke UpdateOffering with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the JSONPatchOperation model
				jsonPatchOperationModel := new(catalogmanagementv1.JSONPatchOperation)
				jsonPatchOperationModel.Op = core.StringPtr("add")
				jsonPatchOperationModel.Path = core.StringPtr("testString")
				jsonPatchOperationModel.Value = core.StringPtr("testString")
				jsonPatchOperationModel.From = core.StringPtr("testString")

				// Construct an instance of the UpdateOfferingOptions model
				updateOfferingOptionsModel := new(catalogmanagementv1.UpdateOfferingOptions)
				updateOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				updateOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				updateOfferingOptionsModel.IfMatch = core.StringPtr("testString")
				updateOfferingOptionsModel.Updates = []catalogmanagementv1.JSONPatchOperation{*jsonPatchOperationModel}
				updateOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.UpdateOffering(updateOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the UpdateOfferingOptions model with no property values
				updateOfferingOptionsModelNew := new(catalogmanagementv1.UpdateOfferingOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.UpdateOffering(updateOfferingOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke UpdateOffering successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the JSONPatchOperation model
				jsonPatchOperationModel := new(catalogmanagementv1.JSONPatchOperation)
				jsonPatchOperationModel.Op = core.StringPtr("add")
				jsonPatchOperationModel.Path = core.StringPtr("testString")
				jsonPatchOperationModel.Value = core.StringPtr("testString")
				jsonPatchOperationModel.From = core.StringPtr("testString")

				// Construct an instance of the UpdateOfferingOptions model
				updateOfferingOptionsModel := new(catalogmanagementv1.UpdateOfferingOptions)
				updateOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				updateOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				updateOfferingOptionsModel.IfMatch = core.StringPtr("testString")
				updateOfferingOptionsModel.Updates = []catalogmanagementv1.JSONPatchOperation{*jsonPatchOperationModel}
				updateOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.UpdateOffering(updateOfferingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteOffering(deleteOfferingOptions *DeleteOfferingOptions)`, func() {
		deleteOfferingPath := "/catalogs/testString/offerings/testString"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteOfferingPath))
					Expect(req.Method).To(Equal("DELETE"))

					res.WriteHeader(200)
				}))
			})
			It(`Invoke DeleteOffering successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.DeleteOffering(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteOfferingOptions model
				deleteOfferingOptionsModel := new(catalogmanagementv1.DeleteOfferingOptions)
				deleteOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				deleteOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				deleteOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.DeleteOffering(deleteOfferingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteOffering with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the DeleteOfferingOptions model
				deleteOfferingOptionsModel := new(catalogmanagementv1.DeleteOfferingOptions)
				deleteOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				deleteOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				deleteOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.DeleteOffering(deleteOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeleteOfferingOptions model with no property values
				deleteOfferingOptionsModelNew := new(catalogmanagementv1.DeleteOfferingOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.DeleteOffering(deleteOfferingOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListOfferingAudits(listOfferingAuditsOptions *ListOfferingAuditsOptions) - Operation response error`, func() {
		listOfferingAuditsPath := "/catalogs/testString/offerings/testString/audits"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listOfferingAuditsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// TODO: Add check for lookupnames query parameter
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListOfferingAudits with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListOfferingAuditsOptions model
				listOfferingAuditsOptionsModel := new(catalogmanagementv1.ListOfferingAuditsOptions)
				listOfferingAuditsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listOfferingAuditsOptionsModel.OfferingID = core.StringPtr("testString")
				listOfferingAuditsOptionsModel.Start = core.StringPtr("testString")
				listOfferingAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listOfferingAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listOfferingAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.ListOfferingAudits(listOfferingAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.ListOfferingAudits(listOfferingAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListOfferingAudits(listOfferingAuditsOptions *ListOfferingAuditsOptions)`, func() {
		listOfferingAuditsPath := "/catalogs/testString/offerings/testString/audits"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listOfferingAuditsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// TODO: Add check for lookupnames query parameter
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"start": "Start", "limit": 5, "total_count": 10, "resource_count": 13, "first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}, "prev": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}, "audits": [{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message"}]}`)
				}))
			})
			It(`Invoke ListOfferingAudits successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the ListOfferingAuditsOptions model
				listOfferingAuditsOptionsModel := new(catalogmanagementv1.ListOfferingAuditsOptions)
				listOfferingAuditsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listOfferingAuditsOptionsModel.OfferingID = core.StringPtr("testString")
				listOfferingAuditsOptionsModel.Start = core.StringPtr("testString")
				listOfferingAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listOfferingAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listOfferingAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.ListOfferingAuditsWithContext(ctx, listOfferingAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.ListOfferingAudits(listOfferingAuditsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.ListOfferingAuditsWithContext(ctx, listOfferingAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listOfferingAuditsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// TODO: Add check for lookupnames query parameter
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"start": "Start", "limit": 5, "total_count": 10, "resource_count": 13, "first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}, "prev": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}, "audits": [{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message"}]}`)
				}))
			})
			It(`Invoke ListOfferingAudits successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.ListOfferingAudits(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListOfferingAuditsOptions model
				listOfferingAuditsOptionsModel := new(catalogmanagementv1.ListOfferingAuditsOptions)
				listOfferingAuditsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listOfferingAuditsOptionsModel.OfferingID = core.StringPtr("testString")
				listOfferingAuditsOptionsModel.Start = core.StringPtr("testString")
				listOfferingAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listOfferingAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listOfferingAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.ListOfferingAudits(listOfferingAuditsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListOfferingAudits with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListOfferingAuditsOptions model
				listOfferingAuditsOptionsModel := new(catalogmanagementv1.ListOfferingAuditsOptions)
				listOfferingAuditsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listOfferingAuditsOptionsModel.OfferingID = core.StringPtr("testString")
				listOfferingAuditsOptionsModel.Start = core.StringPtr("testString")
				listOfferingAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listOfferingAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listOfferingAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.ListOfferingAudits(listOfferingAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ListOfferingAuditsOptions model with no property values
				listOfferingAuditsOptionsModelNew := new(catalogmanagementv1.ListOfferingAuditsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.ListOfferingAudits(listOfferingAuditsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListOfferingAudits successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListOfferingAuditsOptions model
				listOfferingAuditsOptionsModel := new(catalogmanagementv1.ListOfferingAuditsOptions)
				listOfferingAuditsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listOfferingAuditsOptionsModel.OfferingID = core.StringPtr("testString")
				listOfferingAuditsOptionsModel.Start = core.StringPtr("testString")
				listOfferingAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listOfferingAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listOfferingAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.ListOfferingAudits(listOfferingAuditsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Test pagination helper method on response`, func() {
			It(`Invoke GetNextStart successfully`, func() {
				responseObject := new(catalogmanagementv1.AuditLogs)
				nextObject := new(catalogmanagementv1.PaginationTokenLink)
				nextObject.Start = core.StringPtr("abc-123")
				responseObject.Next = nextObject
	
				value, err := responseObject.GetNextStart()
				Expect(err).To(BeNil())
				Expect(value).To(Equal(core.StringPtr("abc-123")))
			})
			It(`Invoke GetNextStart without a "Next" property in the response`, func() {
				responseObject := new(catalogmanagementv1.AuditLogs)
	
				value, err := responseObject.GetNextStart()
				Expect(err).To(BeNil())
				Expect(value).To(BeNil())
			})
		})
		Context(`Using mock server endpoint - paginated response`, func() {
			BeforeEach(func() {
				var requestNumber int = 0
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listOfferingAuditsPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					requestNumber++
					if requestNumber == 1 {
						fmt.Fprintf(res, "%s", `{"next":{"start":"1"},"total_count":2,"limit":1,"audits":[{"id":"ID","_rev":"Rev","created":"2019-01-01T12:00:00.000Z","change_type":"ChangeType","target_type":"TargetType","target_id":"TargetID","who_email":"WhoEmail","who_delegate_email":"WhoDelegateEmail","message":"Message"}]}`)
					} else if requestNumber == 2 {
						fmt.Fprintf(res, "%s", `{"total_count":2,"limit":1,"audits":[{"id":"ID","_rev":"Rev","created":"2019-01-01T12:00:00.000Z","change_type":"ChangeType","target_type":"TargetType","target_id":"TargetID","who_email":"WhoEmail","who_delegate_email":"WhoDelegateEmail","message":"Message"}]}`)
					} else {
						res.WriteHeader(400)
					}
				}))
			})
			It(`Use OfferingAuditsPager.GetNext successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				listOfferingAuditsOptionsModel := &catalogmanagementv1.ListOfferingAuditsOptions{
					CatalogIdentifier: core.StringPtr("testString"),
					OfferingID: core.StringPtr("testString"),
					Limit: core.Int64Ptr(int64(10)),
					Lookupnames: core.BoolPtr(true),
				}

				pager, err := catalogManagementService.NewOfferingAuditsPager(listOfferingAuditsOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				var allResults []catalogmanagementv1.AuditLogDigest
				for pager.HasNext() {
					nextPage, err := pager.GetNext()
					Expect(err).To(BeNil())
					Expect(nextPage).ToNot(BeNil())
					allResults = append(allResults, nextPage...)
				}
				Expect(len(allResults)).To(Equal(2))
			})
			It(`Use OfferingAuditsPager.GetAll successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				listOfferingAuditsOptionsModel := &catalogmanagementv1.ListOfferingAuditsOptions{
					CatalogIdentifier: core.StringPtr("testString"),
					OfferingID: core.StringPtr("testString"),
					Limit: core.Int64Ptr(int64(10)),
					Lookupnames: core.BoolPtr(true),
				}

				pager, err := catalogManagementService.NewOfferingAuditsPager(listOfferingAuditsOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				allResults, err := pager.GetAll()
				Expect(err).To(BeNil())
				Expect(allResults).ToNot(BeNil())
				Expect(len(allResults)).To(Equal(2))
			})
		})
	})
	Describe(`GetOfferingAudit(getOfferingAuditOptions *GetOfferingAuditOptions) - Operation response error`, func() {
		getOfferingAuditPath := "/catalogs/testString/offerings/testString/audits/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingAuditPath))
					Expect(req.Method).To(Equal("GET"))
					// TODO: Add check for lookupnames query parameter
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetOfferingAudit with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingAuditOptions model
				getOfferingAuditOptionsModel := new(catalogmanagementv1.GetOfferingAuditOptions)
				getOfferingAuditOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingAuditOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getOfferingAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getOfferingAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetOfferingAudit(getOfferingAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetOfferingAudit(getOfferingAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetOfferingAudit(getOfferingAuditOptions *GetOfferingAuditOptions)`, func() {
		getOfferingAuditPath := "/catalogs/testString/offerings/testString/audits/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingAuditPath))
					Expect(req.Method).To(Equal("GET"))

					// TODO: Add check for lookupnames query parameter
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message", "gid": "Gid", "who_id": "WhoID", "who_name": "WhoName", "who_delegate_id": "WhoDelegateID", "who_delegate_name": "WhoDelegateName", "data": "anyValue"}`)
				}))
			})
			It(`Invoke GetOfferingAudit successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetOfferingAuditOptions model
				getOfferingAuditOptionsModel := new(catalogmanagementv1.GetOfferingAuditOptions)
				getOfferingAuditOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingAuditOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getOfferingAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getOfferingAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetOfferingAuditWithContext(ctx, getOfferingAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetOfferingAudit(getOfferingAuditOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetOfferingAuditWithContext(ctx, getOfferingAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingAuditPath))
					Expect(req.Method).To(Equal("GET"))

					// TODO: Add check for lookupnames query parameter
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message", "gid": "Gid", "who_id": "WhoID", "who_name": "WhoName", "who_delegate_id": "WhoDelegateID", "who_delegate_name": "WhoDelegateName", "data": "anyValue"}`)
				}))
			})
			It(`Invoke GetOfferingAudit successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetOfferingAudit(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetOfferingAuditOptions model
				getOfferingAuditOptionsModel := new(catalogmanagementv1.GetOfferingAuditOptions)
				getOfferingAuditOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingAuditOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getOfferingAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getOfferingAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetOfferingAudit(getOfferingAuditOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetOfferingAudit with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingAuditOptions model
				getOfferingAuditOptionsModel := new(catalogmanagementv1.GetOfferingAuditOptions)
				getOfferingAuditOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingAuditOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getOfferingAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getOfferingAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetOfferingAudit(getOfferingAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetOfferingAuditOptions model with no property values
				getOfferingAuditOptionsModelNew := new(catalogmanagementv1.GetOfferingAuditOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetOfferingAudit(getOfferingAuditOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetOfferingAudit successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingAuditOptions model
				getOfferingAuditOptionsModel := new(catalogmanagementv1.GetOfferingAuditOptions)
				getOfferingAuditOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingAuditOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getOfferingAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getOfferingAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetOfferingAudit(getOfferingAuditOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`SetOfferingPublish(setOfferingPublishOptions *SetOfferingPublishOptions) - Operation response error`, func() {
		setOfferingPublishPath := "/catalogs/testString/offerings/testString/publish/pc_managed/true"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(setOfferingPublishPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["X-Approver-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Approver-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["portal_record"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["portal_url"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke SetOfferingPublish with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the SetOfferingPublishOptions model
				setOfferingPublishOptionsModel := new(catalogmanagementv1.SetOfferingPublishOptions)
				setOfferingPublishOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				setOfferingPublishOptionsModel.OfferingID = core.StringPtr("testString")
				setOfferingPublishOptionsModel.ApprovalType = core.StringPtr("pc_managed")
				setOfferingPublishOptionsModel.Approved = core.StringPtr("true")
				setOfferingPublishOptionsModel.PortalRecord = core.StringPtr("testString")
				setOfferingPublishOptionsModel.PortalURL = core.StringPtr("testString")
				setOfferingPublishOptionsModel.XApproverToken = core.StringPtr("testString")
				setOfferingPublishOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.SetOfferingPublish(setOfferingPublishOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.SetOfferingPublish(setOfferingPublishOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`SetOfferingPublish(setOfferingPublishOptions *SetOfferingPublishOptions)`, func() {
		setOfferingPublishPath := "/catalogs/testString/offerings/testString/publish/pc_managed/true"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(setOfferingPublishPath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["X-Approver-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Approver-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["portal_record"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["portal_url"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"shared": true, "ibm": false, "public": true, "allow_request": true, "approved": true, "portal_record": "PortalRecord", "portal_url": "PortalURL", "changed": false}`)
				}))
			})
			It(`Invoke SetOfferingPublish successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the SetOfferingPublishOptions model
				setOfferingPublishOptionsModel := new(catalogmanagementv1.SetOfferingPublishOptions)
				setOfferingPublishOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				setOfferingPublishOptionsModel.OfferingID = core.StringPtr("testString")
				setOfferingPublishOptionsModel.ApprovalType = core.StringPtr("pc_managed")
				setOfferingPublishOptionsModel.Approved = core.StringPtr("true")
				setOfferingPublishOptionsModel.PortalRecord = core.StringPtr("testString")
				setOfferingPublishOptionsModel.PortalURL = core.StringPtr("testString")
				setOfferingPublishOptionsModel.XApproverToken = core.StringPtr("testString")
				setOfferingPublishOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.SetOfferingPublishWithContext(ctx, setOfferingPublishOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.SetOfferingPublish(setOfferingPublishOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.SetOfferingPublishWithContext(ctx, setOfferingPublishOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(setOfferingPublishPath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["X-Approver-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Approver-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["portal_record"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["portal_url"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"shared": true, "ibm": false, "public": true, "allow_request": true, "approved": true, "portal_record": "PortalRecord", "portal_url": "PortalURL", "changed": false}`)
				}))
			})
			It(`Invoke SetOfferingPublish successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.SetOfferingPublish(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the SetOfferingPublishOptions model
				setOfferingPublishOptionsModel := new(catalogmanagementv1.SetOfferingPublishOptions)
				setOfferingPublishOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				setOfferingPublishOptionsModel.OfferingID = core.StringPtr("testString")
				setOfferingPublishOptionsModel.ApprovalType = core.StringPtr("pc_managed")
				setOfferingPublishOptionsModel.Approved = core.StringPtr("true")
				setOfferingPublishOptionsModel.PortalRecord = core.StringPtr("testString")
				setOfferingPublishOptionsModel.PortalURL = core.StringPtr("testString")
				setOfferingPublishOptionsModel.XApproverToken = core.StringPtr("testString")
				setOfferingPublishOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.SetOfferingPublish(setOfferingPublishOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke SetOfferingPublish with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the SetOfferingPublishOptions model
				setOfferingPublishOptionsModel := new(catalogmanagementv1.SetOfferingPublishOptions)
				setOfferingPublishOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				setOfferingPublishOptionsModel.OfferingID = core.StringPtr("testString")
				setOfferingPublishOptionsModel.ApprovalType = core.StringPtr("pc_managed")
				setOfferingPublishOptionsModel.Approved = core.StringPtr("true")
				setOfferingPublishOptionsModel.PortalRecord = core.StringPtr("testString")
				setOfferingPublishOptionsModel.PortalURL = core.StringPtr("testString")
				setOfferingPublishOptionsModel.XApproverToken = core.StringPtr("testString")
				setOfferingPublishOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.SetOfferingPublish(setOfferingPublishOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the SetOfferingPublishOptions model with no property values
				setOfferingPublishOptionsModelNew := new(catalogmanagementv1.SetOfferingPublishOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.SetOfferingPublish(setOfferingPublishOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke SetOfferingPublish successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the SetOfferingPublishOptions model
				setOfferingPublishOptionsModel := new(catalogmanagementv1.SetOfferingPublishOptions)
				setOfferingPublishOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				setOfferingPublishOptionsModel.OfferingID = core.StringPtr("testString")
				setOfferingPublishOptionsModel.ApprovalType = core.StringPtr("pc_managed")
				setOfferingPublishOptionsModel.Approved = core.StringPtr("true")
				setOfferingPublishOptionsModel.PortalRecord = core.StringPtr("testString")
				setOfferingPublishOptionsModel.PortalURL = core.StringPtr("testString")
				setOfferingPublishOptionsModel.XApproverToken = core.StringPtr("testString")
				setOfferingPublishOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.SetOfferingPublish(setOfferingPublishOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeprecateOffering(deprecateOfferingOptions *DeprecateOfferingOptions)`, func() {
		deprecateOfferingPath := "/catalogs/testString/offerings/testString/deprecate/true"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deprecateOfferingPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					res.WriteHeader(202)
				}))
			})
			It(`Invoke DeprecateOffering successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.DeprecateOffering(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeprecateOfferingOptions model
				deprecateOfferingOptionsModel := new(catalogmanagementv1.DeprecateOfferingOptions)
				deprecateOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				deprecateOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				deprecateOfferingOptionsModel.Setting = core.StringPtr("true")
				deprecateOfferingOptionsModel.Description = core.StringPtr("testString")
				deprecateOfferingOptionsModel.DaysUntilDeprecate = core.Int64Ptr(int64(38))
				deprecateOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.DeprecateOffering(deprecateOfferingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeprecateOffering with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the DeprecateOfferingOptions model
				deprecateOfferingOptionsModel := new(catalogmanagementv1.DeprecateOfferingOptions)
				deprecateOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				deprecateOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				deprecateOfferingOptionsModel.Setting = core.StringPtr("true")
				deprecateOfferingOptionsModel.Description = core.StringPtr("testString")
				deprecateOfferingOptionsModel.DaysUntilDeprecate = core.Int64Ptr(int64(38))
				deprecateOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.DeprecateOffering(deprecateOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeprecateOfferingOptions model with no property values
				deprecateOfferingOptionsModelNew := new(catalogmanagementv1.DeprecateOfferingOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.DeprecateOffering(deprecateOfferingOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ShareOffering(shareOfferingOptions *ShareOfferingOptions) - Operation response error`, func() {
		shareOfferingPath := "/catalogs/testString/offerings/testString/share"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(shareOfferingPath))
					Expect(req.Method).To(Equal("POST"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ShareOffering with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ShareOfferingOptions model
				shareOfferingOptionsModel := new(catalogmanagementv1.ShareOfferingOptions)
				shareOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				shareOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				shareOfferingOptionsModel.IBM = core.BoolPtr(true)
				shareOfferingOptionsModel.Public = core.BoolPtr(true)
				shareOfferingOptionsModel.Enabled = core.BoolPtr(true)
				shareOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.ShareOffering(shareOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.ShareOffering(shareOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ShareOffering(shareOfferingOptions *ShareOfferingOptions)`, func() {
		shareOfferingPath := "/catalogs/testString/offerings/testString/share"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(shareOfferingPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"ibm": false, "public": true, "enabled": false}`)
				}))
			})
			It(`Invoke ShareOffering successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the ShareOfferingOptions model
				shareOfferingOptionsModel := new(catalogmanagementv1.ShareOfferingOptions)
				shareOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				shareOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				shareOfferingOptionsModel.IBM = core.BoolPtr(true)
				shareOfferingOptionsModel.Public = core.BoolPtr(true)
				shareOfferingOptionsModel.Enabled = core.BoolPtr(true)
				shareOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.ShareOfferingWithContext(ctx, shareOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.ShareOffering(shareOfferingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.ShareOfferingWithContext(ctx, shareOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(shareOfferingPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"ibm": false, "public": true, "enabled": false}`)
				}))
			})
			It(`Invoke ShareOffering successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.ShareOffering(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ShareOfferingOptions model
				shareOfferingOptionsModel := new(catalogmanagementv1.ShareOfferingOptions)
				shareOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				shareOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				shareOfferingOptionsModel.IBM = core.BoolPtr(true)
				shareOfferingOptionsModel.Public = core.BoolPtr(true)
				shareOfferingOptionsModel.Enabled = core.BoolPtr(true)
				shareOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.ShareOffering(shareOfferingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ShareOffering with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ShareOfferingOptions model
				shareOfferingOptionsModel := new(catalogmanagementv1.ShareOfferingOptions)
				shareOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				shareOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				shareOfferingOptionsModel.IBM = core.BoolPtr(true)
				shareOfferingOptionsModel.Public = core.BoolPtr(true)
				shareOfferingOptionsModel.Enabled = core.BoolPtr(true)
				shareOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.ShareOffering(shareOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ShareOfferingOptions model with no property values
				shareOfferingOptionsModelNew := new(catalogmanagementv1.ShareOfferingOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.ShareOffering(shareOfferingOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ShareOffering successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ShareOfferingOptions model
				shareOfferingOptionsModel := new(catalogmanagementv1.ShareOfferingOptions)
				shareOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				shareOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				shareOfferingOptionsModel.IBM = core.BoolPtr(true)
				shareOfferingOptionsModel.Public = core.BoolPtr(true)
				shareOfferingOptionsModel.Enabled = core.BoolPtr(true)
				shareOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.ShareOffering(shareOfferingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetOfferingAccess(getOfferingAccessOptions *GetOfferingAccessOptions) - Operation response error`, func() {
		getOfferingAccessPath := "/catalogs/testString/offerings/testString/access/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingAccessPath))
					Expect(req.Method).To(Equal("GET"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetOfferingAccess with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingAccessOptions model
				getOfferingAccessOptionsModel := new(catalogmanagementv1.GetOfferingAccessOptions)
				getOfferingAccessOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingAccessOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingAccessOptionsModel.AccessIdentifier = core.StringPtr("testString")
				getOfferingAccessOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetOfferingAccess(getOfferingAccessOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetOfferingAccess(getOfferingAccessOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetOfferingAccess(getOfferingAccessOptions *GetOfferingAccessOptions)`, func() {
		getOfferingAccessPath := "/catalogs/testString/offerings/testString/access/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingAccessPath))
					Expect(req.Method).To(Equal("GET"))

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "account": "Account", "account_type": 11, "catalog_id": "CatalogID", "target_id": "TargetID", "target_account": "TargetAccount", "target_kind": "TargetKind", "private_accessible": false, "created": "2019-01-01T12:00:00.000Z"}`)
				}))
			})
			It(`Invoke GetOfferingAccess successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetOfferingAccessOptions model
				getOfferingAccessOptionsModel := new(catalogmanagementv1.GetOfferingAccessOptions)
				getOfferingAccessOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingAccessOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingAccessOptionsModel.AccessIdentifier = core.StringPtr("testString")
				getOfferingAccessOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetOfferingAccessWithContext(ctx, getOfferingAccessOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetOfferingAccess(getOfferingAccessOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetOfferingAccessWithContext(ctx, getOfferingAccessOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingAccessPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "account": "Account", "account_type": 11, "catalog_id": "CatalogID", "target_id": "TargetID", "target_account": "TargetAccount", "target_kind": "TargetKind", "private_accessible": false, "created": "2019-01-01T12:00:00.000Z"}`)
				}))
			})
			It(`Invoke GetOfferingAccess successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetOfferingAccess(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetOfferingAccessOptions model
				getOfferingAccessOptionsModel := new(catalogmanagementv1.GetOfferingAccessOptions)
				getOfferingAccessOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingAccessOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingAccessOptionsModel.AccessIdentifier = core.StringPtr("testString")
				getOfferingAccessOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetOfferingAccess(getOfferingAccessOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetOfferingAccess with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingAccessOptions model
				getOfferingAccessOptionsModel := new(catalogmanagementv1.GetOfferingAccessOptions)
				getOfferingAccessOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingAccessOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingAccessOptionsModel.AccessIdentifier = core.StringPtr("testString")
				getOfferingAccessOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetOfferingAccess(getOfferingAccessOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetOfferingAccessOptions model with no property values
				getOfferingAccessOptionsModelNew := new(catalogmanagementv1.GetOfferingAccessOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetOfferingAccess(getOfferingAccessOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetOfferingAccess successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingAccessOptions model
				getOfferingAccessOptionsModel := new(catalogmanagementv1.GetOfferingAccessOptions)
				getOfferingAccessOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingAccessOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingAccessOptionsModel.AccessIdentifier = core.StringPtr("testString")
				getOfferingAccessOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetOfferingAccess(getOfferingAccessOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetOfferingAccessList(getOfferingAccessListOptions *GetOfferingAccessListOptions) - Operation response error`, func() {
		getOfferingAccessListPath := "/catalogs/testString/offerings/testString/access"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingAccessListPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetOfferingAccessList with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingAccessListOptions model
				getOfferingAccessListOptionsModel := new(catalogmanagementv1.GetOfferingAccessListOptions)
				getOfferingAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingAccessListOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingAccessListOptionsModel.Start = core.StringPtr("testString")
				getOfferingAccessListOptionsModel.Limit = core.Int64Ptr(int64(10))
				getOfferingAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetOfferingAccessList(getOfferingAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetOfferingAccessList(getOfferingAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetOfferingAccessList(getOfferingAccessListOptions *GetOfferingAccessListOptions)`, func() {
		getOfferingAccessListPath := "/catalogs/testString/offerings/testString/access"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingAccessListPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"start": "Start", "limit": 5, "total_count": 10, "resource_count": 13, "first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}, "prev": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}, "resources": [{"id": "ID", "account": "Account", "account_type": 11, "catalog_id": "CatalogID", "target_id": "TargetID", "target_account": "TargetAccount", "target_kind": "TargetKind", "private_accessible": false, "created": "2019-01-01T12:00:00.000Z"}]}`)
				}))
			})
			It(`Invoke GetOfferingAccessList successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetOfferingAccessListOptions model
				getOfferingAccessListOptionsModel := new(catalogmanagementv1.GetOfferingAccessListOptions)
				getOfferingAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingAccessListOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingAccessListOptionsModel.Start = core.StringPtr("testString")
				getOfferingAccessListOptionsModel.Limit = core.Int64Ptr(int64(10))
				getOfferingAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetOfferingAccessListWithContext(ctx, getOfferingAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetOfferingAccessList(getOfferingAccessListOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetOfferingAccessListWithContext(ctx, getOfferingAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingAccessListPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"start": "Start", "limit": 5, "total_count": 10, "resource_count": 13, "first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}, "prev": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}, "resources": [{"id": "ID", "account": "Account", "account_type": 11, "catalog_id": "CatalogID", "target_id": "TargetID", "target_account": "TargetAccount", "target_kind": "TargetKind", "private_accessible": false, "created": "2019-01-01T12:00:00.000Z"}]}`)
				}))
			})
			It(`Invoke GetOfferingAccessList successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetOfferingAccessList(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetOfferingAccessListOptions model
				getOfferingAccessListOptionsModel := new(catalogmanagementv1.GetOfferingAccessListOptions)
				getOfferingAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingAccessListOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingAccessListOptionsModel.Start = core.StringPtr("testString")
				getOfferingAccessListOptionsModel.Limit = core.Int64Ptr(int64(10))
				getOfferingAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetOfferingAccessList(getOfferingAccessListOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetOfferingAccessList with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingAccessListOptions model
				getOfferingAccessListOptionsModel := new(catalogmanagementv1.GetOfferingAccessListOptions)
				getOfferingAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingAccessListOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingAccessListOptionsModel.Start = core.StringPtr("testString")
				getOfferingAccessListOptionsModel.Limit = core.Int64Ptr(int64(10))
				getOfferingAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetOfferingAccessList(getOfferingAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetOfferingAccessListOptions model with no property values
				getOfferingAccessListOptionsModelNew := new(catalogmanagementv1.GetOfferingAccessListOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetOfferingAccessList(getOfferingAccessListOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetOfferingAccessList successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingAccessListOptions model
				getOfferingAccessListOptionsModel := new(catalogmanagementv1.GetOfferingAccessListOptions)
				getOfferingAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingAccessListOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingAccessListOptionsModel.Start = core.StringPtr("testString")
				getOfferingAccessListOptionsModel.Limit = core.Int64Ptr(int64(10))
				getOfferingAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetOfferingAccessList(getOfferingAccessListOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Test pagination helper method on response`, func() {
			It(`Invoke GetNextStart successfully`, func() {
				responseObject := new(catalogmanagementv1.AccessListResult)
				nextObject := new(catalogmanagementv1.PaginationTokenLink)
				nextObject.Start = core.StringPtr("abc-123")
				responseObject.Next = nextObject
	
				value, err := responseObject.GetNextStart()
				Expect(err).To(BeNil())
				Expect(value).To(Equal(core.StringPtr("abc-123")))
			})
			It(`Invoke GetNextStart without a "Next" property in the response`, func() {
				responseObject := new(catalogmanagementv1.AccessListResult)
	
				value, err := responseObject.GetNextStart()
				Expect(err).To(BeNil())
				Expect(value).To(BeNil())
			})
		})
		Context(`Using mock server endpoint - paginated response`, func() {
			BeforeEach(func() {
				var requestNumber int = 0
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingAccessListPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					requestNumber++
					if requestNumber == 1 {
						fmt.Fprintf(res, "%s", `{"next":{"start":"1"},"total_count":2,"limit":1,"resources":[{"id":"ID","account":"Account","account_type":11,"catalog_id":"CatalogID","target_id":"TargetID","target_account":"TargetAccount","target_kind":"TargetKind","private_accessible":false,"created":"2019-01-01T12:00:00.000Z"}]}`)
					} else if requestNumber == 2 {
						fmt.Fprintf(res, "%s", `{"total_count":2,"limit":1,"resources":[{"id":"ID","account":"Account","account_type":11,"catalog_id":"CatalogID","target_id":"TargetID","target_account":"TargetAccount","target_kind":"TargetKind","private_accessible":false,"created":"2019-01-01T12:00:00.000Z"}]}`)
					} else {
						res.WriteHeader(400)
					}
				}))
			})
			It(`Use GetOfferingAccessListPager.GetNext successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				getOfferingAccessListOptionsModel := &catalogmanagementv1.GetOfferingAccessListOptions{
					CatalogIdentifier: core.StringPtr("testString"),
					OfferingID: core.StringPtr("testString"),
					Limit: core.Int64Ptr(int64(10)),
				}

				pager, err := catalogManagementService.NewGetOfferingAccessListPager(getOfferingAccessListOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				var allResults []catalogmanagementv1.Access
				for pager.HasNext() {
					nextPage, err := pager.GetNext()
					Expect(err).To(BeNil())
					Expect(nextPage).ToNot(BeNil())
					allResults = append(allResults, nextPage...)
				}
				Expect(len(allResults)).To(Equal(2))
			})
			It(`Use GetOfferingAccessListPager.GetAll successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				getOfferingAccessListOptionsModel := &catalogmanagementv1.GetOfferingAccessListOptions{
					CatalogIdentifier: core.StringPtr("testString"),
					OfferingID: core.StringPtr("testString"),
					Limit: core.Int64Ptr(int64(10)),
				}

				pager, err := catalogManagementService.NewGetOfferingAccessListPager(getOfferingAccessListOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				allResults, err := pager.GetAll()
				Expect(err).To(BeNil())
				Expect(allResults).ToNot(BeNil())
				Expect(len(allResults)).To(Equal(2))
			})
		})
	})
	Describe(`DeleteOfferingAccessList(deleteOfferingAccessListOptions *DeleteOfferingAccessListOptions) - Operation response error`, func() {
		deleteOfferingAccessListPath := "/catalogs/testString/offerings/testString/access"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteOfferingAccessListPath))
					Expect(req.Method).To(Equal("DELETE"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke DeleteOfferingAccessList with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the DeleteOfferingAccessListOptions model
				deleteOfferingAccessListOptionsModel := new(catalogmanagementv1.DeleteOfferingAccessListOptions)
				deleteOfferingAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				deleteOfferingAccessListOptionsModel.OfferingID = core.StringPtr("testString")
				deleteOfferingAccessListOptionsModel.Accesses = []string{"testString"}
				deleteOfferingAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.DeleteOfferingAccessList(deleteOfferingAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.DeleteOfferingAccessList(deleteOfferingAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteOfferingAccessList(deleteOfferingAccessListOptions *DeleteOfferingAccessListOptions)`, func() {
		deleteOfferingAccessListPath := "/catalogs/testString/offerings/testString/access"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteOfferingAccessListPath))
					Expect(req.Method).To(Equal("DELETE"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"errors": {"mapKey": "Inner"}}`)
				}))
			})
			It(`Invoke DeleteOfferingAccessList successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the DeleteOfferingAccessListOptions model
				deleteOfferingAccessListOptionsModel := new(catalogmanagementv1.DeleteOfferingAccessListOptions)
				deleteOfferingAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				deleteOfferingAccessListOptionsModel.OfferingID = core.StringPtr("testString")
				deleteOfferingAccessListOptionsModel.Accesses = []string{"testString"}
				deleteOfferingAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.DeleteOfferingAccessListWithContext(ctx, deleteOfferingAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.DeleteOfferingAccessList(deleteOfferingAccessListOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.DeleteOfferingAccessListWithContext(ctx, deleteOfferingAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteOfferingAccessListPath))
					Expect(req.Method).To(Equal("DELETE"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"errors": {"mapKey": "Inner"}}`)
				}))
			})
			It(`Invoke DeleteOfferingAccessList successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.DeleteOfferingAccessList(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the DeleteOfferingAccessListOptions model
				deleteOfferingAccessListOptionsModel := new(catalogmanagementv1.DeleteOfferingAccessListOptions)
				deleteOfferingAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				deleteOfferingAccessListOptionsModel.OfferingID = core.StringPtr("testString")
				deleteOfferingAccessListOptionsModel.Accesses = []string{"testString"}
				deleteOfferingAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.DeleteOfferingAccessList(deleteOfferingAccessListOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke DeleteOfferingAccessList with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the DeleteOfferingAccessListOptions model
				deleteOfferingAccessListOptionsModel := new(catalogmanagementv1.DeleteOfferingAccessListOptions)
				deleteOfferingAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				deleteOfferingAccessListOptionsModel.OfferingID = core.StringPtr("testString")
				deleteOfferingAccessListOptionsModel.Accesses = []string{"testString"}
				deleteOfferingAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.DeleteOfferingAccessList(deleteOfferingAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the DeleteOfferingAccessListOptions model with no property values
				deleteOfferingAccessListOptionsModelNew := new(catalogmanagementv1.DeleteOfferingAccessListOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.DeleteOfferingAccessList(deleteOfferingAccessListOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke DeleteOfferingAccessList successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the DeleteOfferingAccessListOptions model
				deleteOfferingAccessListOptionsModel := new(catalogmanagementv1.DeleteOfferingAccessListOptions)
				deleteOfferingAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				deleteOfferingAccessListOptionsModel.OfferingID = core.StringPtr("testString")
				deleteOfferingAccessListOptionsModel.Accesses = []string{"testString"}
				deleteOfferingAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.DeleteOfferingAccessList(deleteOfferingAccessListOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`AddOfferingAccessList(addOfferingAccessListOptions *AddOfferingAccessListOptions) - Operation response error`, func() {
		addOfferingAccessListPath := "/catalogs/testString/offerings/testString/access"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(addOfferingAccessListPath))
					Expect(req.Method).To(Equal("POST"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke AddOfferingAccessList with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the AddOfferingAccessListOptions model
				addOfferingAccessListOptionsModel := new(catalogmanagementv1.AddOfferingAccessListOptions)
				addOfferingAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				addOfferingAccessListOptionsModel.OfferingID = core.StringPtr("testString")
				addOfferingAccessListOptionsModel.Accesses = []string{"testString"}
				addOfferingAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.AddOfferingAccessList(addOfferingAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.AddOfferingAccessList(addOfferingAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`AddOfferingAccessList(addOfferingAccessListOptions *AddOfferingAccessListOptions)`, func() {
		addOfferingAccessListPath := "/catalogs/testString/offerings/testString/access"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(addOfferingAccessListPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"start": "Start", "limit": 5, "total_count": 10, "resource_count": 13, "first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}, "prev": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}, "resources": [{"id": "ID", "account": "Account", "account_type": 11, "catalog_id": "CatalogID", "target_id": "TargetID", "target_account": "TargetAccount", "target_kind": "TargetKind", "private_accessible": false, "created": "2019-01-01T12:00:00.000Z"}]}`)
				}))
			})
			It(`Invoke AddOfferingAccessList successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the AddOfferingAccessListOptions model
				addOfferingAccessListOptionsModel := new(catalogmanagementv1.AddOfferingAccessListOptions)
				addOfferingAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				addOfferingAccessListOptionsModel.OfferingID = core.StringPtr("testString")
				addOfferingAccessListOptionsModel.Accesses = []string{"testString"}
				addOfferingAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.AddOfferingAccessListWithContext(ctx, addOfferingAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.AddOfferingAccessList(addOfferingAccessListOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.AddOfferingAccessListWithContext(ctx, addOfferingAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(addOfferingAccessListPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"start": "Start", "limit": 5, "total_count": 10, "resource_count": 13, "first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}, "prev": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}, "resources": [{"id": "ID", "account": "Account", "account_type": 11, "catalog_id": "CatalogID", "target_id": "TargetID", "target_account": "TargetAccount", "target_kind": "TargetKind", "private_accessible": false, "created": "2019-01-01T12:00:00.000Z"}]}`)
				}))
			})
			It(`Invoke AddOfferingAccessList successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.AddOfferingAccessList(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the AddOfferingAccessListOptions model
				addOfferingAccessListOptionsModel := new(catalogmanagementv1.AddOfferingAccessListOptions)
				addOfferingAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				addOfferingAccessListOptionsModel.OfferingID = core.StringPtr("testString")
				addOfferingAccessListOptionsModel.Accesses = []string{"testString"}
				addOfferingAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.AddOfferingAccessList(addOfferingAccessListOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke AddOfferingAccessList with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the AddOfferingAccessListOptions model
				addOfferingAccessListOptionsModel := new(catalogmanagementv1.AddOfferingAccessListOptions)
				addOfferingAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				addOfferingAccessListOptionsModel.OfferingID = core.StringPtr("testString")
				addOfferingAccessListOptionsModel.Accesses = []string{"testString"}
				addOfferingAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.AddOfferingAccessList(addOfferingAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the AddOfferingAccessListOptions model with no property values
				addOfferingAccessListOptionsModelNew := new(catalogmanagementv1.AddOfferingAccessListOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.AddOfferingAccessList(addOfferingAccessListOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke AddOfferingAccessList successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the AddOfferingAccessListOptions model
				addOfferingAccessListOptionsModel := new(catalogmanagementv1.AddOfferingAccessListOptions)
				addOfferingAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				addOfferingAccessListOptionsModel.OfferingID = core.StringPtr("testString")
				addOfferingAccessListOptionsModel.Accesses = []string{"testString"}
				addOfferingAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.AddOfferingAccessList(addOfferingAccessListOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetOfferingUpdates(getOfferingUpdatesOptions *GetOfferingUpdatesOptions) - Operation response error`, func() {
		getOfferingUpdatesPath := "/catalogs/testString/offerings/testString/updates"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingUpdatesPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["kind"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["target"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["version"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["cluster_id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["region"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["resource_group_id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["namespace"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["sha"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["channel"]).To(Equal([]string{"testString"}))
					// TODO: Add check for all_namespaces query parameter
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetOfferingUpdates with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingUpdatesOptions model
				getOfferingUpdatesOptionsModel := new(catalogmanagementv1.GetOfferingUpdatesOptions)
				getOfferingUpdatesOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Kind = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Target = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Version = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.ClusterID = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Region = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.ResourceGroupID = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Namespace = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Sha = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Channel = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Namespaces = []string{"testString"}
				getOfferingUpdatesOptionsModel.AllNamespaces = core.BoolPtr(true)
				getOfferingUpdatesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetOfferingUpdates(getOfferingUpdatesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetOfferingUpdates(getOfferingUpdatesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetOfferingUpdates(getOfferingUpdatesOptions *GetOfferingUpdatesOptions)`, func() {
		getOfferingUpdatesPath := "/catalogs/testString/offerings/testString/updates"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingUpdatesPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["kind"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["target"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["version"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["cluster_id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["region"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["resource_group_id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["namespace"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["sha"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["channel"]).To(Equal([]string{"testString"}))
					// TODO: Add check for all_namespaces query parameter
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `[{"version_locator": "VersionLocator", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "package_version": "PackageVersion", "sha": "Sha", "can_update": false, "messages": {"mapKey": "Inner"}}]`)
				}))
			})
			It(`Invoke GetOfferingUpdates successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetOfferingUpdatesOptions model
				getOfferingUpdatesOptionsModel := new(catalogmanagementv1.GetOfferingUpdatesOptions)
				getOfferingUpdatesOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Kind = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Target = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Version = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.ClusterID = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Region = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.ResourceGroupID = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Namespace = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Sha = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Channel = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Namespaces = []string{"testString"}
				getOfferingUpdatesOptionsModel.AllNamespaces = core.BoolPtr(true)
				getOfferingUpdatesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetOfferingUpdatesWithContext(ctx, getOfferingUpdatesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetOfferingUpdates(getOfferingUpdatesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetOfferingUpdatesWithContext(ctx, getOfferingUpdatesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingUpdatesPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["kind"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["target"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["version"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["cluster_id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["region"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["resource_group_id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["namespace"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["sha"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["channel"]).To(Equal([]string{"testString"}))
					// TODO: Add check for all_namespaces query parameter
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `[{"version_locator": "VersionLocator", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "package_version": "PackageVersion", "sha": "Sha", "can_update": false, "messages": {"mapKey": "Inner"}}]`)
				}))
			})
			It(`Invoke GetOfferingUpdates successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetOfferingUpdates(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetOfferingUpdatesOptions model
				getOfferingUpdatesOptionsModel := new(catalogmanagementv1.GetOfferingUpdatesOptions)
				getOfferingUpdatesOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Kind = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Target = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Version = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.ClusterID = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Region = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.ResourceGroupID = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Namespace = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Sha = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Channel = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Namespaces = []string{"testString"}
				getOfferingUpdatesOptionsModel.AllNamespaces = core.BoolPtr(true)
				getOfferingUpdatesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetOfferingUpdates(getOfferingUpdatesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetOfferingUpdates with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingUpdatesOptions model
				getOfferingUpdatesOptionsModel := new(catalogmanagementv1.GetOfferingUpdatesOptions)
				getOfferingUpdatesOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Kind = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Target = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Version = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.ClusterID = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Region = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.ResourceGroupID = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Namespace = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Sha = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Channel = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Namespaces = []string{"testString"}
				getOfferingUpdatesOptionsModel.AllNamespaces = core.BoolPtr(true)
				getOfferingUpdatesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetOfferingUpdates(getOfferingUpdatesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetOfferingUpdatesOptions model with no property values
				getOfferingUpdatesOptionsModelNew := new(catalogmanagementv1.GetOfferingUpdatesOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetOfferingUpdates(getOfferingUpdatesOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetOfferingUpdates successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingUpdatesOptions model
				getOfferingUpdatesOptionsModel := new(catalogmanagementv1.GetOfferingUpdatesOptions)
				getOfferingUpdatesOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Kind = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Target = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Version = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.ClusterID = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Region = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.ResourceGroupID = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Namespace = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Sha = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Channel = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Namespaces = []string{"testString"}
				getOfferingUpdatesOptionsModel.AllNamespaces = core.BoolPtr(true)
				getOfferingUpdatesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetOfferingUpdates(getOfferingUpdatesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetOfferingSource(getOfferingSourceOptions *GetOfferingSourceOptions)`, func() {
		getOfferingSourcePath := "/offering/source"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingSourcePath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Accept"]).ToNot(BeNil())
					Expect(req.Header["Accept"][0]).To(Equal(fmt.Sprintf("%v", "application/yaml")))
					Expect(req.URL.Query()["version"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["catalogID"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["name"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["kind"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["channel"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/yaml")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `This is a mock binary response.`)
				}))
			})
			It(`Invoke GetOfferingSource successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetOfferingSourceOptions model
				getOfferingSourceOptionsModel := new(catalogmanagementv1.GetOfferingSourceOptions)
				getOfferingSourceOptionsModel.Version = core.StringPtr("testString")
				getOfferingSourceOptionsModel.Accept = core.StringPtr("application/yaml")
				getOfferingSourceOptionsModel.CatalogID = core.StringPtr("testString")
				getOfferingSourceOptionsModel.Name = core.StringPtr("testString")
				getOfferingSourceOptionsModel.ID = core.StringPtr("testString")
				getOfferingSourceOptionsModel.Kind = core.StringPtr("testString")
				getOfferingSourceOptionsModel.Channel = core.StringPtr("testString")
				getOfferingSourceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetOfferingSourceWithContext(ctx, getOfferingSourceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetOfferingSource(getOfferingSourceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetOfferingSourceWithContext(ctx, getOfferingSourceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingSourcePath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Accept"]).ToNot(BeNil())
					Expect(req.Header["Accept"][0]).To(Equal(fmt.Sprintf("%v", "application/yaml")))
					Expect(req.URL.Query()["version"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["catalogID"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["name"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["kind"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["channel"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/yaml")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `This is a mock binary response.`)
				}))
			})
			It(`Invoke GetOfferingSource successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetOfferingSource(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetOfferingSourceOptions model
				getOfferingSourceOptionsModel := new(catalogmanagementv1.GetOfferingSourceOptions)
				getOfferingSourceOptionsModel.Version = core.StringPtr("testString")
				getOfferingSourceOptionsModel.Accept = core.StringPtr("application/yaml")
				getOfferingSourceOptionsModel.CatalogID = core.StringPtr("testString")
				getOfferingSourceOptionsModel.Name = core.StringPtr("testString")
				getOfferingSourceOptionsModel.ID = core.StringPtr("testString")
				getOfferingSourceOptionsModel.Kind = core.StringPtr("testString")
				getOfferingSourceOptionsModel.Channel = core.StringPtr("testString")
				getOfferingSourceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetOfferingSource(getOfferingSourceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetOfferingSource with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingSourceOptions model
				getOfferingSourceOptionsModel := new(catalogmanagementv1.GetOfferingSourceOptions)
				getOfferingSourceOptionsModel.Version = core.StringPtr("testString")
				getOfferingSourceOptionsModel.Accept = core.StringPtr("application/yaml")
				getOfferingSourceOptionsModel.CatalogID = core.StringPtr("testString")
				getOfferingSourceOptionsModel.Name = core.StringPtr("testString")
				getOfferingSourceOptionsModel.ID = core.StringPtr("testString")
				getOfferingSourceOptionsModel.Kind = core.StringPtr("testString")
				getOfferingSourceOptionsModel.Channel = core.StringPtr("testString")
				getOfferingSourceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetOfferingSource(getOfferingSourceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetOfferingSourceOptions model with no property values
				getOfferingSourceOptionsModelNew := new(catalogmanagementv1.GetOfferingSourceOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetOfferingSource(getOfferingSourceOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetOfferingSource successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingSourceOptions model
				getOfferingSourceOptionsModel := new(catalogmanagementv1.GetOfferingSourceOptions)
				getOfferingSourceOptionsModel.Version = core.StringPtr("testString")
				getOfferingSourceOptionsModel.Accept = core.StringPtr("application/yaml")
				getOfferingSourceOptionsModel.CatalogID = core.StringPtr("testString")
				getOfferingSourceOptionsModel.Name = core.StringPtr("testString")
				getOfferingSourceOptionsModel.ID = core.StringPtr("testString")
				getOfferingSourceOptionsModel.Kind = core.StringPtr("testString")
				getOfferingSourceOptionsModel.Channel = core.StringPtr("testString")
				getOfferingSourceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetOfferingSource(getOfferingSourceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())


				// Verify empty byte buffer.
				Expect(result).ToNot(BeNil())
				buffer, operationErr := io.ReadAll(result)
				Expect(operationErr).To(BeNil())
				Expect(buffer).ToNot(BeNil())
				Expect(len(buffer)).To(Equal(0))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetOfferingSourceURL(getOfferingSourceURLOptions *GetOfferingSourceURLOptions)`, func() {
		getOfferingSourceURLPath := "/offering/source/url/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingSourceURLPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Accept"]).ToNot(BeNil())
					Expect(req.Header["Accept"][0]).To(Equal(fmt.Sprintf("%v", "application/yaml")))
					Expect(req.URL.Query()["catalogID"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["name"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["id"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/yaml")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `This is a mock binary response.`)
				}))
			})
			It(`Invoke GetOfferingSourceURL successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetOfferingSourceURLOptions model
				getOfferingSourceURLOptionsModel := new(catalogmanagementv1.GetOfferingSourceURLOptions)
				getOfferingSourceURLOptionsModel.KeyIdentifier = core.StringPtr("testString")
				getOfferingSourceURLOptionsModel.Accept = core.StringPtr("application/yaml")
				getOfferingSourceURLOptionsModel.CatalogID = core.StringPtr("testString")
				getOfferingSourceURLOptionsModel.Name = core.StringPtr("testString")
				getOfferingSourceURLOptionsModel.ID = core.StringPtr("testString")
				getOfferingSourceURLOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetOfferingSourceURLWithContext(ctx, getOfferingSourceURLOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetOfferingSourceURL(getOfferingSourceURLOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetOfferingSourceURLWithContext(ctx, getOfferingSourceURLOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingSourceURLPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Accept"]).ToNot(BeNil())
					Expect(req.Header["Accept"][0]).To(Equal(fmt.Sprintf("%v", "application/yaml")))
					Expect(req.URL.Query()["catalogID"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["name"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["id"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/yaml")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `This is a mock binary response.`)
				}))
			})
			It(`Invoke GetOfferingSourceURL successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetOfferingSourceURL(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetOfferingSourceURLOptions model
				getOfferingSourceURLOptionsModel := new(catalogmanagementv1.GetOfferingSourceURLOptions)
				getOfferingSourceURLOptionsModel.KeyIdentifier = core.StringPtr("testString")
				getOfferingSourceURLOptionsModel.Accept = core.StringPtr("application/yaml")
				getOfferingSourceURLOptionsModel.CatalogID = core.StringPtr("testString")
				getOfferingSourceURLOptionsModel.Name = core.StringPtr("testString")
				getOfferingSourceURLOptionsModel.ID = core.StringPtr("testString")
				getOfferingSourceURLOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetOfferingSourceURL(getOfferingSourceURLOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetOfferingSourceURL with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingSourceURLOptions model
				getOfferingSourceURLOptionsModel := new(catalogmanagementv1.GetOfferingSourceURLOptions)
				getOfferingSourceURLOptionsModel.KeyIdentifier = core.StringPtr("testString")
				getOfferingSourceURLOptionsModel.Accept = core.StringPtr("application/yaml")
				getOfferingSourceURLOptionsModel.CatalogID = core.StringPtr("testString")
				getOfferingSourceURLOptionsModel.Name = core.StringPtr("testString")
				getOfferingSourceURLOptionsModel.ID = core.StringPtr("testString")
				getOfferingSourceURLOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetOfferingSourceURL(getOfferingSourceURLOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetOfferingSourceURLOptions model with no property values
				getOfferingSourceURLOptionsModelNew := new(catalogmanagementv1.GetOfferingSourceURLOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetOfferingSourceURL(getOfferingSourceURLOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetOfferingSourceURL successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingSourceURLOptions model
				getOfferingSourceURLOptionsModel := new(catalogmanagementv1.GetOfferingSourceURLOptions)
				getOfferingSourceURLOptionsModel.KeyIdentifier = core.StringPtr("testString")
				getOfferingSourceURLOptionsModel.Accept = core.StringPtr("application/yaml")
				getOfferingSourceURLOptionsModel.CatalogID = core.StringPtr("testString")
				getOfferingSourceURLOptionsModel.Name = core.StringPtr("testString")
				getOfferingSourceURLOptionsModel.ID = core.StringPtr("testString")
				getOfferingSourceURLOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetOfferingSourceURL(getOfferingSourceURLOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())


				// Verify empty byte buffer.
				Expect(result).ToNot(BeNil())
				buffer, operationErr := io.ReadAll(result)
				Expect(operationErr).To(BeNil())
				Expect(buffer).ToNot(BeNil())
				Expect(len(buffer)).To(Equal(0))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetOfferingAbout(getOfferingAboutOptions *GetOfferingAboutOptions)`, func() {
		getOfferingAboutPath := "/versions/testString/about"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingAboutPath))
					Expect(req.Method).To(Equal("GET"))

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "text/markdown")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `"OperationResponse"`)
				}))
			})
			It(`Invoke GetOfferingAbout successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetOfferingAboutOptions model
				getOfferingAboutOptionsModel := new(catalogmanagementv1.GetOfferingAboutOptions)
				getOfferingAboutOptionsModel.VersionLocID = core.StringPtr("testString")
				getOfferingAboutOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetOfferingAboutWithContext(ctx, getOfferingAboutOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetOfferingAbout(getOfferingAboutOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetOfferingAboutWithContext(ctx, getOfferingAboutOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingAboutPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "text/markdown")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `"OperationResponse"`)
				}))
			})
			It(`Invoke GetOfferingAbout successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetOfferingAbout(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetOfferingAboutOptions model
				getOfferingAboutOptionsModel := new(catalogmanagementv1.GetOfferingAboutOptions)
				getOfferingAboutOptionsModel.VersionLocID = core.StringPtr("testString")
				getOfferingAboutOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetOfferingAbout(getOfferingAboutOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetOfferingAbout with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingAboutOptions model
				getOfferingAboutOptionsModel := new(catalogmanagementv1.GetOfferingAboutOptions)
				getOfferingAboutOptionsModel.VersionLocID = core.StringPtr("testString")
				getOfferingAboutOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetOfferingAbout(getOfferingAboutOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetOfferingAboutOptions model with no property values
				getOfferingAboutOptionsModelNew := new(catalogmanagementv1.GetOfferingAboutOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetOfferingAbout(getOfferingAboutOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetOfferingAbout successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingAboutOptions model
				getOfferingAboutOptionsModel := new(catalogmanagementv1.GetOfferingAboutOptions)
				getOfferingAboutOptionsModel.VersionLocID = core.StringPtr("testString")
				getOfferingAboutOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetOfferingAbout(getOfferingAboutOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetOfferingLicense(getOfferingLicenseOptions *GetOfferingLicenseOptions)`, func() {
		getOfferingLicensePath := "/versions/testString/licenses/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingLicensePath))
					Expect(req.Method).To(Equal("GET"))

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "text/plain")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `"OperationResponse"`)
				}))
			})
			It(`Invoke GetOfferingLicense successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetOfferingLicenseOptions model
				getOfferingLicenseOptionsModel := new(catalogmanagementv1.GetOfferingLicenseOptions)
				getOfferingLicenseOptionsModel.VersionLocID = core.StringPtr("testString")
				getOfferingLicenseOptionsModel.LicenseID = core.StringPtr("testString")
				getOfferingLicenseOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetOfferingLicenseWithContext(ctx, getOfferingLicenseOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetOfferingLicense(getOfferingLicenseOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetOfferingLicenseWithContext(ctx, getOfferingLicenseOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingLicensePath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "text/plain")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `"OperationResponse"`)
				}))
			})
			It(`Invoke GetOfferingLicense successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetOfferingLicense(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetOfferingLicenseOptions model
				getOfferingLicenseOptionsModel := new(catalogmanagementv1.GetOfferingLicenseOptions)
				getOfferingLicenseOptionsModel.VersionLocID = core.StringPtr("testString")
				getOfferingLicenseOptionsModel.LicenseID = core.StringPtr("testString")
				getOfferingLicenseOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetOfferingLicense(getOfferingLicenseOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetOfferingLicense with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingLicenseOptions model
				getOfferingLicenseOptionsModel := new(catalogmanagementv1.GetOfferingLicenseOptions)
				getOfferingLicenseOptionsModel.VersionLocID = core.StringPtr("testString")
				getOfferingLicenseOptionsModel.LicenseID = core.StringPtr("testString")
				getOfferingLicenseOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetOfferingLicense(getOfferingLicenseOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetOfferingLicenseOptions model with no property values
				getOfferingLicenseOptionsModelNew := new(catalogmanagementv1.GetOfferingLicenseOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetOfferingLicense(getOfferingLicenseOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetOfferingLicense successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingLicenseOptions model
				getOfferingLicenseOptionsModel := new(catalogmanagementv1.GetOfferingLicenseOptions)
				getOfferingLicenseOptionsModel.VersionLocID = core.StringPtr("testString")
				getOfferingLicenseOptionsModel.LicenseID = core.StringPtr("testString")
				getOfferingLicenseOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetOfferingLicense(getOfferingLicenseOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetOfferingContainerImages(getOfferingContainerImagesOptions *GetOfferingContainerImagesOptions) - Operation response error`, func() {
		getOfferingContainerImagesPath := "/versions/testString/containerImages"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingContainerImagesPath))
					Expect(req.Method).To(Equal("GET"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetOfferingContainerImages with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingContainerImagesOptions model
				getOfferingContainerImagesOptionsModel := new(catalogmanagementv1.GetOfferingContainerImagesOptions)
				getOfferingContainerImagesOptionsModel.VersionLocID = core.StringPtr("testString")
				getOfferingContainerImagesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetOfferingContainerImages(getOfferingContainerImagesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetOfferingContainerImages(getOfferingContainerImagesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetOfferingContainerImages(getOfferingContainerImagesOptions *GetOfferingContainerImagesOptions)`, func() {
		getOfferingContainerImagesPath := "/versions/testString/containerImages"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingContainerImagesPath))
					Expect(req.Method).To(Equal("GET"))

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"description": "Description", "images": [{"image": "Image"}]}`)
				}))
			})
			It(`Invoke GetOfferingContainerImages successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetOfferingContainerImagesOptions model
				getOfferingContainerImagesOptionsModel := new(catalogmanagementv1.GetOfferingContainerImagesOptions)
				getOfferingContainerImagesOptionsModel.VersionLocID = core.StringPtr("testString")
				getOfferingContainerImagesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetOfferingContainerImagesWithContext(ctx, getOfferingContainerImagesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetOfferingContainerImages(getOfferingContainerImagesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetOfferingContainerImagesWithContext(ctx, getOfferingContainerImagesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingContainerImagesPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"description": "Description", "images": [{"image": "Image"}]}`)
				}))
			})
			It(`Invoke GetOfferingContainerImages successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetOfferingContainerImages(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetOfferingContainerImagesOptions model
				getOfferingContainerImagesOptionsModel := new(catalogmanagementv1.GetOfferingContainerImagesOptions)
				getOfferingContainerImagesOptionsModel.VersionLocID = core.StringPtr("testString")
				getOfferingContainerImagesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetOfferingContainerImages(getOfferingContainerImagesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetOfferingContainerImages with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingContainerImagesOptions model
				getOfferingContainerImagesOptionsModel := new(catalogmanagementv1.GetOfferingContainerImagesOptions)
				getOfferingContainerImagesOptionsModel.VersionLocID = core.StringPtr("testString")
				getOfferingContainerImagesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetOfferingContainerImages(getOfferingContainerImagesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetOfferingContainerImagesOptions model with no property values
				getOfferingContainerImagesOptionsModelNew := new(catalogmanagementv1.GetOfferingContainerImagesOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetOfferingContainerImages(getOfferingContainerImagesOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetOfferingContainerImages successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingContainerImagesOptions model
				getOfferingContainerImagesOptionsModel := new(catalogmanagementv1.GetOfferingContainerImagesOptions)
				getOfferingContainerImagesOptionsModel.VersionLocID = core.StringPtr("testString")
				getOfferingContainerImagesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetOfferingContainerImages(getOfferingContainerImagesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ArchiveVersion(archiveVersionOptions *ArchiveVersionOptions)`, func() {
		archiveVersionPath := "/versions/testString/archive"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(archiveVersionPath))
					Expect(req.Method).To(Equal("POST"))

					res.WriteHeader(202)
				}))
			})
			It(`Invoke ArchiveVersion successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.ArchiveVersion(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the ArchiveVersionOptions model
				archiveVersionOptionsModel := new(catalogmanagementv1.ArchiveVersionOptions)
				archiveVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				archiveVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.ArchiveVersion(archiveVersionOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke ArchiveVersion with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ArchiveVersionOptions model
				archiveVersionOptionsModel := new(catalogmanagementv1.ArchiveVersionOptions)
				archiveVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				archiveVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.ArchiveVersion(archiveVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the ArchiveVersionOptions model with no property values
				archiveVersionOptionsModelNew := new(catalogmanagementv1.ArchiveVersionOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.ArchiveVersion(archiveVersionOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`SetDeprecateVersion(setDeprecateVersionOptions *SetDeprecateVersionOptions)`, func() {
		setDeprecateVersionPath := "/versions/testString/deprecate/true"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(setDeprecateVersionPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					res.WriteHeader(202)
				}))
			})
			It(`Invoke SetDeprecateVersion successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.SetDeprecateVersion(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the SetDeprecateVersionOptions model
				setDeprecateVersionOptionsModel := new(catalogmanagementv1.SetDeprecateVersionOptions)
				setDeprecateVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				setDeprecateVersionOptionsModel.Setting = core.StringPtr("true")
				setDeprecateVersionOptionsModel.Description = core.StringPtr("testString")
				setDeprecateVersionOptionsModel.DaysUntilDeprecate = core.Int64Ptr(int64(38))
				setDeprecateVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.SetDeprecateVersion(setDeprecateVersionOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke SetDeprecateVersion with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the SetDeprecateVersionOptions model
				setDeprecateVersionOptionsModel := new(catalogmanagementv1.SetDeprecateVersionOptions)
				setDeprecateVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				setDeprecateVersionOptionsModel.Setting = core.StringPtr("true")
				setDeprecateVersionOptionsModel.Description = core.StringPtr("testString")
				setDeprecateVersionOptionsModel.DaysUntilDeprecate = core.Int64Ptr(int64(38))
				setDeprecateVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.SetDeprecateVersion(setDeprecateVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the SetDeprecateVersionOptions model with no property values
				setDeprecateVersionOptionsModelNew := new(catalogmanagementv1.SetDeprecateVersionOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.SetDeprecateVersion(setDeprecateVersionOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ConsumableVersion(consumableVersionOptions *ConsumableVersionOptions)`, func() {
		consumableVersionPath := "/versions/testString/consume-publish"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(consumableVersionPath))
					Expect(req.Method).To(Equal("POST"))

					res.WriteHeader(202)
				}))
			})
			It(`Invoke ConsumableVersion successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.ConsumableVersion(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the ConsumableVersionOptions model
				consumableVersionOptionsModel := new(catalogmanagementv1.ConsumableVersionOptions)
				consumableVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				consumableVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.ConsumableVersion(consumableVersionOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke ConsumableVersion with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ConsumableVersionOptions model
				consumableVersionOptionsModel := new(catalogmanagementv1.ConsumableVersionOptions)
				consumableVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				consumableVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.ConsumableVersion(consumableVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the ConsumableVersionOptions model with no property values
				consumableVersionOptionsModelNew := new(catalogmanagementv1.ConsumableVersionOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.ConsumableVersion(consumableVersionOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`SuspendVersion(suspendVersionOptions *SuspendVersionOptions)`, func() {
		suspendVersionPath := "/versions/testString/suspend"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(suspendVersionPath))
					Expect(req.Method).To(Equal("POST"))

					res.WriteHeader(202)
				}))
			})
			It(`Invoke SuspendVersion successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.SuspendVersion(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the SuspendVersionOptions model
				suspendVersionOptionsModel := new(catalogmanagementv1.SuspendVersionOptions)
				suspendVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				suspendVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.SuspendVersion(suspendVersionOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke SuspendVersion with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the SuspendVersionOptions model
				suspendVersionOptionsModel := new(catalogmanagementv1.SuspendVersionOptions)
				suspendVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				suspendVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.SuspendVersion(suspendVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the SuspendVersionOptions model with no property values
				suspendVersionOptionsModelNew := new(catalogmanagementv1.SuspendVersionOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.SuspendVersion(suspendVersionOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CommitVersion(commitVersionOptions *CommitVersionOptions)`, func() {
		commitVersionPath := "/versions/testString/commit"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(commitVersionPath))
					Expect(req.Method).To(Equal("POST"))

					res.WriteHeader(200)
				}))
			})
			It(`Invoke CommitVersion successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.CommitVersion(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the CommitVersionOptions model
				commitVersionOptionsModel := new(catalogmanagementv1.CommitVersionOptions)
				commitVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				commitVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.CommitVersion(commitVersionOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke CommitVersion with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the CommitVersionOptions model
				commitVersionOptionsModel := new(catalogmanagementv1.CommitVersionOptions)
				commitVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				commitVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.CommitVersion(commitVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the CommitVersionOptions model with no property values
				commitVersionOptionsModelNew := new(catalogmanagementv1.CommitVersionOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.CommitVersion(commitVersionOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CopyVersion(copyVersionOptions *CopyVersionOptions)`, func() {
		copyVersionPath := "/versions/testString/copy"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(copyVersionPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					res.WriteHeader(200)
				}))
			})
			It(`Invoke CopyVersion successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.CopyVersion(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = make(map[string]string)
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the CopyVersionOptions model
				copyVersionOptionsModel := new(catalogmanagementv1.CopyVersionOptions)
				copyVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				copyVersionOptionsModel.Tags = []string{"testString"}
				copyVersionOptionsModel.Content = CreateMockByteArray("This is a mock byte array value.")
				copyVersionOptionsModel.TargetKinds = []string{"testString"}
				copyVersionOptionsModel.FormatKind = core.StringPtr("testString")
				copyVersionOptionsModel.Flavor = flavorModel
				copyVersionOptionsModel.WorkingDirectory = core.StringPtr("testString")
				copyVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.CopyVersion(copyVersionOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke CopyVersion with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = make(map[string]string)
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the CopyVersionOptions model
				copyVersionOptionsModel := new(catalogmanagementv1.CopyVersionOptions)
				copyVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				copyVersionOptionsModel.Tags = []string{"testString"}
				copyVersionOptionsModel.Content = CreateMockByteArray("This is a mock byte array value.")
				copyVersionOptionsModel.TargetKinds = []string{"testString"}
				copyVersionOptionsModel.FormatKind = core.StringPtr("testString")
				copyVersionOptionsModel.Flavor = flavorModel
				copyVersionOptionsModel.WorkingDirectory = core.StringPtr("testString")
				copyVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.CopyVersion(copyVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the CopyVersionOptions model with no property values
				copyVersionOptionsModelNew := new(catalogmanagementv1.CopyVersionOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.CopyVersion(copyVersionOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetOfferingWorkingCopy(getOfferingWorkingCopyOptions *GetOfferingWorkingCopyOptions) - Operation response error`, func() {
		getOfferingWorkingCopyPath := "/versions/testString/workingcopy"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingWorkingCopyPath))
					Expect(req.Method).To(Equal("POST"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetOfferingWorkingCopy with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingWorkingCopyOptions model
				getOfferingWorkingCopyOptionsModel := new(catalogmanagementv1.GetOfferingWorkingCopyOptions)
				getOfferingWorkingCopyOptionsModel.VersionLocID = core.StringPtr("testString")
				getOfferingWorkingCopyOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetOfferingWorkingCopy(getOfferingWorkingCopyOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetOfferingWorkingCopy(getOfferingWorkingCopyOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetOfferingWorkingCopy(getOfferingWorkingCopyOptions *GetOfferingWorkingCopyOptions)`, func() {
		getOfferingWorkingCopyPath := "/versions/testString/workingcopy"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingWorkingCopyPath))
					Expect(req.Method).To(Equal("POST"))

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"mapKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"mapKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "version": "Version", "flavors": ["Flavors"]}]}, "is_consumable": true}`)
				}))
			})
			It(`Invoke GetOfferingWorkingCopy successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetOfferingWorkingCopyOptions model
				getOfferingWorkingCopyOptionsModel := new(catalogmanagementv1.GetOfferingWorkingCopyOptions)
				getOfferingWorkingCopyOptionsModel.VersionLocID = core.StringPtr("testString")
				getOfferingWorkingCopyOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetOfferingWorkingCopyWithContext(ctx, getOfferingWorkingCopyOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetOfferingWorkingCopy(getOfferingWorkingCopyOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetOfferingWorkingCopyWithContext(ctx, getOfferingWorkingCopyOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingWorkingCopyPath))
					Expect(req.Method).To(Equal("POST"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"mapKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"mapKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "version": "Version", "flavors": ["Flavors"]}]}, "is_consumable": true}`)
				}))
			})
			It(`Invoke GetOfferingWorkingCopy successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetOfferingWorkingCopy(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetOfferingWorkingCopyOptions model
				getOfferingWorkingCopyOptionsModel := new(catalogmanagementv1.GetOfferingWorkingCopyOptions)
				getOfferingWorkingCopyOptionsModel.VersionLocID = core.StringPtr("testString")
				getOfferingWorkingCopyOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetOfferingWorkingCopy(getOfferingWorkingCopyOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetOfferingWorkingCopy with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingWorkingCopyOptions model
				getOfferingWorkingCopyOptionsModel := new(catalogmanagementv1.GetOfferingWorkingCopyOptions)
				getOfferingWorkingCopyOptionsModel.VersionLocID = core.StringPtr("testString")
				getOfferingWorkingCopyOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetOfferingWorkingCopy(getOfferingWorkingCopyOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetOfferingWorkingCopyOptions model with no property values
				getOfferingWorkingCopyOptionsModelNew := new(catalogmanagementv1.GetOfferingWorkingCopyOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetOfferingWorkingCopy(getOfferingWorkingCopyOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetOfferingWorkingCopy successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingWorkingCopyOptions model
				getOfferingWorkingCopyOptionsModel := new(catalogmanagementv1.GetOfferingWorkingCopyOptions)
				getOfferingWorkingCopyOptionsModel.VersionLocID = core.StringPtr("testString")
				getOfferingWorkingCopyOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetOfferingWorkingCopy(getOfferingWorkingCopyOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CopyFromPreviousVersion(copyFromPreviousVersionOptions *CopyFromPreviousVersionOptions)`, func() {
		copyFromPreviousVersionPath := "/versions/testString/copy/testString/testString"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(copyFromPreviousVersionPath))
					Expect(req.Method).To(Equal("POST"))

					res.WriteHeader(200)
				}))
			})
			It(`Invoke CopyFromPreviousVersion successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.CopyFromPreviousVersion(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the CopyFromPreviousVersionOptions model
				copyFromPreviousVersionOptionsModel := new(catalogmanagementv1.CopyFromPreviousVersionOptions)
				copyFromPreviousVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				copyFromPreviousVersionOptionsModel.Type = core.StringPtr("testString")
				copyFromPreviousVersionOptionsModel.VersionLocIDToCopyFrom = core.StringPtr("testString")
				copyFromPreviousVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.CopyFromPreviousVersion(copyFromPreviousVersionOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke CopyFromPreviousVersion with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the CopyFromPreviousVersionOptions model
				copyFromPreviousVersionOptionsModel := new(catalogmanagementv1.CopyFromPreviousVersionOptions)
				copyFromPreviousVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				copyFromPreviousVersionOptionsModel.Type = core.StringPtr("testString")
				copyFromPreviousVersionOptionsModel.VersionLocIDToCopyFrom = core.StringPtr("testString")
				copyFromPreviousVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.CopyFromPreviousVersion(copyFromPreviousVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the CopyFromPreviousVersionOptions model with no property values
				copyFromPreviousVersionOptionsModelNew := new(catalogmanagementv1.CopyFromPreviousVersionOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.CopyFromPreviousVersion(copyFromPreviousVersionOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetVersion(getVersionOptions *GetVersionOptions) - Operation response error`, func() {
		getVersionPath := "/versions/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getVersionPath))
					Expect(req.Method).To(Equal("GET"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetVersion with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetVersionOptions model
				getVersionOptionsModel := new(catalogmanagementv1.GetVersionOptions)
				getVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				getVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetVersion(getVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetVersion(getVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetVersion(getVersionOptions *GetVersionOptions)`, func() {
		getVersionPath := "/versions/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getVersionPath))
					Expect(req.Method).To(Equal("GET"))

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "offering_icon_url": "OfferingIconURL", "offering_docs_url": "OfferingDocsURL", "offering_support_url": "OfferingSupportURL", "tags": ["Tags"], "keywords": ["Keywords"], "rating": {"one_star_count": 12, "two_star_count": 12, "three_star_count": 14, "four_star_count": 13}, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "kinds": [{"id": "ID", "format_kind": "FormatKind", "install_kind": "InstallKind", "target_kind": "TargetKind", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"mapKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"mapKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "version": "Version", "flavors": ["Flavors"]}]}, "is_consumable": true}], "plans": [{"id": "ID", "label": "Label", "name": "Name", "short_description": "ShortDescription", "long_description": "LongDescription", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "deployments": [{"id": "ID", "label": "Label", "name": "Name", "short_description": "ShortDescription", "long_description": "LongDescription", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z"}]}]}], "pc_managed": false, "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "permit_request_ibm_public_publish": false, "ibm_publish_approved": true, "public_publish_approved": false, "public_original_crn": "PublicOriginalCRN", "publish_public_crn": "PublishPublicCRN", "portal_approval_record": "PortalApprovalRecord", "portal_ui_url": "PortalUIURL", "catalog_id": "CatalogID", "catalog_name": "CatalogName", "metadata": {"mapKey": "anyValue"}, "disclaimer": "Disclaimer", "hidden": true, "provider": "Provider", "provider_info": {"id": "ID", "name": "Name"}, "repo_info": {"token": "Token", "type": "Type"}, "image_pull_keys": [{"name": "Name", "value": "Value", "description": "Description"}], "support": {"url": "URL", "process": "Process", "process_i18n": {"mapKey": "Inner"}, "locations": ["Locations"], "support_details": [{"type": "Type", "contact": "Contact", "response_wait_time": {"value": 5, "type": "Type"}, "availability": {"times": [{"day": 3, "start_time": "StartTime", "end_time": "EndTime"}], "timezone": "Timezone", "always_available": false}}], "support_escalation": {"escalation_wait_time": {"value": 5, "type": "Type"}, "response_wait_time": {"value": 5, "type": "Type"}, "contact": "Contact"}, "support_type": "SupportType"}, "media": [{"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}], "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "product_kind": "ProductKind", "badges": [{"id": "ID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}, "icon": "Icon", "authority": "Authority", "tag": "Tag", "learn_more_links": {"first_party": "FirstParty", "third_party": "ThirdParty"}, "constraints": [{"type": "Type", "rule": "anyValue"}]}]}`)
				}))
			})
			It(`Invoke GetVersion successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetVersionOptions model
				getVersionOptionsModel := new(catalogmanagementv1.GetVersionOptions)
				getVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				getVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetVersionWithContext(ctx, getVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetVersion(getVersionOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetVersionWithContext(ctx, getVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getVersionPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "offering_icon_url": "OfferingIconURL", "offering_docs_url": "OfferingDocsURL", "offering_support_url": "OfferingSupportURL", "tags": ["Tags"], "keywords": ["Keywords"], "rating": {"one_star_count": 12, "two_star_count": 12, "three_star_count": 14, "four_star_count": 13}, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "kinds": [{"id": "ID", "format_kind": "FormatKind", "install_kind": "InstallKind", "target_kind": "TargetKind", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"mapKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"mapKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCOst": "TotalMonthlyCOst", "resources": [{"name": "Name", "metadata": {"mapKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "version": "Version", "flavors": ["Flavors"]}]}, "is_consumable": true}], "plans": [{"id": "ID", "label": "Label", "name": "Name", "short_description": "ShortDescription", "long_description": "LongDescription", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "deployments": [{"id": "ID", "label": "Label", "name": "Name", "short_description": "ShortDescription", "long_description": "LongDescription", "metadata": {"mapKey": "anyValue"}, "tags": ["Tags"], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z"}]}]}], "pc_managed": false, "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "permit_request_ibm_public_publish": false, "ibm_publish_approved": true, "public_publish_approved": false, "public_original_crn": "PublicOriginalCRN", "publish_public_crn": "PublishPublicCRN", "portal_approval_record": "PortalApprovalRecord", "portal_ui_url": "PortalUIURL", "catalog_id": "CatalogID", "catalog_name": "CatalogName", "metadata": {"mapKey": "anyValue"}, "disclaimer": "Disclaimer", "hidden": true, "provider": "Provider", "provider_info": {"id": "ID", "name": "Name"}, "repo_info": {"token": "Token", "type": "Type"}, "image_pull_keys": [{"name": "Name", "value": "Value", "description": "Description"}], "support": {"url": "URL", "process": "Process", "process_i18n": {"mapKey": "Inner"}, "locations": ["Locations"], "support_details": [{"type": "Type", "contact": "Contact", "response_wait_time": {"value": 5, "type": "Type"}, "availability": {"times": [{"day": 3, "start_time": "StartTime", "end_time": "EndTime"}], "timezone": "Timezone", "always_available": false}}], "support_escalation": {"escalation_wait_time": {"value": 5, "type": "Type"}, "response_wait_time": {"value": 5, "type": "Type"}, "contact": "Contact"}, "support_type": "SupportType"}, "media": [{"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}], "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "product_kind": "ProductKind", "badges": [{"id": "ID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}, "icon": "Icon", "authority": "Authority", "tag": "Tag", "learn_more_links": {"first_party": "FirstParty", "third_party": "ThirdParty"}, "constraints": [{"type": "Type", "rule": "anyValue"}]}]}`)
				}))
			})
			It(`Invoke GetVersion successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetVersion(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetVersionOptions model
				getVersionOptionsModel := new(catalogmanagementv1.GetVersionOptions)
				getVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				getVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetVersion(getVersionOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetVersion with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetVersionOptions model
				getVersionOptionsModel := new(catalogmanagementv1.GetVersionOptions)
				getVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				getVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetVersion(getVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetVersionOptions model with no property values
				getVersionOptionsModelNew := new(catalogmanagementv1.GetVersionOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetVersion(getVersionOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetVersion successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetVersionOptions model
				getVersionOptionsModel := new(catalogmanagementv1.GetVersionOptions)
				getVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				getVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetVersion(getVersionOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteVersion(deleteVersionOptions *DeleteVersionOptions)`, func() {
		deleteVersionPath := "/versions/testString"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteVersionPath))
					Expect(req.Method).To(Equal("DELETE"))

					res.WriteHeader(200)
				}))
			})
			It(`Invoke DeleteVersion successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.DeleteVersion(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteVersionOptions model
				deleteVersionOptionsModel := new(catalogmanagementv1.DeleteVersionOptions)
				deleteVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				deleteVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.DeleteVersion(deleteVersionOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteVersion with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the DeleteVersionOptions model
				deleteVersionOptionsModel := new(catalogmanagementv1.DeleteVersionOptions)
				deleteVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				deleteVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.DeleteVersion(deleteVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeleteVersionOptions model with no property values
				deleteVersionOptionsModelNew := new(catalogmanagementv1.DeleteVersionOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.DeleteVersion(deleteVersionOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeprecateVersion(deprecateVersionOptions *DeprecateVersionOptions)`, func() {
		deprecateVersionPath := "/versions/testString/deprecate"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deprecateVersionPath))
					Expect(req.Method).To(Equal("POST"))

					res.WriteHeader(202)
				}))
			})
			It(`Invoke DeprecateVersion successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.DeprecateVersion(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeprecateVersionOptions model
				deprecateVersionOptionsModel := new(catalogmanagementv1.DeprecateVersionOptions)
				deprecateVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				deprecateVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.DeprecateVersion(deprecateVersionOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeprecateVersion with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the DeprecateVersionOptions model
				deprecateVersionOptionsModel := new(catalogmanagementv1.DeprecateVersionOptions)
				deprecateVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				deprecateVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.DeprecateVersion(deprecateVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeprecateVersionOptions model with no property values
				deprecateVersionOptionsModelNew := new(catalogmanagementv1.DeprecateVersionOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.DeprecateVersion(deprecateVersionOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`AccountPublishVersion(accountPublishVersionOptions *AccountPublishVersionOptions)`, func() {
		accountPublishVersionPath := "/versions/testString/account-publish"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(accountPublishVersionPath))
					Expect(req.Method).To(Equal("POST"))

					res.WriteHeader(202)
				}))
			})
			It(`Invoke AccountPublishVersion successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.AccountPublishVersion(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the AccountPublishVersionOptions model
				accountPublishVersionOptionsModel := new(catalogmanagementv1.AccountPublishVersionOptions)
				accountPublishVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				accountPublishVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.AccountPublishVersion(accountPublishVersionOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke AccountPublishVersion with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the AccountPublishVersionOptions model
				accountPublishVersionOptionsModel := new(catalogmanagementv1.AccountPublishVersionOptions)
				accountPublishVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				accountPublishVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.AccountPublishVersion(accountPublishVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the AccountPublishVersionOptions model with no property values
				accountPublishVersionOptionsModelNew := new(catalogmanagementv1.AccountPublishVersionOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.AccountPublishVersion(accountPublishVersionOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`IBMPublishVersion(ibmPublishVersionOptions *IBMPublishVersionOptions)`, func() {
		ibmPublishVersionPath := "/versions/testString/ibm-publish"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(ibmPublishVersionPath))
					Expect(req.Method).To(Equal("POST"))

					res.WriteHeader(202)
				}))
			})
			It(`Invoke IBMPublishVersion successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.IBMPublishVersion(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the IBMPublishVersionOptions model
				ibmPublishVersionOptionsModel := new(catalogmanagementv1.IBMPublishVersionOptions)
				ibmPublishVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				ibmPublishVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.IBMPublishVersion(ibmPublishVersionOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke IBMPublishVersion with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the IBMPublishVersionOptions model
				ibmPublishVersionOptionsModel := new(catalogmanagementv1.IBMPublishVersionOptions)
				ibmPublishVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				ibmPublishVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.IBMPublishVersion(ibmPublishVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the IBMPublishVersionOptions model with no property values
				ibmPublishVersionOptionsModelNew := new(catalogmanagementv1.IBMPublishVersionOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.IBMPublishVersion(ibmPublishVersionOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`PublicPublishVersion(publicPublishVersionOptions *PublicPublishVersionOptions)`, func() {
		publicPublishVersionPath := "/versions/testString/public-publish"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(publicPublishVersionPath))
					Expect(req.Method).To(Equal("POST"))

					res.WriteHeader(202)
				}))
			})
			It(`Invoke PublicPublishVersion successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.PublicPublishVersion(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the PublicPublishVersionOptions model
				publicPublishVersionOptionsModel := new(catalogmanagementv1.PublicPublishVersionOptions)
				publicPublishVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				publicPublishVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.PublicPublishVersion(publicPublishVersionOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke PublicPublishVersion with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the PublicPublishVersionOptions model
				publicPublishVersionOptionsModel := new(catalogmanagementv1.PublicPublishVersionOptions)
				publicPublishVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				publicPublishVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.PublicPublishVersion(publicPublishVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the PublicPublishVersionOptions model with no property values
				publicPublishVersionOptionsModelNew := new(catalogmanagementv1.PublicPublishVersionOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.PublicPublishVersion(publicPublishVersionOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetCluster(getClusterOptions *GetClusterOptions) - Operation response error`, func() {
		getClusterPath := "/deploy/kubernetes/clusters/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getClusterPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["region"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetCluster with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetClusterOptions model
				getClusterOptionsModel := new(catalogmanagementv1.GetClusterOptions)
				getClusterOptionsModel.ClusterID = core.StringPtr("testString")
				getClusterOptionsModel.Region = core.StringPtr("testString")
				getClusterOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getClusterOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetCluster(getClusterOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetCluster(getClusterOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetCluster(getClusterOptions *GetClusterOptions)`, func() {
		getClusterPath := "/deploy/kubernetes/clusters/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getClusterPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["region"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"resource_group_id": "ResourceGroupID", "resource_group_name": "ResourceGroupName", "id": "ID", "name": "Name", "region": "Region", "ingress_hostname": "IngressHostname", "provider": "Provider", "status": "Status"}`)
				}))
			})
			It(`Invoke GetCluster successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetClusterOptions model
				getClusterOptionsModel := new(catalogmanagementv1.GetClusterOptions)
				getClusterOptionsModel.ClusterID = core.StringPtr("testString")
				getClusterOptionsModel.Region = core.StringPtr("testString")
				getClusterOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getClusterOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetClusterWithContext(ctx, getClusterOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetCluster(getClusterOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetClusterWithContext(ctx, getClusterOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getClusterPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["region"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"resource_group_id": "ResourceGroupID", "resource_group_name": "ResourceGroupName", "id": "ID", "name": "Name", "region": "Region", "ingress_hostname": "IngressHostname", "provider": "Provider", "status": "Status"}`)
				}))
			})
			It(`Invoke GetCluster successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetCluster(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetClusterOptions model
				getClusterOptionsModel := new(catalogmanagementv1.GetClusterOptions)
				getClusterOptionsModel.ClusterID = core.StringPtr("testString")
				getClusterOptionsModel.Region = core.StringPtr("testString")
				getClusterOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getClusterOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetCluster(getClusterOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetCluster with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetClusterOptions model
				getClusterOptionsModel := new(catalogmanagementv1.GetClusterOptions)
				getClusterOptionsModel.ClusterID = core.StringPtr("testString")
				getClusterOptionsModel.Region = core.StringPtr("testString")
				getClusterOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getClusterOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetCluster(getClusterOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetClusterOptions model with no property values
				getClusterOptionsModelNew := new(catalogmanagementv1.GetClusterOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetCluster(getClusterOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetCluster successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetClusterOptions model
				getClusterOptionsModel := new(catalogmanagementv1.GetClusterOptions)
				getClusterOptionsModel.ClusterID = core.StringPtr("testString")
				getClusterOptionsModel.Region = core.StringPtr("testString")
				getClusterOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getClusterOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetCluster(getClusterOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetNamespaces(getNamespacesOptions *GetNamespacesOptions) - Operation response error`, func() {
		getNamespacesPath := "/deploy/kubernetes/clusters/testString/namespaces"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getNamespacesPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["region"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(1000))}))
					Expect(req.URL.Query()["offset"]).To(Equal([]string{fmt.Sprint(int64(38))}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetNamespaces with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetNamespacesOptions model
				getNamespacesOptionsModel := new(catalogmanagementv1.GetNamespacesOptions)
				getNamespacesOptionsModel.ClusterID = core.StringPtr("testString")
				getNamespacesOptionsModel.Region = core.StringPtr("testString")
				getNamespacesOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getNamespacesOptionsModel.Limit = core.Int64Ptr(int64(1000))
				getNamespacesOptionsModel.Offset = core.Int64Ptr(int64(38))
				getNamespacesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetNamespaces(getNamespacesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetNamespaces(getNamespacesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetNamespaces(getNamespacesOptions *GetNamespacesOptions)`, func() {
		getNamespacesPath := "/deploy/kubernetes/clusters/testString/namespaces"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getNamespacesPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["region"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(1000))}))
					Expect(req.URL.Query()["offset"]).To(Equal([]string{fmt.Sprint(int64(38))}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"offset": 6, "limit": 5, "total_count": 10, "resource_count": 13, "first": "First", "last": "Last", "prev": "Prev", "next": "Next", "resources": ["Resources"]}`)
				}))
			})
			It(`Invoke GetNamespaces successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetNamespacesOptions model
				getNamespacesOptionsModel := new(catalogmanagementv1.GetNamespacesOptions)
				getNamespacesOptionsModel.ClusterID = core.StringPtr("testString")
				getNamespacesOptionsModel.Region = core.StringPtr("testString")
				getNamespacesOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getNamespacesOptionsModel.Limit = core.Int64Ptr(int64(1000))
				getNamespacesOptionsModel.Offset = core.Int64Ptr(int64(38))
				getNamespacesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetNamespacesWithContext(ctx, getNamespacesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetNamespaces(getNamespacesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetNamespacesWithContext(ctx, getNamespacesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getNamespacesPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["region"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(1000))}))
					Expect(req.URL.Query()["offset"]).To(Equal([]string{fmt.Sprint(int64(38))}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"offset": 6, "limit": 5, "total_count": 10, "resource_count": 13, "first": "First", "last": "Last", "prev": "Prev", "next": "Next", "resources": ["Resources"]}`)
				}))
			})
			It(`Invoke GetNamespaces successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetNamespaces(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetNamespacesOptions model
				getNamespacesOptionsModel := new(catalogmanagementv1.GetNamespacesOptions)
				getNamespacesOptionsModel.ClusterID = core.StringPtr("testString")
				getNamespacesOptionsModel.Region = core.StringPtr("testString")
				getNamespacesOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getNamespacesOptionsModel.Limit = core.Int64Ptr(int64(1000))
				getNamespacesOptionsModel.Offset = core.Int64Ptr(int64(38))
				getNamespacesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetNamespaces(getNamespacesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetNamespaces with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetNamespacesOptions model
				getNamespacesOptionsModel := new(catalogmanagementv1.GetNamespacesOptions)
				getNamespacesOptionsModel.ClusterID = core.StringPtr("testString")
				getNamespacesOptionsModel.Region = core.StringPtr("testString")
				getNamespacesOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getNamespacesOptionsModel.Limit = core.Int64Ptr(int64(1000))
				getNamespacesOptionsModel.Offset = core.Int64Ptr(int64(38))
				getNamespacesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetNamespaces(getNamespacesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetNamespacesOptions model with no property values
				getNamespacesOptionsModelNew := new(catalogmanagementv1.GetNamespacesOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetNamespaces(getNamespacesOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetNamespaces successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetNamespacesOptions model
				getNamespacesOptionsModel := new(catalogmanagementv1.GetNamespacesOptions)
				getNamespacesOptionsModel.ClusterID = core.StringPtr("testString")
				getNamespacesOptionsModel.Region = core.StringPtr("testString")
				getNamespacesOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getNamespacesOptionsModel.Limit = core.Int64Ptr(int64(1000))
				getNamespacesOptionsModel.Offset = core.Int64Ptr(int64(38))
				getNamespacesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetNamespaces(getNamespacesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeployOperators(deployOperatorsOptions *DeployOperatorsOptions) - Operation response error`, func() {
		deployOperatorsPath := "/deploy/kubernetes/olm/operator"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deployOperatorsPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke DeployOperators with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the DeployOperatorsOptions model
				deployOperatorsOptionsModel := new(catalogmanagementv1.DeployOperatorsOptions)
				deployOperatorsOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				deployOperatorsOptionsModel.ClusterID = core.StringPtr("testString")
				deployOperatorsOptionsModel.Region = core.StringPtr("testString")
				deployOperatorsOptionsModel.Namespaces = []string{"testString"}
				deployOperatorsOptionsModel.AllNamespaces = core.BoolPtr(true)
				deployOperatorsOptionsModel.VersionLocatorID = core.StringPtr("testString")
				deployOperatorsOptionsModel.Channel = core.StringPtr("testString")
				deployOperatorsOptionsModel.InstallPlan = core.StringPtr("testString")
				deployOperatorsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.DeployOperators(deployOperatorsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.DeployOperators(deployOperatorsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeployOperators(deployOperatorsOptions *DeployOperatorsOptions)`, func() {
		deployOperatorsPath := "/deploy/kubernetes/olm/operator"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deployOperatorsPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `[{"phase": "Phase", "message": "Message", "link": "Link", "name": "Name", "version": "Version", "namespace": "Namespace", "package_name": "PackageName", "catalog_id": "CatalogID"}]`)
				}))
			})
			It(`Invoke DeployOperators successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the DeployOperatorsOptions model
				deployOperatorsOptionsModel := new(catalogmanagementv1.DeployOperatorsOptions)
				deployOperatorsOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				deployOperatorsOptionsModel.ClusterID = core.StringPtr("testString")
				deployOperatorsOptionsModel.Region = core.StringPtr("testString")
				deployOperatorsOptionsModel.Namespaces = []string{"testString"}
				deployOperatorsOptionsModel.AllNamespaces = core.BoolPtr(true)
				deployOperatorsOptionsModel.VersionLocatorID = core.StringPtr("testString")
				deployOperatorsOptionsModel.Channel = core.StringPtr("testString")
				deployOperatorsOptionsModel.InstallPlan = core.StringPtr("testString")
				deployOperatorsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.DeployOperatorsWithContext(ctx, deployOperatorsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.DeployOperators(deployOperatorsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.DeployOperatorsWithContext(ctx, deployOperatorsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deployOperatorsPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `[{"phase": "Phase", "message": "Message", "link": "Link", "name": "Name", "version": "Version", "namespace": "Namespace", "package_name": "PackageName", "catalog_id": "CatalogID"}]`)
				}))
			})
			It(`Invoke DeployOperators successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.DeployOperators(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the DeployOperatorsOptions model
				deployOperatorsOptionsModel := new(catalogmanagementv1.DeployOperatorsOptions)
				deployOperatorsOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				deployOperatorsOptionsModel.ClusterID = core.StringPtr("testString")
				deployOperatorsOptionsModel.Region = core.StringPtr("testString")
				deployOperatorsOptionsModel.Namespaces = []string{"testString"}
				deployOperatorsOptionsModel.AllNamespaces = core.BoolPtr(true)
				deployOperatorsOptionsModel.VersionLocatorID = core.StringPtr("testString")
				deployOperatorsOptionsModel.Channel = core.StringPtr("testString")
				deployOperatorsOptionsModel.InstallPlan = core.StringPtr("testString")
				deployOperatorsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.DeployOperators(deployOperatorsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke DeployOperators with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the DeployOperatorsOptions model
				deployOperatorsOptionsModel := new(catalogmanagementv1.DeployOperatorsOptions)
				deployOperatorsOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				deployOperatorsOptionsModel.ClusterID = core.StringPtr("testString")
				deployOperatorsOptionsModel.Region = core.StringPtr("testString")
				deployOperatorsOptionsModel.Namespaces = []string{"testString"}
				deployOperatorsOptionsModel.AllNamespaces = core.BoolPtr(true)
				deployOperatorsOptionsModel.VersionLocatorID = core.StringPtr("testString")
				deployOperatorsOptionsModel.Channel = core.StringPtr("testString")
				deployOperatorsOptionsModel.InstallPlan = core.StringPtr("testString")
				deployOperatorsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.DeployOperators(deployOperatorsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the DeployOperatorsOptions model with no property values
				deployOperatorsOptionsModelNew := new(catalogmanagementv1.DeployOperatorsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.DeployOperators(deployOperatorsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke DeployOperators successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the DeployOperatorsOptions model
				deployOperatorsOptionsModel := new(catalogmanagementv1.DeployOperatorsOptions)
				deployOperatorsOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				deployOperatorsOptionsModel.ClusterID = core.StringPtr("testString")
				deployOperatorsOptionsModel.Region = core.StringPtr("testString")
				deployOperatorsOptionsModel.Namespaces = []string{"testString"}
				deployOperatorsOptionsModel.AllNamespaces = core.BoolPtr(true)
				deployOperatorsOptionsModel.VersionLocatorID = core.StringPtr("testString")
				deployOperatorsOptionsModel.Channel = core.StringPtr("testString")
				deployOperatorsOptionsModel.InstallPlan = core.StringPtr("testString")
				deployOperatorsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.DeployOperators(deployOperatorsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListOperators(listOperatorsOptions *ListOperatorsOptions) - Operation response error`, func() {
		listOperatorsPath := "/deploy/kubernetes/olm/operator"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listOperatorsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["cluster_id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["region"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["version_locator_id"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListOperators with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListOperatorsOptions model
				listOperatorsOptionsModel := new(catalogmanagementv1.ListOperatorsOptions)
				listOperatorsOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				listOperatorsOptionsModel.ClusterID = core.StringPtr("testString")
				listOperatorsOptionsModel.Region = core.StringPtr("testString")
				listOperatorsOptionsModel.VersionLocatorID = core.StringPtr("testString")
				listOperatorsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.ListOperators(listOperatorsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.ListOperators(listOperatorsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListOperators(listOperatorsOptions *ListOperatorsOptions)`, func() {
		listOperatorsPath := "/deploy/kubernetes/olm/operator"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listOperatorsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["cluster_id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["region"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["version_locator_id"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `[{"phase": "Phase", "message": "Message", "link": "Link", "name": "Name", "version": "Version", "namespace": "Namespace", "package_name": "PackageName", "catalog_id": "CatalogID"}]`)
				}))
			})
			It(`Invoke ListOperators successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the ListOperatorsOptions model
				listOperatorsOptionsModel := new(catalogmanagementv1.ListOperatorsOptions)
				listOperatorsOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				listOperatorsOptionsModel.ClusterID = core.StringPtr("testString")
				listOperatorsOptionsModel.Region = core.StringPtr("testString")
				listOperatorsOptionsModel.VersionLocatorID = core.StringPtr("testString")
				listOperatorsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.ListOperatorsWithContext(ctx, listOperatorsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.ListOperators(listOperatorsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.ListOperatorsWithContext(ctx, listOperatorsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listOperatorsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["cluster_id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["region"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["version_locator_id"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `[{"phase": "Phase", "message": "Message", "link": "Link", "name": "Name", "version": "Version", "namespace": "Namespace", "package_name": "PackageName", "catalog_id": "CatalogID"}]`)
				}))
			})
			It(`Invoke ListOperators successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.ListOperators(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListOperatorsOptions model
				listOperatorsOptionsModel := new(catalogmanagementv1.ListOperatorsOptions)
				listOperatorsOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				listOperatorsOptionsModel.ClusterID = core.StringPtr("testString")
				listOperatorsOptionsModel.Region = core.StringPtr("testString")
				listOperatorsOptionsModel.VersionLocatorID = core.StringPtr("testString")
				listOperatorsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.ListOperators(listOperatorsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListOperators with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListOperatorsOptions model
				listOperatorsOptionsModel := new(catalogmanagementv1.ListOperatorsOptions)
				listOperatorsOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				listOperatorsOptionsModel.ClusterID = core.StringPtr("testString")
				listOperatorsOptionsModel.Region = core.StringPtr("testString")
				listOperatorsOptionsModel.VersionLocatorID = core.StringPtr("testString")
				listOperatorsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.ListOperators(listOperatorsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ListOperatorsOptions model with no property values
				listOperatorsOptionsModelNew := new(catalogmanagementv1.ListOperatorsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.ListOperators(listOperatorsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListOperators successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListOperatorsOptions model
				listOperatorsOptionsModel := new(catalogmanagementv1.ListOperatorsOptions)
				listOperatorsOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				listOperatorsOptionsModel.ClusterID = core.StringPtr("testString")
				listOperatorsOptionsModel.Region = core.StringPtr("testString")
				listOperatorsOptionsModel.VersionLocatorID = core.StringPtr("testString")
				listOperatorsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.ListOperators(listOperatorsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ReplaceOperators(replaceOperatorsOptions *ReplaceOperatorsOptions) - Operation response error`, func() {
		replaceOperatorsPath := "/deploy/kubernetes/olm/operator"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(replaceOperatorsPath))
					Expect(req.Method).To(Equal("PUT"))
					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ReplaceOperators with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ReplaceOperatorsOptions model
				replaceOperatorsOptionsModel := new(catalogmanagementv1.ReplaceOperatorsOptions)
				replaceOperatorsOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				replaceOperatorsOptionsModel.ClusterID = core.StringPtr("testString")
				replaceOperatorsOptionsModel.Region = core.StringPtr("testString")
				replaceOperatorsOptionsModel.Namespaces = []string{"testString"}
				replaceOperatorsOptionsModel.AllNamespaces = core.BoolPtr(true)
				replaceOperatorsOptionsModel.VersionLocatorID = core.StringPtr("testString")
				replaceOperatorsOptionsModel.Channel = core.StringPtr("testString")
				replaceOperatorsOptionsModel.InstallPlan = core.StringPtr("testString")
				replaceOperatorsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.ReplaceOperators(replaceOperatorsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.ReplaceOperators(replaceOperatorsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ReplaceOperators(replaceOperatorsOptions *ReplaceOperatorsOptions)`, func() {
		replaceOperatorsPath := "/deploy/kubernetes/olm/operator"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(replaceOperatorsPath))
					Expect(req.Method).To(Equal("PUT"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `[{"phase": "Phase", "message": "Message", "link": "Link", "name": "Name", "version": "Version", "namespace": "Namespace", "package_name": "PackageName", "catalog_id": "CatalogID"}]`)
				}))
			})
			It(`Invoke ReplaceOperators successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the ReplaceOperatorsOptions model
				replaceOperatorsOptionsModel := new(catalogmanagementv1.ReplaceOperatorsOptions)
				replaceOperatorsOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				replaceOperatorsOptionsModel.ClusterID = core.StringPtr("testString")
				replaceOperatorsOptionsModel.Region = core.StringPtr("testString")
				replaceOperatorsOptionsModel.Namespaces = []string{"testString"}
				replaceOperatorsOptionsModel.AllNamespaces = core.BoolPtr(true)
				replaceOperatorsOptionsModel.VersionLocatorID = core.StringPtr("testString")
				replaceOperatorsOptionsModel.Channel = core.StringPtr("testString")
				replaceOperatorsOptionsModel.InstallPlan = core.StringPtr("testString")
				replaceOperatorsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.ReplaceOperatorsWithContext(ctx, replaceOperatorsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.ReplaceOperators(replaceOperatorsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.ReplaceOperatorsWithContext(ctx, replaceOperatorsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(replaceOperatorsPath))
					Expect(req.Method).To(Equal("PUT"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `[{"phase": "Phase", "message": "Message", "link": "Link", "name": "Name", "version": "Version", "namespace": "Namespace", "package_name": "PackageName", "catalog_id": "CatalogID"}]`)
				}))
			})
			It(`Invoke ReplaceOperators successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.ReplaceOperators(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ReplaceOperatorsOptions model
				replaceOperatorsOptionsModel := new(catalogmanagementv1.ReplaceOperatorsOptions)
				replaceOperatorsOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				replaceOperatorsOptionsModel.ClusterID = core.StringPtr("testString")
				replaceOperatorsOptionsModel.Region = core.StringPtr("testString")
				replaceOperatorsOptionsModel.Namespaces = []string{"testString"}
				replaceOperatorsOptionsModel.AllNamespaces = core.BoolPtr(true)
				replaceOperatorsOptionsModel.VersionLocatorID = core.StringPtr("testString")
				replaceOperatorsOptionsModel.Channel = core.StringPtr("testString")
				replaceOperatorsOptionsModel.InstallPlan = core.StringPtr("testString")
				replaceOperatorsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.ReplaceOperators(replaceOperatorsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ReplaceOperators with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ReplaceOperatorsOptions model
				replaceOperatorsOptionsModel := new(catalogmanagementv1.ReplaceOperatorsOptions)
				replaceOperatorsOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				replaceOperatorsOptionsModel.ClusterID = core.StringPtr("testString")
				replaceOperatorsOptionsModel.Region = core.StringPtr("testString")
				replaceOperatorsOptionsModel.Namespaces = []string{"testString"}
				replaceOperatorsOptionsModel.AllNamespaces = core.BoolPtr(true)
				replaceOperatorsOptionsModel.VersionLocatorID = core.StringPtr("testString")
				replaceOperatorsOptionsModel.Channel = core.StringPtr("testString")
				replaceOperatorsOptionsModel.InstallPlan = core.StringPtr("testString")
				replaceOperatorsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.ReplaceOperators(replaceOperatorsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ReplaceOperatorsOptions model with no property values
				replaceOperatorsOptionsModelNew := new(catalogmanagementv1.ReplaceOperatorsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.ReplaceOperators(replaceOperatorsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ReplaceOperators successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ReplaceOperatorsOptions model
				replaceOperatorsOptionsModel := new(catalogmanagementv1.ReplaceOperatorsOptions)
				replaceOperatorsOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				replaceOperatorsOptionsModel.ClusterID = core.StringPtr("testString")
				replaceOperatorsOptionsModel.Region = core.StringPtr("testString")
				replaceOperatorsOptionsModel.Namespaces = []string{"testString"}
				replaceOperatorsOptionsModel.AllNamespaces = core.BoolPtr(true)
				replaceOperatorsOptionsModel.VersionLocatorID = core.StringPtr("testString")
				replaceOperatorsOptionsModel.Channel = core.StringPtr("testString")
				replaceOperatorsOptionsModel.InstallPlan = core.StringPtr("testString")
				replaceOperatorsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.ReplaceOperators(replaceOperatorsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteOperators(deleteOperatorsOptions *DeleteOperatorsOptions)`, func() {
		deleteOperatorsPath := "/deploy/kubernetes/olm/operator"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteOperatorsPath))
					Expect(req.Method).To(Equal("DELETE"))

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["cluster_id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["region"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["version_locator_id"]).To(Equal([]string{"testString"}))
					res.WriteHeader(200)
				}))
			})
			It(`Invoke DeleteOperators successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.DeleteOperators(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteOperatorsOptions model
				deleteOperatorsOptionsModel := new(catalogmanagementv1.DeleteOperatorsOptions)
				deleteOperatorsOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				deleteOperatorsOptionsModel.ClusterID = core.StringPtr("testString")
				deleteOperatorsOptionsModel.Region = core.StringPtr("testString")
				deleteOperatorsOptionsModel.VersionLocatorID = core.StringPtr("testString")
				deleteOperatorsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.DeleteOperators(deleteOperatorsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteOperators with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the DeleteOperatorsOptions model
				deleteOperatorsOptionsModel := new(catalogmanagementv1.DeleteOperatorsOptions)
				deleteOperatorsOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				deleteOperatorsOptionsModel.ClusterID = core.StringPtr("testString")
				deleteOperatorsOptionsModel.Region = core.StringPtr("testString")
				deleteOperatorsOptionsModel.VersionLocatorID = core.StringPtr("testString")
				deleteOperatorsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.DeleteOperators(deleteOperatorsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeleteOperatorsOptions model with no property values
				deleteOperatorsOptionsModelNew := new(catalogmanagementv1.DeleteOperatorsOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.DeleteOperators(deleteOperatorsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`InstallVersion(installVersionOptions *InstallVersionOptions)`, func() {
		installVersionPath := "/versions/testString/install"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(installVersionPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.WriteHeader(202)
				}))
			})
			It(`Invoke InstallVersion successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.InstallVersion(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeployRequestBodyOverrideValues model
				deployRequestBodyOverrideValuesModel := new(catalogmanagementv1.DeployRequestBodyOverrideValues)
				deployRequestBodyOverrideValuesModel.VsiInstanceName = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCProfile = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SubnetID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SubnetZone = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SSHKeyID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCRegion = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SetProperty("foo", core.StringPtr("testString"))

				// Construct an instance of the DeployRequestBodyEnvironmentVariablesItem model
				deployRequestBodyEnvironmentVariablesItemModel := new(catalogmanagementv1.DeployRequestBodyEnvironmentVariablesItem)
				deployRequestBodyEnvironmentVariablesItemModel.Name = core.StringPtr("testString")
				deployRequestBodyEnvironmentVariablesItemModel.Value = core.StringPtr("testString")
				deployRequestBodyEnvironmentVariablesItemModel.Secure = core.BoolPtr(true)

				// Construct an instance of the DeployRequestBodySchematics model
				deployRequestBodySchematicsModel := new(catalogmanagementv1.DeployRequestBodySchematics)
				deployRequestBodySchematicsModel.Name = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Description = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Tags = []string{"testString"}
				deployRequestBodySchematicsModel.ResourceGroupID = core.StringPtr("testString")
				deployRequestBodySchematicsModel.TerraformVersion = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Region = core.StringPtr("testString")

				// Construct an instance of the InstallVersionOptions model
				installVersionOptionsModel := new(catalogmanagementv1.InstallVersionOptions)
				installVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				installVersionOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				installVersionOptionsModel.ClusterID = core.StringPtr("testString")
				installVersionOptionsModel.Region = core.StringPtr("testString")
				installVersionOptionsModel.Namespace = core.StringPtr("testString")
				installVersionOptionsModel.OverrideValues = deployRequestBodyOverrideValuesModel
				installVersionOptionsModel.EnvironmentVariables = []catalogmanagementv1.DeployRequestBodyEnvironmentVariablesItem{*deployRequestBodyEnvironmentVariablesItemModel}
				installVersionOptionsModel.EntitlementApikey = core.StringPtr("testString")
				installVersionOptionsModel.Schematics = deployRequestBodySchematicsModel
				installVersionOptionsModel.Script = core.StringPtr("testString")
				installVersionOptionsModel.ScriptID = core.StringPtr("testString")
				installVersionOptionsModel.VersionLocatorID = core.StringPtr("testString")
				installVersionOptionsModel.VcenterID = core.StringPtr("testString")
				installVersionOptionsModel.VcenterLocation = core.StringPtr("testString")
				installVersionOptionsModel.VcenterUser = core.StringPtr("testString")
				installVersionOptionsModel.VcenterPassword = core.StringPtr("testString")
				installVersionOptionsModel.VcenterDatastore = core.StringPtr("testString")
				installVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.InstallVersion(installVersionOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke InstallVersion with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the DeployRequestBodyOverrideValues model
				deployRequestBodyOverrideValuesModel := new(catalogmanagementv1.DeployRequestBodyOverrideValues)
				deployRequestBodyOverrideValuesModel.VsiInstanceName = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCProfile = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SubnetID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SubnetZone = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SSHKeyID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCRegion = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SetProperty("foo", core.StringPtr("testString"))

				// Construct an instance of the DeployRequestBodyEnvironmentVariablesItem model
				deployRequestBodyEnvironmentVariablesItemModel := new(catalogmanagementv1.DeployRequestBodyEnvironmentVariablesItem)
				deployRequestBodyEnvironmentVariablesItemModel.Name = core.StringPtr("testString")
				deployRequestBodyEnvironmentVariablesItemModel.Value = core.StringPtr("testString")
				deployRequestBodyEnvironmentVariablesItemModel.Secure = core.BoolPtr(true)

				// Construct an instance of the DeployRequestBodySchematics model
				deployRequestBodySchematicsModel := new(catalogmanagementv1.DeployRequestBodySchematics)
				deployRequestBodySchematicsModel.Name = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Description = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Tags = []string{"testString"}
				deployRequestBodySchematicsModel.ResourceGroupID = core.StringPtr("testString")
				deployRequestBodySchematicsModel.TerraformVersion = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Region = core.StringPtr("testString")

				// Construct an instance of the InstallVersionOptions model
				installVersionOptionsModel := new(catalogmanagementv1.InstallVersionOptions)
				installVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				installVersionOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				installVersionOptionsModel.ClusterID = core.StringPtr("testString")
				installVersionOptionsModel.Region = core.StringPtr("testString")
				installVersionOptionsModel.Namespace = core.StringPtr("testString")
				installVersionOptionsModel.OverrideValues = deployRequestBodyOverrideValuesModel
				installVersionOptionsModel.EnvironmentVariables = []catalogmanagementv1.DeployRequestBodyEnvironmentVariablesItem{*deployRequestBodyEnvironmentVariablesItemModel}
				installVersionOptionsModel.EntitlementApikey = core.StringPtr("testString")
				installVersionOptionsModel.Schematics = deployRequestBodySchematicsModel
				installVersionOptionsModel.Script = core.StringPtr("testString")
				installVersionOptionsModel.ScriptID = core.StringPtr("testString")
				installVersionOptionsModel.VersionLocatorID = core.StringPtr("testString")
				installVersionOptionsModel.VcenterID = core.StringPtr("testString")
				installVersionOptionsModel.VcenterLocation = core.StringPtr("testString")
				installVersionOptionsModel.VcenterUser = core.StringPtr("testString")
				installVersionOptionsModel.VcenterPassword = core.StringPtr("testString")
				installVersionOptionsModel.VcenterDatastore = core.StringPtr("testString")
				installVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.InstallVersion(installVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the InstallVersionOptions model with no property values
				installVersionOptionsModelNew := new(catalogmanagementv1.InstallVersionOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.InstallVersion(installVersionOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`PreinstallVersion(preinstallVersionOptions *PreinstallVersionOptions)`, func() {
		preinstallVersionPath := "/versions/testString/preinstall"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(preinstallVersionPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.WriteHeader(202)
				}))
			})
			It(`Invoke PreinstallVersion successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.PreinstallVersion(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeployRequestBodyOverrideValues model
				deployRequestBodyOverrideValuesModel := new(catalogmanagementv1.DeployRequestBodyOverrideValues)
				deployRequestBodyOverrideValuesModel.VsiInstanceName = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCProfile = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SubnetID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SubnetZone = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SSHKeyID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCRegion = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SetProperty("foo", core.StringPtr("testString"))

				// Construct an instance of the DeployRequestBodyEnvironmentVariablesItem model
				deployRequestBodyEnvironmentVariablesItemModel := new(catalogmanagementv1.DeployRequestBodyEnvironmentVariablesItem)
				deployRequestBodyEnvironmentVariablesItemModel.Name = core.StringPtr("testString")
				deployRequestBodyEnvironmentVariablesItemModel.Value = core.StringPtr("testString")
				deployRequestBodyEnvironmentVariablesItemModel.Secure = core.BoolPtr(true)

				// Construct an instance of the DeployRequestBodySchematics model
				deployRequestBodySchematicsModel := new(catalogmanagementv1.DeployRequestBodySchematics)
				deployRequestBodySchematicsModel.Name = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Description = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Tags = []string{"testString"}
				deployRequestBodySchematicsModel.ResourceGroupID = core.StringPtr("testString")
				deployRequestBodySchematicsModel.TerraformVersion = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Region = core.StringPtr("testString")

				// Construct an instance of the PreinstallVersionOptions model
				preinstallVersionOptionsModel := new(catalogmanagementv1.PreinstallVersionOptions)
				preinstallVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				preinstallVersionOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				preinstallVersionOptionsModel.ClusterID = core.StringPtr("testString")
				preinstallVersionOptionsModel.Region = core.StringPtr("testString")
				preinstallVersionOptionsModel.Namespace = core.StringPtr("testString")
				preinstallVersionOptionsModel.OverrideValues = deployRequestBodyOverrideValuesModel
				preinstallVersionOptionsModel.EnvironmentVariables = []catalogmanagementv1.DeployRequestBodyEnvironmentVariablesItem{*deployRequestBodyEnvironmentVariablesItemModel}
				preinstallVersionOptionsModel.EntitlementApikey = core.StringPtr("testString")
				preinstallVersionOptionsModel.Schematics = deployRequestBodySchematicsModel
				preinstallVersionOptionsModel.Script = core.StringPtr("testString")
				preinstallVersionOptionsModel.ScriptID = core.StringPtr("testString")
				preinstallVersionOptionsModel.VersionLocatorID = core.StringPtr("testString")
				preinstallVersionOptionsModel.VcenterID = core.StringPtr("testString")
				preinstallVersionOptionsModel.VcenterLocation = core.StringPtr("testString")
				preinstallVersionOptionsModel.VcenterUser = core.StringPtr("testString")
				preinstallVersionOptionsModel.VcenterPassword = core.StringPtr("testString")
				preinstallVersionOptionsModel.VcenterDatastore = core.StringPtr("testString")
				preinstallVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.PreinstallVersion(preinstallVersionOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke PreinstallVersion with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the DeployRequestBodyOverrideValues model
				deployRequestBodyOverrideValuesModel := new(catalogmanagementv1.DeployRequestBodyOverrideValues)
				deployRequestBodyOverrideValuesModel.VsiInstanceName = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCProfile = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SubnetID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SubnetZone = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SSHKeyID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCRegion = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SetProperty("foo", core.StringPtr("testString"))

				// Construct an instance of the DeployRequestBodyEnvironmentVariablesItem model
				deployRequestBodyEnvironmentVariablesItemModel := new(catalogmanagementv1.DeployRequestBodyEnvironmentVariablesItem)
				deployRequestBodyEnvironmentVariablesItemModel.Name = core.StringPtr("testString")
				deployRequestBodyEnvironmentVariablesItemModel.Value = core.StringPtr("testString")
				deployRequestBodyEnvironmentVariablesItemModel.Secure = core.BoolPtr(true)

				// Construct an instance of the DeployRequestBodySchematics model
				deployRequestBodySchematicsModel := new(catalogmanagementv1.DeployRequestBodySchematics)
				deployRequestBodySchematicsModel.Name = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Description = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Tags = []string{"testString"}
				deployRequestBodySchematicsModel.ResourceGroupID = core.StringPtr("testString")
				deployRequestBodySchematicsModel.TerraformVersion = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Region = core.StringPtr("testString")

				// Construct an instance of the PreinstallVersionOptions model
				preinstallVersionOptionsModel := new(catalogmanagementv1.PreinstallVersionOptions)
				preinstallVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				preinstallVersionOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				preinstallVersionOptionsModel.ClusterID = core.StringPtr("testString")
				preinstallVersionOptionsModel.Region = core.StringPtr("testString")
				preinstallVersionOptionsModel.Namespace = core.StringPtr("testString")
				preinstallVersionOptionsModel.OverrideValues = deployRequestBodyOverrideValuesModel
				preinstallVersionOptionsModel.EnvironmentVariables = []catalogmanagementv1.DeployRequestBodyEnvironmentVariablesItem{*deployRequestBodyEnvironmentVariablesItemModel}
				preinstallVersionOptionsModel.EntitlementApikey = core.StringPtr("testString")
				preinstallVersionOptionsModel.Schematics = deployRequestBodySchematicsModel
				preinstallVersionOptionsModel.Script = core.StringPtr("testString")
				preinstallVersionOptionsModel.ScriptID = core.StringPtr("testString")
				preinstallVersionOptionsModel.VersionLocatorID = core.StringPtr("testString")
				preinstallVersionOptionsModel.VcenterID = core.StringPtr("testString")
				preinstallVersionOptionsModel.VcenterLocation = core.StringPtr("testString")
				preinstallVersionOptionsModel.VcenterUser = core.StringPtr("testString")
				preinstallVersionOptionsModel.VcenterPassword = core.StringPtr("testString")
				preinstallVersionOptionsModel.VcenterDatastore = core.StringPtr("testString")
				preinstallVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.PreinstallVersion(preinstallVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the PreinstallVersionOptions model with no property values
				preinstallVersionOptionsModelNew := new(catalogmanagementv1.PreinstallVersionOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.PreinstallVersion(preinstallVersionOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetPreinstall(getPreinstallOptions *GetPreinstallOptions) - Operation response error`, func() {
		getPreinstallPath := "/versions/testString/preinstall"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getPreinstallPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["cluster_id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["region"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["namespace"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetPreinstall with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetPreinstallOptions model
				getPreinstallOptionsModel := new(catalogmanagementv1.GetPreinstallOptions)
				getPreinstallOptionsModel.VersionLocID = core.StringPtr("testString")
				getPreinstallOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getPreinstallOptionsModel.ClusterID = core.StringPtr("testString")
				getPreinstallOptionsModel.Region = core.StringPtr("testString")
				getPreinstallOptionsModel.Namespace = core.StringPtr("testString")
				getPreinstallOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetPreinstall(getPreinstallOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetPreinstall(getPreinstallOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetPreinstall(getPreinstallOptions *GetPreinstallOptions)`, func() {
		getPreinstallPath := "/versions/testString/preinstall"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getPreinstallPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["cluster_id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["region"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["namespace"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"metadata": {"cluster_id": "ClusterID", "region": "Region", "namespace": "Namespace", "workspace_id": "WorkspaceID", "workspace_name": "WorkspaceName"}, "release": {"deployments": [{"mapKey": "anyValue"}], "replicasets": [{"mapKey": "anyValue"}], "statefulsets": [{"mapKey": "anyValue"}], "pods": [{"mapKey": "anyValue"}], "errors": [{"mapKey": "Inner"}]}, "content_mgmt": {"pods": [{"mapKey": "Inner"}], "errors": [{"mapKey": "Inner"}]}}`)
				}))
			})
			It(`Invoke GetPreinstall successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetPreinstallOptions model
				getPreinstallOptionsModel := new(catalogmanagementv1.GetPreinstallOptions)
				getPreinstallOptionsModel.VersionLocID = core.StringPtr("testString")
				getPreinstallOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getPreinstallOptionsModel.ClusterID = core.StringPtr("testString")
				getPreinstallOptionsModel.Region = core.StringPtr("testString")
				getPreinstallOptionsModel.Namespace = core.StringPtr("testString")
				getPreinstallOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetPreinstallWithContext(ctx, getPreinstallOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetPreinstall(getPreinstallOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetPreinstallWithContext(ctx, getPreinstallOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getPreinstallPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["cluster_id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["region"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["namespace"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"metadata": {"cluster_id": "ClusterID", "region": "Region", "namespace": "Namespace", "workspace_id": "WorkspaceID", "workspace_name": "WorkspaceName"}, "release": {"deployments": [{"mapKey": "anyValue"}], "replicasets": [{"mapKey": "anyValue"}], "statefulsets": [{"mapKey": "anyValue"}], "pods": [{"mapKey": "anyValue"}], "errors": [{"mapKey": "Inner"}]}, "content_mgmt": {"pods": [{"mapKey": "Inner"}], "errors": [{"mapKey": "Inner"}]}}`)
				}))
			})
			It(`Invoke GetPreinstall successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetPreinstall(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetPreinstallOptions model
				getPreinstallOptionsModel := new(catalogmanagementv1.GetPreinstallOptions)
				getPreinstallOptionsModel.VersionLocID = core.StringPtr("testString")
				getPreinstallOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getPreinstallOptionsModel.ClusterID = core.StringPtr("testString")
				getPreinstallOptionsModel.Region = core.StringPtr("testString")
				getPreinstallOptionsModel.Namespace = core.StringPtr("testString")
				getPreinstallOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetPreinstall(getPreinstallOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetPreinstall with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetPreinstallOptions model
				getPreinstallOptionsModel := new(catalogmanagementv1.GetPreinstallOptions)
				getPreinstallOptionsModel.VersionLocID = core.StringPtr("testString")
				getPreinstallOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getPreinstallOptionsModel.ClusterID = core.StringPtr("testString")
				getPreinstallOptionsModel.Region = core.StringPtr("testString")
				getPreinstallOptionsModel.Namespace = core.StringPtr("testString")
				getPreinstallOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetPreinstall(getPreinstallOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetPreinstallOptions model with no property values
				getPreinstallOptionsModelNew := new(catalogmanagementv1.GetPreinstallOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetPreinstall(getPreinstallOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetPreinstall successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetPreinstallOptions model
				getPreinstallOptionsModel := new(catalogmanagementv1.GetPreinstallOptions)
				getPreinstallOptionsModel.VersionLocID = core.StringPtr("testString")
				getPreinstallOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getPreinstallOptionsModel.ClusterID = core.StringPtr("testString")
				getPreinstallOptionsModel.Region = core.StringPtr("testString")
				getPreinstallOptionsModel.Namespace = core.StringPtr("testString")
				getPreinstallOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetPreinstall(getPreinstallOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ValidateInstall(validateInstallOptions *ValidateInstallOptions)`, func() {
		validateInstallPath := "/versions/testString/validation/install"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(validateInstallPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.WriteHeader(202)
				}))
			})
			It(`Invoke ValidateInstall successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.ValidateInstall(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeployRequestBodyOverrideValues model
				deployRequestBodyOverrideValuesModel := new(catalogmanagementv1.DeployRequestBodyOverrideValues)
				deployRequestBodyOverrideValuesModel.VsiInstanceName = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCProfile = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SubnetID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SubnetZone = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SSHKeyID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCRegion = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SetProperty("foo", core.StringPtr("testString"))

				// Construct an instance of the DeployRequestBodyEnvironmentVariablesItem model
				deployRequestBodyEnvironmentVariablesItemModel := new(catalogmanagementv1.DeployRequestBodyEnvironmentVariablesItem)
				deployRequestBodyEnvironmentVariablesItemModel.Name = core.StringPtr("testString")
				deployRequestBodyEnvironmentVariablesItemModel.Value = core.StringPtr("testString")
				deployRequestBodyEnvironmentVariablesItemModel.Secure = core.BoolPtr(true)

				// Construct an instance of the DeployRequestBodySchematics model
				deployRequestBodySchematicsModel := new(catalogmanagementv1.DeployRequestBodySchematics)
				deployRequestBodySchematicsModel.Name = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Description = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Tags = []string{"testString"}
				deployRequestBodySchematicsModel.ResourceGroupID = core.StringPtr("testString")
				deployRequestBodySchematicsModel.TerraformVersion = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Region = core.StringPtr("testString")

				// Construct an instance of the ValidateInstallOptions model
				validateInstallOptionsModel := new(catalogmanagementv1.ValidateInstallOptions)
				validateInstallOptionsModel.VersionLocID = core.StringPtr("testString")
				validateInstallOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				validateInstallOptionsModel.ClusterID = core.StringPtr("testString")
				validateInstallOptionsModel.Region = core.StringPtr("testString")
				validateInstallOptionsModel.Namespace = core.StringPtr("testString")
				validateInstallOptionsModel.OverrideValues = deployRequestBodyOverrideValuesModel
				validateInstallOptionsModel.EnvironmentVariables = []catalogmanagementv1.DeployRequestBodyEnvironmentVariablesItem{*deployRequestBodyEnvironmentVariablesItemModel}
				validateInstallOptionsModel.EntitlementApikey = core.StringPtr("testString")
				validateInstallOptionsModel.Schematics = deployRequestBodySchematicsModel
				validateInstallOptionsModel.Script = core.StringPtr("testString")
				validateInstallOptionsModel.ScriptID = core.StringPtr("testString")
				validateInstallOptionsModel.VersionLocatorID = core.StringPtr("testString")
				validateInstallOptionsModel.VcenterID = core.StringPtr("testString")
				validateInstallOptionsModel.VcenterLocation = core.StringPtr("testString")
				validateInstallOptionsModel.VcenterUser = core.StringPtr("testString")
				validateInstallOptionsModel.VcenterPassword = core.StringPtr("testString")
				validateInstallOptionsModel.VcenterDatastore = core.StringPtr("testString")
				validateInstallOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.ValidateInstall(validateInstallOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke ValidateInstall with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the DeployRequestBodyOverrideValues model
				deployRequestBodyOverrideValuesModel := new(catalogmanagementv1.DeployRequestBodyOverrideValues)
				deployRequestBodyOverrideValuesModel.VsiInstanceName = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCProfile = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SubnetID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SubnetZone = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SSHKeyID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCRegion = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SetProperty("foo", core.StringPtr("testString"))

				// Construct an instance of the DeployRequestBodyEnvironmentVariablesItem model
				deployRequestBodyEnvironmentVariablesItemModel := new(catalogmanagementv1.DeployRequestBodyEnvironmentVariablesItem)
				deployRequestBodyEnvironmentVariablesItemModel.Name = core.StringPtr("testString")
				deployRequestBodyEnvironmentVariablesItemModel.Value = core.StringPtr("testString")
				deployRequestBodyEnvironmentVariablesItemModel.Secure = core.BoolPtr(true)

				// Construct an instance of the DeployRequestBodySchematics model
				deployRequestBodySchematicsModel := new(catalogmanagementv1.DeployRequestBodySchematics)
				deployRequestBodySchematicsModel.Name = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Description = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Tags = []string{"testString"}
				deployRequestBodySchematicsModel.ResourceGroupID = core.StringPtr("testString")
				deployRequestBodySchematicsModel.TerraformVersion = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Region = core.StringPtr("testString")

				// Construct an instance of the ValidateInstallOptions model
				validateInstallOptionsModel := new(catalogmanagementv1.ValidateInstallOptions)
				validateInstallOptionsModel.VersionLocID = core.StringPtr("testString")
				validateInstallOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				validateInstallOptionsModel.ClusterID = core.StringPtr("testString")
				validateInstallOptionsModel.Region = core.StringPtr("testString")
				validateInstallOptionsModel.Namespace = core.StringPtr("testString")
				validateInstallOptionsModel.OverrideValues = deployRequestBodyOverrideValuesModel
				validateInstallOptionsModel.EnvironmentVariables = []catalogmanagementv1.DeployRequestBodyEnvironmentVariablesItem{*deployRequestBodyEnvironmentVariablesItemModel}
				validateInstallOptionsModel.EntitlementApikey = core.StringPtr("testString")
				validateInstallOptionsModel.Schematics = deployRequestBodySchematicsModel
				validateInstallOptionsModel.Script = core.StringPtr("testString")
				validateInstallOptionsModel.ScriptID = core.StringPtr("testString")
				validateInstallOptionsModel.VersionLocatorID = core.StringPtr("testString")
				validateInstallOptionsModel.VcenterID = core.StringPtr("testString")
				validateInstallOptionsModel.VcenterLocation = core.StringPtr("testString")
				validateInstallOptionsModel.VcenterUser = core.StringPtr("testString")
				validateInstallOptionsModel.VcenterPassword = core.StringPtr("testString")
				validateInstallOptionsModel.VcenterDatastore = core.StringPtr("testString")
				validateInstallOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.ValidateInstall(validateInstallOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the ValidateInstallOptions model with no property values
				validateInstallOptionsModelNew := new(catalogmanagementv1.ValidateInstallOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.ValidateInstall(validateInstallOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetValidationStatus(getValidationStatusOptions *GetValidationStatusOptions) - Operation response error`, func() {
		getValidationStatusPath := "/versions/testString/validation/install"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getValidationStatusPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetValidationStatus with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetValidationStatusOptions model
				getValidationStatusOptionsModel := new(catalogmanagementv1.GetValidationStatusOptions)
				getValidationStatusOptionsModel.VersionLocID = core.StringPtr("testString")
				getValidationStatusOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getValidationStatusOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetValidationStatus(getValidationStatusOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetValidationStatus(getValidationStatusOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetValidationStatus(getValidationStatusOptions *GetValidationStatusOptions)`, func() {
		getValidationStatusPath := "/versions/testString/validation/install"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getValidationStatusPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"mapKey": "anyValue"}, "message": "Message"}`)
				}))
			})
			It(`Invoke GetValidationStatus successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetValidationStatusOptions model
				getValidationStatusOptionsModel := new(catalogmanagementv1.GetValidationStatusOptions)
				getValidationStatusOptionsModel.VersionLocID = core.StringPtr("testString")
				getValidationStatusOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getValidationStatusOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetValidationStatusWithContext(ctx, getValidationStatusOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetValidationStatus(getValidationStatusOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetValidationStatusWithContext(ctx, getValidationStatusOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getValidationStatusPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"mapKey": "anyValue"}, "message": "Message"}`)
				}))
			})
			It(`Invoke GetValidationStatus successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetValidationStatus(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetValidationStatusOptions model
				getValidationStatusOptionsModel := new(catalogmanagementv1.GetValidationStatusOptions)
				getValidationStatusOptionsModel.VersionLocID = core.StringPtr("testString")
				getValidationStatusOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getValidationStatusOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetValidationStatus(getValidationStatusOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetValidationStatus with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetValidationStatusOptions model
				getValidationStatusOptionsModel := new(catalogmanagementv1.GetValidationStatusOptions)
				getValidationStatusOptionsModel.VersionLocID = core.StringPtr("testString")
				getValidationStatusOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getValidationStatusOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetValidationStatus(getValidationStatusOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetValidationStatusOptions model with no property values
				getValidationStatusOptionsModelNew := new(catalogmanagementv1.GetValidationStatusOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetValidationStatus(getValidationStatusOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetValidationStatus successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetValidationStatusOptions model
				getValidationStatusOptionsModel := new(catalogmanagementv1.GetValidationStatusOptions)
				getValidationStatusOptionsModel.VersionLocID = core.StringPtr("testString")
				getValidationStatusOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getValidationStatusOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetValidationStatus(getValidationStatusOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetOverrideValues(getOverrideValuesOptions *GetOverrideValuesOptions)`, func() {
		getOverrideValuesPath := "/versions/testString/validation/overridevalues"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOverrideValuesPath))
					Expect(req.Method).To(Equal("GET"))

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"mapKey": "anyValue"}`)
				}))
			})
			It(`Invoke GetOverrideValues successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetOverrideValuesOptions model
				getOverrideValuesOptionsModel := new(catalogmanagementv1.GetOverrideValuesOptions)
				getOverrideValuesOptionsModel.VersionLocID = core.StringPtr("testString")
				getOverrideValuesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetOverrideValuesWithContext(ctx, getOverrideValuesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetOverrideValues(getOverrideValuesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetOverrideValuesWithContext(ctx, getOverrideValuesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOverrideValuesPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"mapKey": "anyValue"}`)
				}))
			})
			It(`Invoke GetOverrideValues successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetOverrideValues(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetOverrideValuesOptions model
				getOverrideValuesOptionsModel := new(catalogmanagementv1.GetOverrideValuesOptions)
				getOverrideValuesOptionsModel.VersionLocID = core.StringPtr("testString")
				getOverrideValuesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetOverrideValues(getOverrideValuesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetOverrideValues with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOverrideValuesOptions model
				getOverrideValuesOptionsModel := new(catalogmanagementv1.GetOverrideValuesOptions)
				getOverrideValuesOptionsModel.VersionLocID = core.StringPtr("testString")
				getOverrideValuesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetOverrideValues(getOverrideValuesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetOverrideValuesOptions model with no property values
				getOverrideValuesOptionsModelNew := new(catalogmanagementv1.GetOverrideValuesOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetOverrideValues(getOverrideValuesOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetOverrideValues successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOverrideValuesOptions model
				getOverrideValuesOptionsModel := new(catalogmanagementv1.GetOverrideValuesOptions)
				getOverrideValuesOptionsModel.VersionLocID = core.StringPtr("testString")
				getOverrideValuesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetOverrideValues(getOverrideValuesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`SearchObjects(searchObjectsOptions *SearchObjectsOptions) - Operation response error`, func() {
		searchObjectsPath := "/objects"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(searchObjectsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.URL.Query()["query"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["kind"]).To(Equal([]string{"vpe"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(1000))}))
					Expect(req.URL.Query()["offset"]).To(Equal([]string{fmt.Sprint(int64(38))}))
					// TODO: Add check for collapse query parameter
					// TODO: Add check for digest query parameter
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke SearchObjects with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the SearchObjectsOptions model
				searchObjectsOptionsModel := new(catalogmanagementv1.SearchObjectsOptions)
				searchObjectsOptionsModel.Query = core.StringPtr("testString")
				searchObjectsOptionsModel.Kind = core.StringPtr("vpe")
				searchObjectsOptionsModel.Limit = core.Int64Ptr(int64(1000))
				searchObjectsOptionsModel.Offset = core.Int64Ptr(int64(38))
				searchObjectsOptionsModel.Collapse = core.BoolPtr(true)
				searchObjectsOptionsModel.Digest = core.BoolPtr(true)
				searchObjectsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.SearchObjects(searchObjectsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.SearchObjects(searchObjectsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`SearchObjects(searchObjectsOptions *SearchObjectsOptions)`, func() {
		searchObjectsPath := "/objects"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(searchObjectsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["query"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["kind"]).To(Equal([]string{"vpe"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(1000))}))
					Expect(req.URL.Query()["offset"]).To(Equal([]string{fmt.Sprint(int64(38))}))
					// TODO: Add check for collapse query parameter
					// TODO: Add check for digest query parameter
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"offset": 6, "limit": 5, "total_count": 10, "resource_count": 13, "first": "First", "last": "Last", "prev": "Prev", "next": "Next", "resources": [{"id": "ID", "name": "Name", "_rev": "Rev", "crn": "CRN", "url": "URL", "parent_id": "ParentID", "label_i18n": {"mapKey": "Inner"}, "label": "Label", "tags": ["Tags"], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "kind": "Kind", "publish": {"permit_ibm_public_publish": true, "ibm_approved": false, "public_approved": true, "portal_approval_record": "PortalApprovalRecord", "portal_url": "PortalURL"}, "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "catalog_id": "CatalogID", "catalog_name": "CatalogName", "data": {"mapKey": "anyValue"}}]}`)
				}))
			})
			It(`Invoke SearchObjects successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the SearchObjectsOptions model
				searchObjectsOptionsModel := new(catalogmanagementv1.SearchObjectsOptions)
				searchObjectsOptionsModel.Query = core.StringPtr("testString")
				searchObjectsOptionsModel.Kind = core.StringPtr("vpe")
				searchObjectsOptionsModel.Limit = core.Int64Ptr(int64(1000))
				searchObjectsOptionsModel.Offset = core.Int64Ptr(int64(38))
				searchObjectsOptionsModel.Collapse = core.BoolPtr(true)
				searchObjectsOptionsModel.Digest = core.BoolPtr(true)
				searchObjectsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.SearchObjectsWithContext(ctx, searchObjectsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.SearchObjects(searchObjectsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.SearchObjectsWithContext(ctx, searchObjectsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(searchObjectsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["query"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["kind"]).To(Equal([]string{"vpe"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(1000))}))
					Expect(req.URL.Query()["offset"]).To(Equal([]string{fmt.Sprint(int64(38))}))
					// TODO: Add check for collapse query parameter
					// TODO: Add check for digest query parameter
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"offset": 6, "limit": 5, "total_count": 10, "resource_count": 13, "first": "First", "last": "Last", "prev": "Prev", "next": "Next", "resources": [{"id": "ID", "name": "Name", "_rev": "Rev", "crn": "CRN", "url": "URL", "parent_id": "ParentID", "label_i18n": {"mapKey": "Inner"}, "label": "Label", "tags": ["Tags"], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "kind": "Kind", "publish": {"permit_ibm_public_publish": true, "ibm_approved": false, "public_approved": true, "portal_approval_record": "PortalApprovalRecord", "portal_url": "PortalURL"}, "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "catalog_id": "CatalogID", "catalog_name": "CatalogName", "data": {"mapKey": "anyValue"}}]}`)
				}))
			})
			It(`Invoke SearchObjects successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.SearchObjects(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the SearchObjectsOptions model
				searchObjectsOptionsModel := new(catalogmanagementv1.SearchObjectsOptions)
				searchObjectsOptionsModel.Query = core.StringPtr("testString")
				searchObjectsOptionsModel.Kind = core.StringPtr("vpe")
				searchObjectsOptionsModel.Limit = core.Int64Ptr(int64(1000))
				searchObjectsOptionsModel.Offset = core.Int64Ptr(int64(38))
				searchObjectsOptionsModel.Collapse = core.BoolPtr(true)
				searchObjectsOptionsModel.Digest = core.BoolPtr(true)
				searchObjectsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.SearchObjects(searchObjectsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke SearchObjects with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the SearchObjectsOptions model
				searchObjectsOptionsModel := new(catalogmanagementv1.SearchObjectsOptions)
				searchObjectsOptionsModel.Query = core.StringPtr("testString")
				searchObjectsOptionsModel.Kind = core.StringPtr("vpe")
				searchObjectsOptionsModel.Limit = core.Int64Ptr(int64(1000))
				searchObjectsOptionsModel.Offset = core.Int64Ptr(int64(38))
				searchObjectsOptionsModel.Collapse = core.BoolPtr(true)
				searchObjectsOptionsModel.Digest = core.BoolPtr(true)
				searchObjectsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.SearchObjects(searchObjectsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the SearchObjectsOptions model with no property values
				searchObjectsOptionsModelNew := new(catalogmanagementv1.SearchObjectsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.SearchObjects(searchObjectsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke SearchObjects successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the SearchObjectsOptions model
				searchObjectsOptionsModel := new(catalogmanagementv1.SearchObjectsOptions)
				searchObjectsOptionsModel.Query = core.StringPtr("testString")
				searchObjectsOptionsModel.Kind = core.StringPtr("vpe")
				searchObjectsOptionsModel.Limit = core.Int64Ptr(int64(1000))
				searchObjectsOptionsModel.Offset = core.Int64Ptr(int64(38))
				searchObjectsOptionsModel.Collapse = core.BoolPtr(true)
				searchObjectsOptionsModel.Digest = core.BoolPtr(true)
				searchObjectsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.SearchObjects(searchObjectsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListObjects(listObjectsOptions *ListObjectsOptions) - Operation response error`, func() {
		listObjectsPath := "/catalogs/testString/objects"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listObjectsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(1000))}))
					Expect(req.URL.Query()["offset"]).To(Equal([]string{fmt.Sprint(int64(38))}))
					Expect(req.URL.Query()["name"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["sort"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListObjects with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListObjectsOptions model
				listObjectsOptionsModel := new(catalogmanagementv1.ListObjectsOptions)
				listObjectsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listObjectsOptionsModel.Limit = core.Int64Ptr(int64(1000))
				listObjectsOptionsModel.Offset = core.Int64Ptr(int64(38))
				listObjectsOptionsModel.Name = core.StringPtr("testString")
				listObjectsOptionsModel.Sort = core.StringPtr("testString")
				listObjectsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.ListObjects(listObjectsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.ListObjects(listObjectsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListObjects(listObjectsOptions *ListObjectsOptions)`, func() {
		listObjectsPath := "/catalogs/testString/objects"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listObjectsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(1000))}))
					Expect(req.URL.Query()["offset"]).To(Equal([]string{fmt.Sprint(int64(38))}))
					Expect(req.URL.Query()["name"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["sort"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"offset": 6, "limit": 5, "total_count": 10, "resource_count": 13, "first": "First", "last": "Last", "prev": "Prev", "next": "Next", "resources": [{"id": "ID", "name": "Name", "_rev": "Rev", "crn": "CRN", "url": "URL", "parent_id": "ParentID", "label_i18n": {"mapKey": "Inner"}, "label": "Label", "tags": ["Tags"], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "kind": "Kind", "publish": {"permit_ibm_public_publish": true, "ibm_approved": false, "public_approved": true, "portal_approval_record": "PortalApprovalRecord", "portal_url": "PortalURL"}, "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "catalog_id": "CatalogID", "catalog_name": "CatalogName", "data": {"mapKey": "anyValue"}}]}`)
				}))
			})
			It(`Invoke ListObjects successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the ListObjectsOptions model
				listObjectsOptionsModel := new(catalogmanagementv1.ListObjectsOptions)
				listObjectsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listObjectsOptionsModel.Limit = core.Int64Ptr(int64(1000))
				listObjectsOptionsModel.Offset = core.Int64Ptr(int64(38))
				listObjectsOptionsModel.Name = core.StringPtr("testString")
				listObjectsOptionsModel.Sort = core.StringPtr("testString")
				listObjectsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.ListObjectsWithContext(ctx, listObjectsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.ListObjects(listObjectsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.ListObjectsWithContext(ctx, listObjectsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listObjectsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(1000))}))
					Expect(req.URL.Query()["offset"]).To(Equal([]string{fmt.Sprint(int64(38))}))
					Expect(req.URL.Query()["name"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["sort"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"offset": 6, "limit": 5, "total_count": 10, "resource_count": 13, "first": "First", "last": "Last", "prev": "Prev", "next": "Next", "resources": [{"id": "ID", "name": "Name", "_rev": "Rev", "crn": "CRN", "url": "URL", "parent_id": "ParentID", "label_i18n": {"mapKey": "Inner"}, "label": "Label", "tags": ["Tags"], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "kind": "Kind", "publish": {"permit_ibm_public_publish": true, "ibm_approved": false, "public_approved": true, "portal_approval_record": "PortalApprovalRecord", "portal_url": "PortalURL"}, "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "catalog_id": "CatalogID", "catalog_name": "CatalogName", "data": {"mapKey": "anyValue"}}]}`)
				}))
			})
			It(`Invoke ListObjects successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.ListObjects(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListObjectsOptions model
				listObjectsOptionsModel := new(catalogmanagementv1.ListObjectsOptions)
				listObjectsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listObjectsOptionsModel.Limit = core.Int64Ptr(int64(1000))
				listObjectsOptionsModel.Offset = core.Int64Ptr(int64(38))
				listObjectsOptionsModel.Name = core.StringPtr("testString")
				listObjectsOptionsModel.Sort = core.StringPtr("testString")
				listObjectsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.ListObjects(listObjectsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListObjects with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListObjectsOptions model
				listObjectsOptionsModel := new(catalogmanagementv1.ListObjectsOptions)
				listObjectsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listObjectsOptionsModel.Limit = core.Int64Ptr(int64(1000))
				listObjectsOptionsModel.Offset = core.Int64Ptr(int64(38))
				listObjectsOptionsModel.Name = core.StringPtr("testString")
				listObjectsOptionsModel.Sort = core.StringPtr("testString")
				listObjectsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.ListObjects(listObjectsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ListObjectsOptions model with no property values
				listObjectsOptionsModelNew := new(catalogmanagementv1.ListObjectsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.ListObjects(listObjectsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListObjects successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListObjectsOptions model
				listObjectsOptionsModel := new(catalogmanagementv1.ListObjectsOptions)
				listObjectsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listObjectsOptionsModel.Limit = core.Int64Ptr(int64(1000))
				listObjectsOptionsModel.Offset = core.Int64Ptr(int64(38))
				listObjectsOptionsModel.Name = core.StringPtr("testString")
				listObjectsOptionsModel.Sort = core.StringPtr("testString")
				listObjectsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.ListObjects(listObjectsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateObject(createObjectOptions *CreateObjectOptions) - Operation response error`, func() {
		createObjectPath := "/catalogs/testString/objects"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createObjectPath))
					Expect(req.Method).To(Equal("POST"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateObject with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the PublishObject model
				publishObjectModel := new(catalogmanagementv1.PublishObject)
				publishObjectModel.PermitIBMPublicPublish = core.BoolPtr(true)
				publishObjectModel.IBMApproved = core.BoolPtr(true)
				publishObjectModel.PublicApproved = core.BoolPtr(true)
				publishObjectModel.PortalApprovalRecord = core.StringPtr("testString")
				publishObjectModel.PortalURL = core.StringPtr("testString")

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")

				// Construct an instance of the CreateObjectOptions model
				createObjectOptionsModel := new(catalogmanagementv1.CreateObjectOptions)
				createObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				createObjectOptionsModel.ID = core.StringPtr("testString")
				createObjectOptionsModel.Name = core.StringPtr("testString")
				createObjectOptionsModel.Rev = core.StringPtr("testString")
				createObjectOptionsModel.CRN = core.StringPtr("testString")
				createObjectOptionsModel.URL = core.StringPtr("testString")
				createObjectOptionsModel.ParentID = core.StringPtr("testString")
				createObjectOptionsModel.LabelI18n = make(map[string]string)
				createObjectOptionsModel.Label = core.StringPtr("testString")
				createObjectOptionsModel.Tags = []string{"testString"}
				createObjectOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createObjectOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createObjectOptionsModel.ShortDescription = core.StringPtr("testString")
				createObjectOptionsModel.ShortDescriptionI18n = make(map[string]string)
				createObjectOptionsModel.Kind = core.StringPtr("testString")
				createObjectOptionsModel.Publish = publishObjectModel
				createObjectOptionsModel.State = stateModel
				createObjectOptionsModel.CatalogID = core.StringPtr("testString")
				createObjectOptionsModel.CatalogName = core.StringPtr("testString")
				createObjectOptionsModel.Data = make(map[string]interface{})
				createObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.CreateObject(createObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.CreateObject(createObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateObject(createObjectOptions *CreateObjectOptions)`, func() {
		createObjectPath := "/catalogs/testString/objects"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createObjectPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"id": "ID", "name": "Name", "_rev": "Rev", "crn": "CRN", "url": "URL", "parent_id": "ParentID", "label_i18n": {"mapKey": "Inner"}, "label": "Label", "tags": ["Tags"], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "kind": "Kind", "publish": {"permit_ibm_public_publish": true, "ibm_approved": false, "public_approved": true, "portal_approval_record": "PortalApprovalRecord", "portal_url": "PortalURL"}, "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "catalog_id": "CatalogID", "catalog_name": "CatalogName", "data": {"mapKey": "anyValue"}}`)
				}))
			})
			It(`Invoke CreateObject successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the PublishObject model
				publishObjectModel := new(catalogmanagementv1.PublishObject)
				publishObjectModel.PermitIBMPublicPublish = core.BoolPtr(true)
				publishObjectModel.IBMApproved = core.BoolPtr(true)
				publishObjectModel.PublicApproved = core.BoolPtr(true)
				publishObjectModel.PortalApprovalRecord = core.StringPtr("testString")
				publishObjectModel.PortalURL = core.StringPtr("testString")

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")

				// Construct an instance of the CreateObjectOptions model
				createObjectOptionsModel := new(catalogmanagementv1.CreateObjectOptions)
				createObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				createObjectOptionsModel.ID = core.StringPtr("testString")
				createObjectOptionsModel.Name = core.StringPtr("testString")
				createObjectOptionsModel.Rev = core.StringPtr("testString")
				createObjectOptionsModel.CRN = core.StringPtr("testString")
				createObjectOptionsModel.URL = core.StringPtr("testString")
				createObjectOptionsModel.ParentID = core.StringPtr("testString")
				createObjectOptionsModel.LabelI18n = make(map[string]string)
				createObjectOptionsModel.Label = core.StringPtr("testString")
				createObjectOptionsModel.Tags = []string{"testString"}
				createObjectOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createObjectOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createObjectOptionsModel.ShortDescription = core.StringPtr("testString")
				createObjectOptionsModel.ShortDescriptionI18n = make(map[string]string)
				createObjectOptionsModel.Kind = core.StringPtr("testString")
				createObjectOptionsModel.Publish = publishObjectModel
				createObjectOptionsModel.State = stateModel
				createObjectOptionsModel.CatalogID = core.StringPtr("testString")
				createObjectOptionsModel.CatalogName = core.StringPtr("testString")
				createObjectOptionsModel.Data = make(map[string]interface{})
				createObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.CreateObjectWithContext(ctx, createObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.CreateObject(createObjectOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.CreateObjectWithContext(ctx, createObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createObjectPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"id": "ID", "name": "Name", "_rev": "Rev", "crn": "CRN", "url": "URL", "parent_id": "ParentID", "label_i18n": {"mapKey": "Inner"}, "label": "Label", "tags": ["Tags"], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "kind": "Kind", "publish": {"permit_ibm_public_publish": true, "ibm_approved": false, "public_approved": true, "portal_approval_record": "PortalApprovalRecord", "portal_url": "PortalURL"}, "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "catalog_id": "CatalogID", "catalog_name": "CatalogName", "data": {"mapKey": "anyValue"}}`)
				}))
			})
			It(`Invoke CreateObject successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.CreateObject(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the PublishObject model
				publishObjectModel := new(catalogmanagementv1.PublishObject)
				publishObjectModel.PermitIBMPublicPublish = core.BoolPtr(true)
				publishObjectModel.IBMApproved = core.BoolPtr(true)
				publishObjectModel.PublicApproved = core.BoolPtr(true)
				publishObjectModel.PortalApprovalRecord = core.StringPtr("testString")
				publishObjectModel.PortalURL = core.StringPtr("testString")

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")

				// Construct an instance of the CreateObjectOptions model
				createObjectOptionsModel := new(catalogmanagementv1.CreateObjectOptions)
				createObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				createObjectOptionsModel.ID = core.StringPtr("testString")
				createObjectOptionsModel.Name = core.StringPtr("testString")
				createObjectOptionsModel.Rev = core.StringPtr("testString")
				createObjectOptionsModel.CRN = core.StringPtr("testString")
				createObjectOptionsModel.URL = core.StringPtr("testString")
				createObjectOptionsModel.ParentID = core.StringPtr("testString")
				createObjectOptionsModel.LabelI18n = make(map[string]string)
				createObjectOptionsModel.Label = core.StringPtr("testString")
				createObjectOptionsModel.Tags = []string{"testString"}
				createObjectOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createObjectOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createObjectOptionsModel.ShortDescription = core.StringPtr("testString")
				createObjectOptionsModel.ShortDescriptionI18n = make(map[string]string)
				createObjectOptionsModel.Kind = core.StringPtr("testString")
				createObjectOptionsModel.Publish = publishObjectModel
				createObjectOptionsModel.State = stateModel
				createObjectOptionsModel.CatalogID = core.StringPtr("testString")
				createObjectOptionsModel.CatalogName = core.StringPtr("testString")
				createObjectOptionsModel.Data = make(map[string]interface{})
				createObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.CreateObject(createObjectOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateObject with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the PublishObject model
				publishObjectModel := new(catalogmanagementv1.PublishObject)
				publishObjectModel.PermitIBMPublicPublish = core.BoolPtr(true)
				publishObjectModel.IBMApproved = core.BoolPtr(true)
				publishObjectModel.PublicApproved = core.BoolPtr(true)
				publishObjectModel.PortalApprovalRecord = core.StringPtr("testString")
				publishObjectModel.PortalURL = core.StringPtr("testString")

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")

				// Construct an instance of the CreateObjectOptions model
				createObjectOptionsModel := new(catalogmanagementv1.CreateObjectOptions)
				createObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				createObjectOptionsModel.ID = core.StringPtr("testString")
				createObjectOptionsModel.Name = core.StringPtr("testString")
				createObjectOptionsModel.Rev = core.StringPtr("testString")
				createObjectOptionsModel.CRN = core.StringPtr("testString")
				createObjectOptionsModel.URL = core.StringPtr("testString")
				createObjectOptionsModel.ParentID = core.StringPtr("testString")
				createObjectOptionsModel.LabelI18n = make(map[string]string)
				createObjectOptionsModel.Label = core.StringPtr("testString")
				createObjectOptionsModel.Tags = []string{"testString"}
				createObjectOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createObjectOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createObjectOptionsModel.ShortDescription = core.StringPtr("testString")
				createObjectOptionsModel.ShortDescriptionI18n = make(map[string]string)
				createObjectOptionsModel.Kind = core.StringPtr("testString")
				createObjectOptionsModel.Publish = publishObjectModel
				createObjectOptionsModel.State = stateModel
				createObjectOptionsModel.CatalogID = core.StringPtr("testString")
				createObjectOptionsModel.CatalogName = core.StringPtr("testString")
				createObjectOptionsModel.Data = make(map[string]interface{})
				createObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.CreateObject(createObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreateObjectOptions model with no property values
				createObjectOptionsModelNew := new(catalogmanagementv1.CreateObjectOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.CreateObject(createObjectOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreateObject successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the PublishObject model
				publishObjectModel := new(catalogmanagementv1.PublishObject)
				publishObjectModel.PermitIBMPublicPublish = core.BoolPtr(true)
				publishObjectModel.IBMApproved = core.BoolPtr(true)
				publishObjectModel.PublicApproved = core.BoolPtr(true)
				publishObjectModel.PortalApprovalRecord = core.StringPtr("testString")
				publishObjectModel.PortalURL = core.StringPtr("testString")

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")

				// Construct an instance of the CreateObjectOptions model
				createObjectOptionsModel := new(catalogmanagementv1.CreateObjectOptions)
				createObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				createObjectOptionsModel.ID = core.StringPtr("testString")
				createObjectOptionsModel.Name = core.StringPtr("testString")
				createObjectOptionsModel.Rev = core.StringPtr("testString")
				createObjectOptionsModel.CRN = core.StringPtr("testString")
				createObjectOptionsModel.URL = core.StringPtr("testString")
				createObjectOptionsModel.ParentID = core.StringPtr("testString")
				createObjectOptionsModel.LabelI18n = make(map[string]string)
				createObjectOptionsModel.Label = core.StringPtr("testString")
				createObjectOptionsModel.Tags = []string{"testString"}
				createObjectOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createObjectOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createObjectOptionsModel.ShortDescription = core.StringPtr("testString")
				createObjectOptionsModel.ShortDescriptionI18n = make(map[string]string)
				createObjectOptionsModel.Kind = core.StringPtr("testString")
				createObjectOptionsModel.Publish = publishObjectModel
				createObjectOptionsModel.State = stateModel
				createObjectOptionsModel.CatalogID = core.StringPtr("testString")
				createObjectOptionsModel.CatalogName = core.StringPtr("testString")
				createObjectOptionsModel.Data = make(map[string]interface{})
				createObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.CreateObject(createObjectOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetObject(getObjectOptions *GetObjectOptions) - Operation response error`, func() {
		getObjectPath := "/catalogs/testString/objects/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getObjectPath))
					Expect(req.Method).To(Equal("GET"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetObject with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetObjectOptions model
				getObjectOptionsModel := new(catalogmanagementv1.GetObjectOptions)
				getObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetObject(getObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetObject(getObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetObject(getObjectOptions *GetObjectOptions)`, func() {
		getObjectPath := "/catalogs/testString/objects/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getObjectPath))
					Expect(req.Method).To(Equal("GET"))

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "name": "Name", "_rev": "Rev", "crn": "CRN", "url": "URL", "parent_id": "ParentID", "label_i18n": {"mapKey": "Inner"}, "label": "Label", "tags": ["Tags"], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "kind": "Kind", "publish": {"permit_ibm_public_publish": true, "ibm_approved": false, "public_approved": true, "portal_approval_record": "PortalApprovalRecord", "portal_url": "PortalURL"}, "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "catalog_id": "CatalogID", "catalog_name": "CatalogName", "data": {"mapKey": "anyValue"}}`)
				}))
			})
			It(`Invoke GetObject successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetObjectOptions model
				getObjectOptionsModel := new(catalogmanagementv1.GetObjectOptions)
				getObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetObjectWithContext(ctx, getObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetObject(getObjectOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetObjectWithContext(ctx, getObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getObjectPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "name": "Name", "_rev": "Rev", "crn": "CRN", "url": "URL", "parent_id": "ParentID", "label_i18n": {"mapKey": "Inner"}, "label": "Label", "tags": ["Tags"], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "kind": "Kind", "publish": {"permit_ibm_public_publish": true, "ibm_approved": false, "public_approved": true, "portal_approval_record": "PortalApprovalRecord", "portal_url": "PortalURL"}, "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "catalog_id": "CatalogID", "catalog_name": "CatalogName", "data": {"mapKey": "anyValue"}}`)
				}))
			})
			It(`Invoke GetObject successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetObject(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetObjectOptions model
				getObjectOptionsModel := new(catalogmanagementv1.GetObjectOptions)
				getObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetObject(getObjectOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetObject with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetObjectOptions model
				getObjectOptionsModel := new(catalogmanagementv1.GetObjectOptions)
				getObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetObject(getObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetObjectOptions model with no property values
				getObjectOptionsModelNew := new(catalogmanagementv1.GetObjectOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetObject(getObjectOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetObject successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetObjectOptions model
				getObjectOptionsModel := new(catalogmanagementv1.GetObjectOptions)
				getObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetObject(getObjectOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ReplaceObject(replaceObjectOptions *ReplaceObjectOptions) - Operation response error`, func() {
		replaceObjectPath := "/catalogs/testString/objects/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(replaceObjectPath))
					Expect(req.Method).To(Equal("PUT"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ReplaceObject with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the PublishObject model
				publishObjectModel := new(catalogmanagementv1.PublishObject)
				publishObjectModel.PermitIBMPublicPublish = core.BoolPtr(true)
				publishObjectModel.IBMApproved = core.BoolPtr(true)
				publishObjectModel.PublicApproved = core.BoolPtr(true)
				publishObjectModel.PortalApprovalRecord = core.StringPtr("testString")
				publishObjectModel.PortalURL = core.StringPtr("testString")

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")

				// Construct an instance of the ReplaceObjectOptions model
				replaceObjectOptionsModel := new(catalogmanagementv1.ReplaceObjectOptions)
				replaceObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				replaceObjectOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				replaceObjectOptionsModel.ID = core.StringPtr("testString")
				replaceObjectOptionsModel.Name = core.StringPtr("testString")
				replaceObjectOptionsModel.Rev = core.StringPtr("testString")
				replaceObjectOptionsModel.CRN = core.StringPtr("testString")
				replaceObjectOptionsModel.URL = core.StringPtr("testString")
				replaceObjectOptionsModel.ParentID = core.StringPtr("testString")
				replaceObjectOptionsModel.LabelI18n = make(map[string]string)
				replaceObjectOptionsModel.Label = core.StringPtr("testString")
				replaceObjectOptionsModel.Tags = []string{"testString"}
				replaceObjectOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				replaceObjectOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				replaceObjectOptionsModel.ShortDescription = core.StringPtr("testString")
				replaceObjectOptionsModel.ShortDescriptionI18n = make(map[string]string)
				replaceObjectOptionsModel.Kind = core.StringPtr("testString")
				replaceObjectOptionsModel.Publish = publishObjectModel
				replaceObjectOptionsModel.State = stateModel
				replaceObjectOptionsModel.CatalogID = core.StringPtr("testString")
				replaceObjectOptionsModel.CatalogName = core.StringPtr("testString")
				replaceObjectOptionsModel.Data = make(map[string]interface{})
				replaceObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.ReplaceObject(replaceObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.ReplaceObject(replaceObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ReplaceObject(replaceObjectOptions *ReplaceObjectOptions)`, func() {
		replaceObjectPath := "/catalogs/testString/objects/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(replaceObjectPath))
					Expect(req.Method).To(Equal("PUT"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "name": "Name", "_rev": "Rev", "crn": "CRN", "url": "URL", "parent_id": "ParentID", "label_i18n": {"mapKey": "Inner"}, "label": "Label", "tags": ["Tags"], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "kind": "Kind", "publish": {"permit_ibm_public_publish": true, "ibm_approved": false, "public_approved": true, "portal_approval_record": "PortalApprovalRecord", "portal_url": "PortalURL"}, "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "catalog_id": "CatalogID", "catalog_name": "CatalogName", "data": {"mapKey": "anyValue"}}`)
				}))
			})
			It(`Invoke ReplaceObject successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the PublishObject model
				publishObjectModel := new(catalogmanagementv1.PublishObject)
				publishObjectModel.PermitIBMPublicPublish = core.BoolPtr(true)
				publishObjectModel.IBMApproved = core.BoolPtr(true)
				publishObjectModel.PublicApproved = core.BoolPtr(true)
				publishObjectModel.PortalApprovalRecord = core.StringPtr("testString")
				publishObjectModel.PortalURL = core.StringPtr("testString")

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")

				// Construct an instance of the ReplaceObjectOptions model
				replaceObjectOptionsModel := new(catalogmanagementv1.ReplaceObjectOptions)
				replaceObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				replaceObjectOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				replaceObjectOptionsModel.ID = core.StringPtr("testString")
				replaceObjectOptionsModel.Name = core.StringPtr("testString")
				replaceObjectOptionsModel.Rev = core.StringPtr("testString")
				replaceObjectOptionsModel.CRN = core.StringPtr("testString")
				replaceObjectOptionsModel.URL = core.StringPtr("testString")
				replaceObjectOptionsModel.ParentID = core.StringPtr("testString")
				replaceObjectOptionsModel.LabelI18n = make(map[string]string)
				replaceObjectOptionsModel.Label = core.StringPtr("testString")
				replaceObjectOptionsModel.Tags = []string{"testString"}
				replaceObjectOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				replaceObjectOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				replaceObjectOptionsModel.ShortDescription = core.StringPtr("testString")
				replaceObjectOptionsModel.ShortDescriptionI18n = make(map[string]string)
				replaceObjectOptionsModel.Kind = core.StringPtr("testString")
				replaceObjectOptionsModel.Publish = publishObjectModel
				replaceObjectOptionsModel.State = stateModel
				replaceObjectOptionsModel.CatalogID = core.StringPtr("testString")
				replaceObjectOptionsModel.CatalogName = core.StringPtr("testString")
				replaceObjectOptionsModel.Data = make(map[string]interface{})
				replaceObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.ReplaceObjectWithContext(ctx, replaceObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.ReplaceObject(replaceObjectOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.ReplaceObjectWithContext(ctx, replaceObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(replaceObjectPath))
					Expect(req.Method).To(Equal("PUT"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "name": "Name", "_rev": "Rev", "crn": "CRN", "url": "URL", "parent_id": "ParentID", "label_i18n": {"mapKey": "Inner"}, "label": "Label", "tags": ["Tags"], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "kind": "Kind", "publish": {"permit_ibm_public_publish": true, "ibm_approved": false, "public_approved": true, "portal_approval_record": "PortalApprovalRecord", "portal_url": "PortalURL"}, "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "catalog_id": "CatalogID", "catalog_name": "CatalogName", "data": {"mapKey": "anyValue"}}`)
				}))
			})
			It(`Invoke ReplaceObject successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.ReplaceObject(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the PublishObject model
				publishObjectModel := new(catalogmanagementv1.PublishObject)
				publishObjectModel.PermitIBMPublicPublish = core.BoolPtr(true)
				publishObjectModel.IBMApproved = core.BoolPtr(true)
				publishObjectModel.PublicApproved = core.BoolPtr(true)
				publishObjectModel.PortalApprovalRecord = core.StringPtr("testString")
				publishObjectModel.PortalURL = core.StringPtr("testString")

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")

				// Construct an instance of the ReplaceObjectOptions model
				replaceObjectOptionsModel := new(catalogmanagementv1.ReplaceObjectOptions)
				replaceObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				replaceObjectOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				replaceObjectOptionsModel.ID = core.StringPtr("testString")
				replaceObjectOptionsModel.Name = core.StringPtr("testString")
				replaceObjectOptionsModel.Rev = core.StringPtr("testString")
				replaceObjectOptionsModel.CRN = core.StringPtr("testString")
				replaceObjectOptionsModel.URL = core.StringPtr("testString")
				replaceObjectOptionsModel.ParentID = core.StringPtr("testString")
				replaceObjectOptionsModel.LabelI18n = make(map[string]string)
				replaceObjectOptionsModel.Label = core.StringPtr("testString")
				replaceObjectOptionsModel.Tags = []string{"testString"}
				replaceObjectOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				replaceObjectOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				replaceObjectOptionsModel.ShortDescription = core.StringPtr("testString")
				replaceObjectOptionsModel.ShortDescriptionI18n = make(map[string]string)
				replaceObjectOptionsModel.Kind = core.StringPtr("testString")
				replaceObjectOptionsModel.Publish = publishObjectModel
				replaceObjectOptionsModel.State = stateModel
				replaceObjectOptionsModel.CatalogID = core.StringPtr("testString")
				replaceObjectOptionsModel.CatalogName = core.StringPtr("testString")
				replaceObjectOptionsModel.Data = make(map[string]interface{})
				replaceObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.ReplaceObject(replaceObjectOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ReplaceObject with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the PublishObject model
				publishObjectModel := new(catalogmanagementv1.PublishObject)
				publishObjectModel.PermitIBMPublicPublish = core.BoolPtr(true)
				publishObjectModel.IBMApproved = core.BoolPtr(true)
				publishObjectModel.PublicApproved = core.BoolPtr(true)
				publishObjectModel.PortalApprovalRecord = core.StringPtr("testString")
				publishObjectModel.PortalURL = core.StringPtr("testString")

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")

				// Construct an instance of the ReplaceObjectOptions model
				replaceObjectOptionsModel := new(catalogmanagementv1.ReplaceObjectOptions)
				replaceObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				replaceObjectOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				replaceObjectOptionsModel.ID = core.StringPtr("testString")
				replaceObjectOptionsModel.Name = core.StringPtr("testString")
				replaceObjectOptionsModel.Rev = core.StringPtr("testString")
				replaceObjectOptionsModel.CRN = core.StringPtr("testString")
				replaceObjectOptionsModel.URL = core.StringPtr("testString")
				replaceObjectOptionsModel.ParentID = core.StringPtr("testString")
				replaceObjectOptionsModel.LabelI18n = make(map[string]string)
				replaceObjectOptionsModel.Label = core.StringPtr("testString")
				replaceObjectOptionsModel.Tags = []string{"testString"}
				replaceObjectOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				replaceObjectOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				replaceObjectOptionsModel.ShortDescription = core.StringPtr("testString")
				replaceObjectOptionsModel.ShortDescriptionI18n = make(map[string]string)
				replaceObjectOptionsModel.Kind = core.StringPtr("testString")
				replaceObjectOptionsModel.Publish = publishObjectModel
				replaceObjectOptionsModel.State = stateModel
				replaceObjectOptionsModel.CatalogID = core.StringPtr("testString")
				replaceObjectOptionsModel.CatalogName = core.StringPtr("testString")
				replaceObjectOptionsModel.Data = make(map[string]interface{})
				replaceObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.ReplaceObject(replaceObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ReplaceObjectOptions model with no property values
				replaceObjectOptionsModelNew := new(catalogmanagementv1.ReplaceObjectOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.ReplaceObject(replaceObjectOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ReplaceObject successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the PublishObject model
				publishObjectModel := new(catalogmanagementv1.PublishObject)
				publishObjectModel.PermitIBMPublicPublish = core.BoolPtr(true)
				publishObjectModel.IBMApproved = core.BoolPtr(true)
				publishObjectModel.PublicApproved = core.BoolPtr(true)
				publishObjectModel.PortalApprovalRecord = core.StringPtr("testString")
				publishObjectModel.PortalURL = core.StringPtr("testString")

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")

				// Construct an instance of the ReplaceObjectOptions model
				replaceObjectOptionsModel := new(catalogmanagementv1.ReplaceObjectOptions)
				replaceObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				replaceObjectOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				replaceObjectOptionsModel.ID = core.StringPtr("testString")
				replaceObjectOptionsModel.Name = core.StringPtr("testString")
				replaceObjectOptionsModel.Rev = core.StringPtr("testString")
				replaceObjectOptionsModel.CRN = core.StringPtr("testString")
				replaceObjectOptionsModel.URL = core.StringPtr("testString")
				replaceObjectOptionsModel.ParentID = core.StringPtr("testString")
				replaceObjectOptionsModel.LabelI18n = make(map[string]string)
				replaceObjectOptionsModel.Label = core.StringPtr("testString")
				replaceObjectOptionsModel.Tags = []string{"testString"}
				replaceObjectOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				replaceObjectOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				replaceObjectOptionsModel.ShortDescription = core.StringPtr("testString")
				replaceObjectOptionsModel.ShortDescriptionI18n = make(map[string]string)
				replaceObjectOptionsModel.Kind = core.StringPtr("testString")
				replaceObjectOptionsModel.Publish = publishObjectModel
				replaceObjectOptionsModel.State = stateModel
				replaceObjectOptionsModel.CatalogID = core.StringPtr("testString")
				replaceObjectOptionsModel.CatalogName = core.StringPtr("testString")
				replaceObjectOptionsModel.Data = make(map[string]interface{})
				replaceObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.ReplaceObject(replaceObjectOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteObject(deleteObjectOptions *DeleteObjectOptions)`, func() {
		deleteObjectPath := "/catalogs/testString/objects/testString"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteObjectPath))
					Expect(req.Method).To(Equal("DELETE"))

					res.WriteHeader(200)
				}))
			})
			It(`Invoke DeleteObject successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.DeleteObject(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteObjectOptions model
				deleteObjectOptionsModel := new(catalogmanagementv1.DeleteObjectOptions)
				deleteObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				deleteObjectOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				deleteObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.DeleteObject(deleteObjectOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteObject with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the DeleteObjectOptions model
				deleteObjectOptionsModel := new(catalogmanagementv1.DeleteObjectOptions)
				deleteObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				deleteObjectOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				deleteObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.DeleteObject(deleteObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeleteObjectOptions model with no property values
				deleteObjectOptionsModelNew := new(catalogmanagementv1.DeleteObjectOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.DeleteObject(deleteObjectOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListObjectAudits(listObjectAuditsOptions *ListObjectAuditsOptions) - Operation response error`, func() {
		listObjectAuditsPath := "/catalogs/testString/objects/testString/audits"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listObjectAuditsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// TODO: Add check for lookupnames query parameter
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListObjectAudits with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListObjectAuditsOptions model
				listObjectAuditsOptionsModel := new(catalogmanagementv1.ListObjectAuditsOptions)
				listObjectAuditsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listObjectAuditsOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				listObjectAuditsOptionsModel.Start = core.StringPtr("testString")
				listObjectAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listObjectAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listObjectAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.ListObjectAudits(listObjectAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.ListObjectAudits(listObjectAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListObjectAudits(listObjectAuditsOptions *ListObjectAuditsOptions)`, func() {
		listObjectAuditsPath := "/catalogs/testString/objects/testString/audits"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listObjectAuditsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// TODO: Add check for lookupnames query parameter
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"start": "Start", "limit": 5, "total_count": 10, "resource_count": 13, "first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}, "prev": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}, "audits": [{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message"}]}`)
				}))
			})
			It(`Invoke ListObjectAudits successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the ListObjectAuditsOptions model
				listObjectAuditsOptionsModel := new(catalogmanagementv1.ListObjectAuditsOptions)
				listObjectAuditsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listObjectAuditsOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				listObjectAuditsOptionsModel.Start = core.StringPtr("testString")
				listObjectAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listObjectAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listObjectAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.ListObjectAuditsWithContext(ctx, listObjectAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.ListObjectAudits(listObjectAuditsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.ListObjectAuditsWithContext(ctx, listObjectAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listObjectAuditsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// TODO: Add check for lookupnames query parameter
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"start": "Start", "limit": 5, "total_count": 10, "resource_count": 13, "first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}, "prev": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}, "audits": [{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message"}]}`)
				}))
			})
			It(`Invoke ListObjectAudits successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.ListObjectAudits(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListObjectAuditsOptions model
				listObjectAuditsOptionsModel := new(catalogmanagementv1.ListObjectAuditsOptions)
				listObjectAuditsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listObjectAuditsOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				listObjectAuditsOptionsModel.Start = core.StringPtr("testString")
				listObjectAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listObjectAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listObjectAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.ListObjectAudits(listObjectAuditsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListObjectAudits with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListObjectAuditsOptions model
				listObjectAuditsOptionsModel := new(catalogmanagementv1.ListObjectAuditsOptions)
				listObjectAuditsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listObjectAuditsOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				listObjectAuditsOptionsModel.Start = core.StringPtr("testString")
				listObjectAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listObjectAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listObjectAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.ListObjectAudits(listObjectAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ListObjectAuditsOptions model with no property values
				listObjectAuditsOptionsModelNew := new(catalogmanagementv1.ListObjectAuditsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.ListObjectAudits(listObjectAuditsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListObjectAudits successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListObjectAuditsOptions model
				listObjectAuditsOptionsModel := new(catalogmanagementv1.ListObjectAuditsOptions)
				listObjectAuditsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listObjectAuditsOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				listObjectAuditsOptionsModel.Start = core.StringPtr("testString")
				listObjectAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listObjectAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listObjectAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.ListObjectAudits(listObjectAuditsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Test pagination helper method on response`, func() {
			It(`Invoke GetNextStart successfully`, func() {
				responseObject := new(catalogmanagementv1.AuditLogs)
				nextObject := new(catalogmanagementv1.PaginationTokenLink)
				nextObject.Start = core.StringPtr("abc-123")
				responseObject.Next = nextObject
	
				value, err := responseObject.GetNextStart()
				Expect(err).To(BeNil())
				Expect(value).To(Equal(core.StringPtr("abc-123")))
			})
			It(`Invoke GetNextStart without a "Next" property in the response`, func() {
				responseObject := new(catalogmanagementv1.AuditLogs)
	
				value, err := responseObject.GetNextStart()
				Expect(err).To(BeNil())
				Expect(value).To(BeNil())
			})
		})
		Context(`Using mock server endpoint - paginated response`, func() {
			BeforeEach(func() {
				var requestNumber int = 0
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listObjectAuditsPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					requestNumber++
					if requestNumber == 1 {
						fmt.Fprintf(res, "%s", `{"next":{"start":"1"},"total_count":2,"limit":1,"audits":[{"id":"ID","_rev":"Rev","created":"2019-01-01T12:00:00.000Z","change_type":"ChangeType","target_type":"TargetType","target_id":"TargetID","who_email":"WhoEmail","who_delegate_email":"WhoDelegateEmail","message":"Message"}]}`)
					} else if requestNumber == 2 {
						fmt.Fprintf(res, "%s", `{"total_count":2,"limit":1,"audits":[{"id":"ID","_rev":"Rev","created":"2019-01-01T12:00:00.000Z","change_type":"ChangeType","target_type":"TargetType","target_id":"TargetID","who_email":"WhoEmail","who_delegate_email":"WhoDelegateEmail","message":"Message"}]}`)
					} else {
						res.WriteHeader(400)
					}
				}))
			})
			It(`Use ObjectAuditsPager.GetNext successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				listObjectAuditsOptionsModel := &catalogmanagementv1.ListObjectAuditsOptions{
					CatalogIdentifier: core.StringPtr("testString"),
					ObjectIdentifier: core.StringPtr("testString"),
					Limit: core.Int64Ptr(int64(10)),
					Lookupnames: core.BoolPtr(true),
				}

				pager, err := catalogManagementService.NewObjectAuditsPager(listObjectAuditsOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				var allResults []catalogmanagementv1.AuditLogDigest
				for pager.HasNext() {
					nextPage, err := pager.GetNext()
					Expect(err).To(BeNil())
					Expect(nextPage).ToNot(BeNil())
					allResults = append(allResults, nextPage...)
				}
				Expect(len(allResults)).To(Equal(2))
			})
			It(`Use ObjectAuditsPager.GetAll successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				listObjectAuditsOptionsModel := &catalogmanagementv1.ListObjectAuditsOptions{
					CatalogIdentifier: core.StringPtr("testString"),
					ObjectIdentifier: core.StringPtr("testString"),
					Limit: core.Int64Ptr(int64(10)),
					Lookupnames: core.BoolPtr(true),
				}

				pager, err := catalogManagementService.NewObjectAuditsPager(listObjectAuditsOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				allResults, err := pager.GetAll()
				Expect(err).To(BeNil())
				Expect(allResults).ToNot(BeNil())
				Expect(len(allResults)).To(Equal(2))
			})
		})
	})
	Describe(`GetObjectAudit(getObjectAuditOptions *GetObjectAuditOptions) - Operation response error`, func() {
		getObjectAuditPath := "/catalogs/testString/objects/testString/audits/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getObjectAuditPath))
					Expect(req.Method).To(Equal("GET"))
					// TODO: Add check for lookupnames query parameter
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetObjectAudit with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetObjectAuditOptions model
				getObjectAuditOptionsModel := new(catalogmanagementv1.GetObjectAuditOptions)
				getObjectAuditOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectAuditOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getObjectAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getObjectAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetObjectAudit(getObjectAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetObjectAudit(getObjectAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetObjectAudit(getObjectAuditOptions *GetObjectAuditOptions)`, func() {
		getObjectAuditPath := "/catalogs/testString/objects/testString/audits/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getObjectAuditPath))
					Expect(req.Method).To(Equal("GET"))

					// TODO: Add check for lookupnames query parameter
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message", "gid": "Gid", "who_id": "WhoID", "who_name": "WhoName", "who_delegate_id": "WhoDelegateID", "who_delegate_name": "WhoDelegateName", "data": "anyValue"}`)
				}))
			})
			It(`Invoke GetObjectAudit successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetObjectAuditOptions model
				getObjectAuditOptionsModel := new(catalogmanagementv1.GetObjectAuditOptions)
				getObjectAuditOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectAuditOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getObjectAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getObjectAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetObjectAuditWithContext(ctx, getObjectAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetObjectAudit(getObjectAuditOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetObjectAuditWithContext(ctx, getObjectAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getObjectAuditPath))
					Expect(req.Method).To(Equal("GET"))

					// TODO: Add check for lookupnames query parameter
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message", "gid": "Gid", "who_id": "WhoID", "who_name": "WhoName", "who_delegate_id": "WhoDelegateID", "who_delegate_name": "WhoDelegateName", "data": "anyValue"}`)
				}))
			})
			It(`Invoke GetObjectAudit successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetObjectAudit(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetObjectAuditOptions model
				getObjectAuditOptionsModel := new(catalogmanagementv1.GetObjectAuditOptions)
				getObjectAuditOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectAuditOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getObjectAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getObjectAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetObjectAudit(getObjectAuditOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetObjectAudit with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetObjectAuditOptions model
				getObjectAuditOptionsModel := new(catalogmanagementv1.GetObjectAuditOptions)
				getObjectAuditOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectAuditOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getObjectAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getObjectAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetObjectAudit(getObjectAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetObjectAuditOptions model with no property values
				getObjectAuditOptionsModelNew := new(catalogmanagementv1.GetObjectAuditOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetObjectAudit(getObjectAuditOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetObjectAudit successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetObjectAuditOptions model
				getObjectAuditOptionsModel := new(catalogmanagementv1.GetObjectAuditOptions)
				getObjectAuditOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectAuditOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getObjectAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getObjectAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetObjectAudit(getObjectAuditOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ConsumableShareObject(consumableShareObjectOptions *ConsumableShareObjectOptions)`, func() {
		consumableShareObjectPath := "/catalogs/testString/objects/testString/consume-publish"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(consumableShareObjectPath))
					Expect(req.Method).To(Equal("POST"))

					res.WriteHeader(202)
				}))
			})
			It(`Invoke ConsumableShareObject successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.ConsumableShareObject(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the ConsumableShareObjectOptions model
				consumableShareObjectOptionsModel := new(catalogmanagementv1.ConsumableShareObjectOptions)
				consumableShareObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				consumableShareObjectOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				consumableShareObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.ConsumableShareObject(consumableShareObjectOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke ConsumableShareObject with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ConsumableShareObjectOptions model
				consumableShareObjectOptionsModel := new(catalogmanagementv1.ConsumableShareObjectOptions)
				consumableShareObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				consumableShareObjectOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				consumableShareObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.ConsumableShareObject(consumableShareObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the ConsumableShareObjectOptions model with no property values
				consumableShareObjectOptionsModelNew := new(catalogmanagementv1.ConsumableShareObjectOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.ConsumableShareObject(consumableShareObjectOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ShareObject(shareObjectOptions *ShareObjectOptions) - Operation response error`, func() {
		shareObjectPath := "/catalogs/testString/objects/testString/share"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(shareObjectPath))
					Expect(req.Method).To(Equal("POST"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ShareObject with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ShareObjectOptions model
				shareObjectOptionsModel := new(catalogmanagementv1.ShareObjectOptions)
				shareObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				shareObjectOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				shareObjectOptionsModel.IBM = core.BoolPtr(true)
				shareObjectOptionsModel.Public = core.BoolPtr(true)
				shareObjectOptionsModel.Enabled = core.BoolPtr(true)
				shareObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.ShareObject(shareObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.ShareObject(shareObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ShareObject(shareObjectOptions *ShareObjectOptions)`, func() {
		shareObjectPath := "/catalogs/testString/objects/testString/share"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(shareObjectPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"ibm": false, "public": true, "enabled": false}`)
				}))
			})
			It(`Invoke ShareObject successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the ShareObjectOptions model
				shareObjectOptionsModel := new(catalogmanagementv1.ShareObjectOptions)
				shareObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				shareObjectOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				shareObjectOptionsModel.IBM = core.BoolPtr(true)
				shareObjectOptionsModel.Public = core.BoolPtr(true)
				shareObjectOptionsModel.Enabled = core.BoolPtr(true)
				shareObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.ShareObjectWithContext(ctx, shareObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.ShareObject(shareObjectOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.ShareObjectWithContext(ctx, shareObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(shareObjectPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"ibm": false, "public": true, "enabled": false}`)
				}))
			})
			It(`Invoke ShareObject successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.ShareObject(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ShareObjectOptions model
				shareObjectOptionsModel := new(catalogmanagementv1.ShareObjectOptions)
				shareObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				shareObjectOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				shareObjectOptionsModel.IBM = core.BoolPtr(true)
				shareObjectOptionsModel.Public = core.BoolPtr(true)
				shareObjectOptionsModel.Enabled = core.BoolPtr(true)
				shareObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.ShareObject(shareObjectOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ShareObject with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ShareObjectOptions model
				shareObjectOptionsModel := new(catalogmanagementv1.ShareObjectOptions)
				shareObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				shareObjectOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				shareObjectOptionsModel.IBM = core.BoolPtr(true)
				shareObjectOptionsModel.Public = core.BoolPtr(true)
				shareObjectOptionsModel.Enabled = core.BoolPtr(true)
				shareObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.ShareObject(shareObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ShareObjectOptions model with no property values
				shareObjectOptionsModelNew := new(catalogmanagementv1.ShareObjectOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.ShareObject(shareObjectOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ShareObject successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ShareObjectOptions model
				shareObjectOptionsModel := new(catalogmanagementv1.ShareObjectOptions)
				shareObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				shareObjectOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				shareObjectOptionsModel.IBM = core.BoolPtr(true)
				shareObjectOptionsModel.Public = core.BoolPtr(true)
				shareObjectOptionsModel.Enabled = core.BoolPtr(true)
				shareObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.ShareObject(shareObjectOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetObjectAccessList(getObjectAccessListOptions *GetObjectAccessListOptions) - Operation response error`, func() {
		getObjectAccessListPath := "/catalogs/testString/objects/testString/accessv1"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getObjectAccessListPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetObjectAccessList with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetObjectAccessListOptions model
				getObjectAccessListOptionsModel := new(catalogmanagementv1.GetObjectAccessListOptions)
				getObjectAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectAccessListOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectAccessListOptionsModel.Start = core.StringPtr("testString")
				getObjectAccessListOptionsModel.Limit = core.Int64Ptr(int64(10))
				getObjectAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetObjectAccessList(getObjectAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetObjectAccessList(getObjectAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetObjectAccessList(getObjectAccessListOptions *GetObjectAccessListOptions)`, func() {
		getObjectAccessListPath := "/catalogs/testString/objects/testString/accessv1"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getObjectAccessListPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"start": "Start", "limit": 5, "total_count": 10, "resource_count": 13, "first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}, "prev": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}, "resources": [{"id": "ID", "account": "Account", "account_type": 11, "catalog_id": "CatalogID", "target_id": "TargetID", "target_account": "TargetAccount", "target_kind": "TargetKind", "private_accessible": false, "created": "2019-01-01T12:00:00.000Z"}]}`)
				}))
			})
			It(`Invoke GetObjectAccessList successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetObjectAccessListOptions model
				getObjectAccessListOptionsModel := new(catalogmanagementv1.GetObjectAccessListOptions)
				getObjectAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectAccessListOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectAccessListOptionsModel.Start = core.StringPtr("testString")
				getObjectAccessListOptionsModel.Limit = core.Int64Ptr(int64(10))
				getObjectAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetObjectAccessListWithContext(ctx, getObjectAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetObjectAccessList(getObjectAccessListOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetObjectAccessListWithContext(ctx, getObjectAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getObjectAccessListPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"start": "Start", "limit": 5, "total_count": 10, "resource_count": 13, "first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}, "prev": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}, "resources": [{"id": "ID", "account": "Account", "account_type": 11, "catalog_id": "CatalogID", "target_id": "TargetID", "target_account": "TargetAccount", "target_kind": "TargetKind", "private_accessible": false, "created": "2019-01-01T12:00:00.000Z"}]}`)
				}))
			})
			It(`Invoke GetObjectAccessList successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetObjectAccessList(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetObjectAccessListOptions model
				getObjectAccessListOptionsModel := new(catalogmanagementv1.GetObjectAccessListOptions)
				getObjectAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectAccessListOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectAccessListOptionsModel.Start = core.StringPtr("testString")
				getObjectAccessListOptionsModel.Limit = core.Int64Ptr(int64(10))
				getObjectAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetObjectAccessList(getObjectAccessListOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetObjectAccessList with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetObjectAccessListOptions model
				getObjectAccessListOptionsModel := new(catalogmanagementv1.GetObjectAccessListOptions)
				getObjectAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectAccessListOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectAccessListOptionsModel.Start = core.StringPtr("testString")
				getObjectAccessListOptionsModel.Limit = core.Int64Ptr(int64(10))
				getObjectAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetObjectAccessList(getObjectAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetObjectAccessListOptions model with no property values
				getObjectAccessListOptionsModelNew := new(catalogmanagementv1.GetObjectAccessListOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetObjectAccessList(getObjectAccessListOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetObjectAccessList successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetObjectAccessListOptions model
				getObjectAccessListOptionsModel := new(catalogmanagementv1.GetObjectAccessListOptions)
				getObjectAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectAccessListOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectAccessListOptionsModel.Start = core.StringPtr("testString")
				getObjectAccessListOptionsModel.Limit = core.Int64Ptr(int64(10))
				getObjectAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetObjectAccessList(getObjectAccessListOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Test pagination helper method on response`, func() {
			It(`Invoke GetNextStart successfully`, func() {
				responseObject := new(catalogmanagementv1.AccessListResult)
				nextObject := new(catalogmanagementv1.PaginationTokenLink)
				nextObject.Start = core.StringPtr("abc-123")
				responseObject.Next = nextObject
	
				value, err := responseObject.GetNextStart()
				Expect(err).To(BeNil())
				Expect(value).To(Equal(core.StringPtr("abc-123")))
			})
			It(`Invoke GetNextStart without a "Next" property in the response`, func() {
				responseObject := new(catalogmanagementv1.AccessListResult)
	
				value, err := responseObject.GetNextStart()
				Expect(err).To(BeNil())
				Expect(value).To(BeNil())
			})
		})
		Context(`Using mock server endpoint - paginated response`, func() {
			BeforeEach(func() {
				var requestNumber int = 0
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getObjectAccessListPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					requestNumber++
					if requestNumber == 1 {
						fmt.Fprintf(res, "%s", `{"next":{"start":"1"},"total_count":2,"limit":1,"resources":[{"id":"ID","account":"Account","account_type":11,"catalog_id":"CatalogID","target_id":"TargetID","target_account":"TargetAccount","target_kind":"TargetKind","private_accessible":false,"created":"2019-01-01T12:00:00.000Z"}]}`)
					} else if requestNumber == 2 {
						fmt.Fprintf(res, "%s", `{"total_count":2,"limit":1,"resources":[{"id":"ID","account":"Account","account_type":11,"catalog_id":"CatalogID","target_id":"TargetID","target_account":"TargetAccount","target_kind":"TargetKind","private_accessible":false,"created":"2019-01-01T12:00:00.000Z"}]}`)
					} else {
						res.WriteHeader(400)
					}
				}))
			})
			It(`Use GetObjectAccessListPager.GetNext successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				getObjectAccessListOptionsModel := &catalogmanagementv1.GetObjectAccessListOptions{
					CatalogIdentifier: core.StringPtr("testString"),
					ObjectIdentifier: core.StringPtr("testString"),
					Limit: core.Int64Ptr(int64(10)),
				}

				pager, err := catalogManagementService.NewGetObjectAccessListPager(getObjectAccessListOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				var allResults []catalogmanagementv1.Access
				for pager.HasNext() {
					nextPage, err := pager.GetNext()
					Expect(err).To(BeNil())
					Expect(nextPage).ToNot(BeNil())
					allResults = append(allResults, nextPage...)
				}
				Expect(len(allResults)).To(Equal(2))
			})
			It(`Use GetObjectAccessListPager.GetAll successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				getObjectAccessListOptionsModel := &catalogmanagementv1.GetObjectAccessListOptions{
					CatalogIdentifier: core.StringPtr("testString"),
					ObjectIdentifier: core.StringPtr("testString"),
					Limit: core.Int64Ptr(int64(10)),
				}

				pager, err := catalogManagementService.NewGetObjectAccessListPager(getObjectAccessListOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				allResults, err := pager.GetAll()
				Expect(err).To(BeNil())
				Expect(allResults).ToNot(BeNil())
				Expect(len(allResults)).To(Equal(2))
			})
		})
	})
	Describe(`GetObjectAccess(getObjectAccessOptions *GetObjectAccessOptions) - Operation response error`, func() {
		getObjectAccessPath := "/catalogs/testString/objects/testString/access/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getObjectAccessPath))
					Expect(req.Method).To(Equal("GET"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetObjectAccess with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetObjectAccessOptions model
				getObjectAccessOptionsModel := new(catalogmanagementv1.GetObjectAccessOptions)
				getObjectAccessOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectAccessOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectAccessOptionsModel.AccessIdentifier = core.StringPtr("testString")
				getObjectAccessOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetObjectAccess(getObjectAccessOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetObjectAccess(getObjectAccessOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetObjectAccess(getObjectAccessOptions *GetObjectAccessOptions)`, func() {
		getObjectAccessPath := "/catalogs/testString/objects/testString/access/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getObjectAccessPath))
					Expect(req.Method).To(Equal("GET"))

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "account": "Account", "account_type": 11, "catalog_id": "CatalogID", "target_id": "TargetID", "target_account": "TargetAccount", "target_kind": "TargetKind", "private_accessible": false, "created": "2019-01-01T12:00:00.000Z"}`)
				}))
			})
			It(`Invoke GetObjectAccess successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetObjectAccessOptions model
				getObjectAccessOptionsModel := new(catalogmanagementv1.GetObjectAccessOptions)
				getObjectAccessOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectAccessOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectAccessOptionsModel.AccessIdentifier = core.StringPtr("testString")
				getObjectAccessOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetObjectAccessWithContext(ctx, getObjectAccessOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetObjectAccess(getObjectAccessOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetObjectAccessWithContext(ctx, getObjectAccessOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getObjectAccessPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "account": "Account", "account_type": 11, "catalog_id": "CatalogID", "target_id": "TargetID", "target_account": "TargetAccount", "target_kind": "TargetKind", "private_accessible": false, "created": "2019-01-01T12:00:00.000Z"}`)
				}))
			})
			It(`Invoke GetObjectAccess successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetObjectAccess(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetObjectAccessOptions model
				getObjectAccessOptionsModel := new(catalogmanagementv1.GetObjectAccessOptions)
				getObjectAccessOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectAccessOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectAccessOptionsModel.AccessIdentifier = core.StringPtr("testString")
				getObjectAccessOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetObjectAccess(getObjectAccessOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetObjectAccess with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetObjectAccessOptions model
				getObjectAccessOptionsModel := new(catalogmanagementv1.GetObjectAccessOptions)
				getObjectAccessOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectAccessOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectAccessOptionsModel.AccessIdentifier = core.StringPtr("testString")
				getObjectAccessOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetObjectAccess(getObjectAccessOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetObjectAccessOptions model with no property values
				getObjectAccessOptionsModelNew := new(catalogmanagementv1.GetObjectAccessOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetObjectAccess(getObjectAccessOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetObjectAccess successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetObjectAccessOptions model
				getObjectAccessOptionsModel := new(catalogmanagementv1.GetObjectAccessOptions)
				getObjectAccessOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectAccessOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectAccessOptionsModel.AccessIdentifier = core.StringPtr("testString")
				getObjectAccessOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetObjectAccess(getObjectAccessOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateObjectAccess(createObjectAccessOptions *CreateObjectAccessOptions)`, func() {
		createObjectAccessPath := "/catalogs/testString/objects/testString/access/testString"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createObjectAccessPath))
					Expect(req.Method).To(Equal("POST"))

					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreateObjectAccess successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.CreateObjectAccess(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the CreateObjectAccessOptions model
				createObjectAccessOptionsModel := new(catalogmanagementv1.CreateObjectAccessOptions)
				createObjectAccessOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				createObjectAccessOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				createObjectAccessOptionsModel.AccessIdentifier = core.StringPtr("testString")
				createObjectAccessOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.CreateObjectAccess(createObjectAccessOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke CreateObjectAccess with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the CreateObjectAccessOptions model
				createObjectAccessOptionsModel := new(catalogmanagementv1.CreateObjectAccessOptions)
				createObjectAccessOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				createObjectAccessOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				createObjectAccessOptionsModel.AccessIdentifier = core.StringPtr("testString")
				createObjectAccessOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.CreateObjectAccess(createObjectAccessOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the CreateObjectAccessOptions model with no property values
				createObjectAccessOptionsModelNew := new(catalogmanagementv1.CreateObjectAccessOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.CreateObjectAccess(createObjectAccessOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteObjectAccess(deleteObjectAccessOptions *DeleteObjectAccessOptions)`, func() {
		deleteObjectAccessPath := "/catalogs/testString/objects/testString/access/testString"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteObjectAccessPath))
					Expect(req.Method).To(Equal("DELETE"))

					res.WriteHeader(200)
				}))
			})
			It(`Invoke DeleteObjectAccess successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.DeleteObjectAccess(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteObjectAccessOptions model
				deleteObjectAccessOptionsModel := new(catalogmanagementv1.DeleteObjectAccessOptions)
				deleteObjectAccessOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				deleteObjectAccessOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				deleteObjectAccessOptionsModel.AccessIdentifier = core.StringPtr("testString")
				deleteObjectAccessOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.DeleteObjectAccess(deleteObjectAccessOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteObjectAccess with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the DeleteObjectAccessOptions model
				deleteObjectAccessOptionsModel := new(catalogmanagementv1.DeleteObjectAccessOptions)
				deleteObjectAccessOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				deleteObjectAccessOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				deleteObjectAccessOptionsModel.AccessIdentifier = core.StringPtr("testString")
				deleteObjectAccessOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.DeleteObjectAccess(deleteObjectAccessOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeleteObjectAccessOptions model with no property values
				deleteObjectAccessOptionsModelNew := new(catalogmanagementv1.DeleteObjectAccessOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.DeleteObjectAccess(deleteObjectAccessOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetObjectAccessListDeprecated(getObjectAccessListDeprecatedOptions *GetObjectAccessListDeprecatedOptions) - Operation response error`, func() {
		getObjectAccessListDeprecatedPath := "/catalogs/testString/objects/testString/access"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getObjectAccessListDeprecatedPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(1000))}))
					Expect(req.URL.Query()["offset"]).To(Equal([]string{fmt.Sprint(int64(38))}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetObjectAccessListDeprecated with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetObjectAccessListDeprecatedOptions model
				getObjectAccessListDeprecatedOptionsModel := new(catalogmanagementv1.GetObjectAccessListDeprecatedOptions)
				getObjectAccessListDeprecatedOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectAccessListDeprecatedOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectAccessListDeprecatedOptionsModel.Limit = core.Int64Ptr(int64(1000))
				getObjectAccessListDeprecatedOptionsModel.Offset = core.Int64Ptr(int64(38))
				getObjectAccessListDeprecatedOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetObjectAccessListDeprecated(getObjectAccessListDeprecatedOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetObjectAccessListDeprecated(getObjectAccessListDeprecatedOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetObjectAccessListDeprecated(getObjectAccessListDeprecatedOptions *GetObjectAccessListDeprecatedOptions)`, func() {
		getObjectAccessListDeprecatedPath := "/catalogs/testString/objects/testString/access"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getObjectAccessListDeprecatedPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(1000))}))
					Expect(req.URL.Query()["offset"]).To(Equal([]string{fmt.Sprint(int64(38))}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"offset": 6, "limit": 5, "total_count": 10, "resource_count": 13, "first": "First", "last": "Last", "prev": "Prev", "next": "Next", "resources": [{"id": "ID", "account": "Account", "account_type": 11, "catalog_id": "CatalogID", "target_id": "TargetID", "target_account": "TargetAccount", "target_kind": "TargetKind", "private_accessible": false, "created": "2019-01-01T12:00:00.000Z"}]}`)
				}))
			})
			It(`Invoke GetObjectAccessListDeprecated successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetObjectAccessListDeprecatedOptions model
				getObjectAccessListDeprecatedOptionsModel := new(catalogmanagementv1.GetObjectAccessListDeprecatedOptions)
				getObjectAccessListDeprecatedOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectAccessListDeprecatedOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectAccessListDeprecatedOptionsModel.Limit = core.Int64Ptr(int64(1000))
				getObjectAccessListDeprecatedOptionsModel.Offset = core.Int64Ptr(int64(38))
				getObjectAccessListDeprecatedOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetObjectAccessListDeprecatedWithContext(ctx, getObjectAccessListDeprecatedOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetObjectAccessListDeprecated(getObjectAccessListDeprecatedOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetObjectAccessListDeprecatedWithContext(ctx, getObjectAccessListDeprecatedOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getObjectAccessListDeprecatedPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(1000))}))
					Expect(req.URL.Query()["offset"]).To(Equal([]string{fmt.Sprint(int64(38))}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"offset": 6, "limit": 5, "total_count": 10, "resource_count": 13, "first": "First", "last": "Last", "prev": "Prev", "next": "Next", "resources": [{"id": "ID", "account": "Account", "account_type": 11, "catalog_id": "CatalogID", "target_id": "TargetID", "target_account": "TargetAccount", "target_kind": "TargetKind", "private_accessible": false, "created": "2019-01-01T12:00:00.000Z"}]}`)
				}))
			})
			It(`Invoke GetObjectAccessListDeprecated successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetObjectAccessListDeprecated(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetObjectAccessListDeprecatedOptions model
				getObjectAccessListDeprecatedOptionsModel := new(catalogmanagementv1.GetObjectAccessListDeprecatedOptions)
				getObjectAccessListDeprecatedOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectAccessListDeprecatedOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectAccessListDeprecatedOptionsModel.Limit = core.Int64Ptr(int64(1000))
				getObjectAccessListDeprecatedOptionsModel.Offset = core.Int64Ptr(int64(38))
				getObjectAccessListDeprecatedOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetObjectAccessListDeprecated(getObjectAccessListDeprecatedOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetObjectAccessListDeprecated with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetObjectAccessListDeprecatedOptions model
				getObjectAccessListDeprecatedOptionsModel := new(catalogmanagementv1.GetObjectAccessListDeprecatedOptions)
				getObjectAccessListDeprecatedOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectAccessListDeprecatedOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectAccessListDeprecatedOptionsModel.Limit = core.Int64Ptr(int64(1000))
				getObjectAccessListDeprecatedOptionsModel.Offset = core.Int64Ptr(int64(38))
				getObjectAccessListDeprecatedOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetObjectAccessListDeprecated(getObjectAccessListDeprecatedOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetObjectAccessListDeprecatedOptions model with no property values
				getObjectAccessListDeprecatedOptionsModelNew := new(catalogmanagementv1.GetObjectAccessListDeprecatedOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetObjectAccessListDeprecated(getObjectAccessListDeprecatedOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetObjectAccessListDeprecated successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetObjectAccessListDeprecatedOptions model
				getObjectAccessListDeprecatedOptionsModel := new(catalogmanagementv1.GetObjectAccessListDeprecatedOptions)
				getObjectAccessListDeprecatedOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectAccessListDeprecatedOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectAccessListDeprecatedOptionsModel.Limit = core.Int64Ptr(int64(1000))
				getObjectAccessListDeprecatedOptionsModel.Offset = core.Int64Ptr(int64(38))
				getObjectAccessListDeprecatedOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetObjectAccessListDeprecated(getObjectAccessListDeprecatedOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteObjectAccessList(deleteObjectAccessListOptions *DeleteObjectAccessListOptions) - Operation response error`, func() {
		deleteObjectAccessListPath := "/catalogs/testString/objects/testString/access"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteObjectAccessListPath))
					Expect(req.Method).To(Equal("DELETE"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke DeleteObjectAccessList with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the DeleteObjectAccessListOptions model
				deleteObjectAccessListOptionsModel := new(catalogmanagementv1.DeleteObjectAccessListOptions)
				deleteObjectAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				deleteObjectAccessListOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				deleteObjectAccessListOptionsModel.Accesses = []string{"testString"}
				deleteObjectAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.DeleteObjectAccessList(deleteObjectAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.DeleteObjectAccessList(deleteObjectAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteObjectAccessList(deleteObjectAccessListOptions *DeleteObjectAccessListOptions)`, func() {
		deleteObjectAccessListPath := "/catalogs/testString/objects/testString/access"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteObjectAccessListPath))
					Expect(req.Method).To(Equal("DELETE"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"errors": {"mapKey": "Inner"}}`)
				}))
			})
			It(`Invoke DeleteObjectAccessList successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the DeleteObjectAccessListOptions model
				deleteObjectAccessListOptionsModel := new(catalogmanagementv1.DeleteObjectAccessListOptions)
				deleteObjectAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				deleteObjectAccessListOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				deleteObjectAccessListOptionsModel.Accesses = []string{"testString"}
				deleteObjectAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.DeleteObjectAccessListWithContext(ctx, deleteObjectAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.DeleteObjectAccessList(deleteObjectAccessListOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.DeleteObjectAccessListWithContext(ctx, deleteObjectAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteObjectAccessListPath))
					Expect(req.Method).To(Equal("DELETE"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"errors": {"mapKey": "Inner"}}`)
				}))
			})
			It(`Invoke DeleteObjectAccessList successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.DeleteObjectAccessList(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the DeleteObjectAccessListOptions model
				deleteObjectAccessListOptionsModel := new(catalogmanagementv1.DeleteObjectAccessListOptions)
				deleteObjectAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				deleteObjectAccessListOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				deleteObjectAccessListOptionsModel.Accesses = []string{"testString"}
				deleteObjectAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.DeleteObjectAccessList(deleteObjectAccessListOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke DeleteObjectAccessList with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the DeleteObjectAccessListOptions model
				deleteObjectAccessListOptionsModel := new(catalogmanagementv1.DeleteObjectAccessListOptions)
				deleteObjectAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				deleteObjectAccessListOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				deleteObjectAccessListOptionsModel.Accesses = []string{"testString"}
				deleteObjectAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.DeleteObjectAccessList(deleteObjectAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the DeleteObjectAccessListOptions model with no property values
				deleteObjectAccessListOptionsModelNew := new(catalogmanagementv1.DeleteObjectAccessListOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.DeleteObjectAccessList(deleteObjectAccessListOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke DeleteObjectAccessList successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the DeleteObjectAccessListOptions model
				deleteObjectAccessListOptionsModel := new(catalogmanagementv1.DeleteObjectAccessListOptions)
				deleteObjectAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				deleteObjectAccessListOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				deleteObjectAccessListOptionsModel.Accesses = []string{"testString"}
				deleteObjectAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.DeleteObjectAccessList(deleteObjectAccessListOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`AddObjectAccessList(addObjectAccessListOptions *AddObjectAccessListOptions) - Operation response error`, func() {
		addObjectAccessListPath := "/catalogs/testString/objects/testString/access"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(addObjectAccessListPath))
					Expect(req.Method).To(Equal("POST"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke AddObjectAccessList with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the AddObjectAccessListOptions model
				addObjectAccessListOptionsModel := new(catalogmanagementv1.AddObjectAccessListOptions)
				addObjectAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				addObjectAccessListOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				addObjectAccessListOptionsModel.Accesses = []string{"testString"}
				addObjectAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.AddObjectAccessList(addObjectAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.AddObjectAccessList(addObjectAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`AddObjectAccessList(addObjectAccessListOptions *AddObjectAccessListOptions)`, func() {
		addObjectAccessListPath := "/catalogs/testString/objects/testString/access"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(addObjectAccessListPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"errors": {"mapKey": "Inner"}}`)
				}))
			})
			It(`Invoke AddObjectAccessList successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the AddObjectAccessListOptions model
				addObjectAccessListOptionsModel := new(catalogmanagementv1.AddObjectAccessListOptions)
				addObjectAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				addObjectAccessListOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				addObjectAccessListOptionsModel.Accesses = []string{"testString"}
				addObjectAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.AddObjectAccessListWithContext(ctx, addObjectAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.AddObjectAccessList(addObjectAccessListOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.AddObjectAccessListWithContext(ctx, addObjectAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(addObjectAccessListPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"errors": {"mapKey": "Inner"}}`)
				}))
			})
			It(`Invoke AddObjectAccessList successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.AddObjectAccessList(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the AddObjectAccessListOptions model
				addObjectAccessListOptionsModel := new(catalogmanagementv1.AddObjectAccessListOptions)
				addObjectAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				addObjectAccessListOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				addObjectAccessListOptionsModel.Accesses = []string{"testString"}
				addObjectAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.AddObjectAccessList(addObjectAccessListOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke AddObjectAccessList with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the AddObjectAccessListOptions model
				addObjectAccessListOptionsModel := new(catalogmanagementv1.AddObjectAccessListOptions)
				addObjectAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				addObjectAccessListOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				addObjectAccessListOptionsModel.Accesses = []string{"testString"}
				addObjectAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.AddObjectAccessList(addObjectAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the AddObjectAccessListOptions model with no property values
				addObjectAccessListOptionsModelNew := new(catalogmanagementv1.AddObjectAccessListOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.AddObjectAccessList(addObjectAccessListOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke AddObjectAccessList successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the AddObjectAccessListOptions model
				addObjectAccessListOptionsModel := new(catalogmanagementv1.AddObjectAccessListOptions)
				addObjectAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				addObjectAccessListOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				addObjectAccessListOptionsModel.Accesses = []string{"testString"}
				addObjectAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.AddObjectAccessList(addObjectAccessListOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`AccountPublishObject(accountPublishObjectOptions *AccountPublishObjectOptions)`, func() {
		accountPublishObjectPath := "/catalogs/testString/objects/testString/account-publish"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(accountPublishObjectPath))
					Expect(req.Method).To(Equal("POST"))

					res.WriteHeader(202)
				}))
			})
			It(`Invoke AccountPublishObject successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.AccountPublishObject(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the AccountPublishObjectOptions model
				accountPublishObjectOptionsModel := new(catalogmanagementv1.AccountPublishObjectOptions)
				accountPublishObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				accountPublishObjectOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				accountPublishObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.AccountPublishObject(accountPublishObjectOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke AccountPublishObject with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the AccountPublishObjectOptions model
				accountPublishObjectOptionsModel := new(catalogmanagementv1.AccountPublishObjectOptions)
				accountPublishObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				accountPublishObjectOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				accountPublishObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.AccountPublishObject(accountPublishObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the AccountPublishObjectOptions model with no property values
				accountPublishObjectOptionsModelNew := new(catalogmanagementv1.AccountPublishObjectOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.AccountPublishObject(accountPublishObjectOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`SharedPublishObject(sharedPublishObjectOptions *SharedPublishObjectOptions)`, func() {
		sharedPublishObjectPath := "/catalogs/testString/objects/testString/shared-publish"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(sharedPublishObjectPath))
					Expect(req.Method).To(Equal("POST"))

					res.WriteHeader(202)
				}))
			})
			It(`Invoke SharedPublishObject successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.SharedPublishObject(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the SharedPublishObjectOptions model
				sharedPublishObjectOptionsModel := new(catalogmanagementv1.SharedPublishObjectOptions)
				sharedPublishObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				sharedPublishObjectOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				sharedPublishObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.SharedPublishObject(sharedPublishObjectOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke SharedPublishObject with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the SharedPublishObjectOptions model
				sharedPublishObjectOptionsModel := new(catalogmanagementv1.SharedPublishObjectOptions)
				sharedPublishObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				sharedPublishObjectOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				sharedPublishObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.SharedPublishObject(sharedPublishObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the SharedPublishObjectOptions model with no property values
				sharedPublishObjectOptionsModelNew := new(catalogmanagementv1.SharedPublishObjectOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.SharedPublishObject(sharedPublishObjectOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`IBMPublishObject(ibmPublishObjectOptions *IBMPublishObjectOptions)`, func() {
		ibmPublishObjectPath := "/catalogs/testString/objects/testString/ibm-publish"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(ibmPublishObjectPath))
					Expect(req.Method).To(Equal("POST"))

					res.WriteHeader(202)
				}))
			})
			It(`Invoke IBMPublishObject successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.IBMPublishObject(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the IBMPublishObjectOptions model
				ibmPublishObjectOptionsModel := new(catalogmanagementv1.IBMPublishObjectOptions)
				ibmPublishObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				ibmPublishObjectOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				ibmPublishObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.IBMPublishObject(ibmPublishObjectOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke IBMPublishObject with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the IBMPublishObjectOptions model
				ibmPublishObjectOptionsModel := new(catalogmanagementv1.IBMPublishObjectOptions)
				ibmPublishObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				ibmPublishObjectOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				ibmPublishObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.IBMPublishObject(ibmPublishObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the IBMPublishObjectOptions model with no property values
				ibmPublishObjectOptionsModelNew := new(catalogmanagementv1.IBMPublishObjectOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.IBMPublishObject(ibmPublishObjectOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`PublicPublishObject(publicPublishObjectOptions *PublicPublishObjectOptions)`, func() {
		publicPublishObjectPath := "/catalogs/testString/objects/testString/public-publish"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(publicPublishObjectPath))
					Expect(req.Method).To(Equal("POST"))

					res.WriteHeader(202)
				}))
			})
			It(`Invoke PublicPublishObject successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.PublicPublishObject(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the PublicPublishObjectOptions model
				publicPublishObjectOptionsModel := new(catalogmanagementv1.PublicPublishObjectOptions)
				publicPublishObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				publicPublishObjectOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				publicPublishObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.PublicPublishObject(publicPublishObjectOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke PublicPublishObject with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the PublicPublishObjectOptions model
				publicPublishObjectOptionsModel := new(catalogmanagementv1.PublicPublishObjectOptions)
				publicPublishObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				publicPublishObjectOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				publicPublishObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.PublicPublishObject(publicPublishObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the PublicPublishObjectOptions model with no property values
				publicPublishObjectOptionsModelNew := new(catalogmanagementv1.PublicPublishObjectOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.PublicPublishObject(publicPublishObjectOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateOfferingInstance(createOfferingInstanceOptions *CreateOfferingInstanceOptions) - Operation response error`, func() {
		createOfferingInstancePath := "/instances/offerings"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createOfferingInstancePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateOfferingInstance with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the OfferingInstanceLastOperation model
				offeringInstanceLastOperationModel := new(catalogmanagementv1.OfferingInstanceLastOperation)
				offeringInstanceLastOperationModel.Operation = core.StringPtr("testString")
				offeringInstanceLastOperationModel.State = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Message = core.StringPtr("testString")
				offeringInstanceLastOperationModel.TransactionID = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				offeringInstanceLastOperationModel.Code = core.StringPtr("testString")

				// Construct an instance of the CreateOfferingInstanceOptions model
				createOfferingInstanceOptionsModel := new(catalogmanagementv1.CreateOfferingInstanceOptions)
				createOfferingInstanceOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.ID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Rev = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.URL = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.CRN = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Label = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.CatalogID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.OfferingID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.KindFormat = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Version = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.VersionID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.ClusterID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.ClusterRegion = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.ClusterNamespaces = []string{"testString"}
				createOfferingInstanceOptionsModel.ClusterAllNamespaces = core.BoolPtr(true)
				createOfferingInstanceOptionsModel.SchematicsWorkspaceID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.InstallPlan = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Channel = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createOfferingInstanceOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createOfferingInstanceOptionsModel.Metadata = make(map[string]interface{})
				createOfferingInstanceOptionsModel.ResourceGroupID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Location = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Disabled = core.BoolPtr(true)
				createOfferingInstanceOptionsModel.Account = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.LastOperation = offeringInstanceLastOperationModel
				createOfferingInstanceOptionsModel.KindTarget = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Sha = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.CreateOfferingInstance(createOfferingInstanceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.CreateOfferingInstance(createOfferingInstanceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateOfferingInstance(createOfferingInstanceOptions *CreateOfferingInstanceOptions)`, func() {
		createOfferingInstancePath := "/instances/offerings"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createOfferingInstancePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "catalog_id": "CatalogID", "offering_id": "OfferingID", "kind_format": "KindFormat", "version": "Version", "version_id": "VersionID", "cluster_id": "ClusterID", "cluster_region": "ClusterRegion", "cluster_namespaces": ["ClusterNamespaces"], "cluster_all_namespaces": true, "schematics_workspace_id": "SchematicsWorkspaceID", "install_plan": "InstallPlan", "channel": "Channel", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "metadata": {"mapKey": "anyValue"}, "resource_group_id": "ResourceGroupID", "location": "Location", "disabled": true, "account": "Account", "last_operation": {"operation": "Operation", "state": "State", "message": "Message", "transaction_id": "TransactionID", "updated": "2019-01-01T12:00:00.000Z", "code": "Code"}, "kind_target": "KindTarget", "sha": "Sha"}`)
				}))
			})
			It(`Invoke CreateOfferingInstance successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the OfferingInstanceLastOperation model
				offeringInstanceLastOperationModel := new(catalogmanagementv1.OfferingInstanceLastOperation)
				offeringInstanceLastOperationModel.Operation = core.StringPtr("testString")
				offeringInstanceLastOperationModel.State = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Message = core.StringPtr("testString")
				offeringInstanceLastOperationModel.TransactionID = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				offeringInstanceLastOperationModel.Code = core.StringPtr("testString")

				// Construct an instance of the CreateOfferingInstanceOptions model
				createOfferingInstanceOptionsModel := new(catalogmanagementv1.CreateOfferingInstanceOptions)
				createOfferingInstanceOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.ID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Rev = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.URL = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.CRN = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Label = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.CatalogID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.OfferingID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.KindFormat = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Version = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.VersionID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.ClusterID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.ClusterRegion = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.ClusterNamespaces = []string{"testString"}
				createOfferingInstanceOptionsModel.ClusterAllNamespaces = core.BoolPtr(true)
				createOfferingInstanceOptionsModel.SchematicsWorkspaceID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.InstallPlan = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Channel = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createOfferingInstanceOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createOfferingInstanceOptionsModel.Metadata = make(map[string]interface{})
				createOfferingInstanceOptionsModel.ResourceGroupID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Location = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Disabled = core.BoolPtr(true)
				createOfferingInstanceOptionsModel.Account = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.LastOperation = offeringInstanceLastOperationModel
				createOfferingInstanceOptionsModel.KindTarget = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Sha = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.CreateOfferingInstanceWithContext(ctx, createOfferingInstanceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.CreateOfferingInstance(createOfferingInstanceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.CreateOfferingInstanceWithContext(ctx, createOfferingInstanceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createOfferingInstancePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "catalog_id": "CatalogID", "offering_id": "OfferingID", "kind_format": "KindFormat", "version": "Version", "version_id": "VersionID", "cluster_id": "ClusterID", "cluster_region": "ClusterRegion", "cluster_namespaces": ["ClusterNamespaces"], "cluster_all_namespaces": true, "schematics_workspace_id": "SchematicsWorkspaceID", "install_plan": "InstallPlan", "channel": "Channel", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "metadata": {"mapKey": "anyValue"}, "resource_group_id": "ResourceGroupID", "location": "Location", "disabled": true, "account": "Account", "last_operation": {"operation": "Operation", "state": "State", "message": "Message", "transaction_id": "TransactionID", "updated": "2019-01-01T12:00:00.000Z", "code": "Code"}, "kind_target": "KindTarget", "sha": "Sha"}`)
				}))
			})
			It(`Invoke CreateOfferingInstance successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.CreateOfferingInstance(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the OfferingInstanceLastOperation model
				offeringInstanceLastOperationModel := new(catalogmanagementv1.OfferingInstanceLastOperation)
				offeringInstanceLastOperationModel.Operation = core.StringPtr("testString")
				offeringInstanceLastOperationModel.State = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Message = core.StringPtr("testString")
				offeringInstanceLastOperationModel.TransactionID = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				offeringInstanceLastOperationModel.Code = core.StringPtr("testString")

				// Construct an instance of the CreateOfferingInstanceOptions model
				createOfferingInstanceOptionsModel := new(catalogmanagementv1.CreateOfferingInstanceOptions)
				createOfferingInstanceOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.ID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Rev = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.URL = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.CRN = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Label = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.CatalogID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.OfferingID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.KindFormat = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Version = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.VersionID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.ClusterID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.ClusterRegion = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.ClusterNamespaces = []string{"testString"}
				createOfferingInstanceOptionsModel.ClusterAllNamespaces = core.BoolPtr(true)
				createOfferingInstanceOptionsModel.SchematicsWorkspaceID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.InstallPlan = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Channel = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createOfferingInstanceOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createOfferingInstanceOptionsModel.Metadata = make(map[string]interface{})
				createOfferingInstanceOptionsModel.ResourceGroupID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Location = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Disabled = core.BoolPtr(true)
				createOfferingInstanceOptionsModel.Account = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.LastOperation = offeringInstanceLastOperationModel
				createOfferingInstanceOptionsModel.KindTarget = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Sha = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.CreateOfferingInstance(createOfferingInstanceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateOfferingInstance with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the OfferingInstanceLastOperation model
				offeringInstanceLastOperationModel := new(catalogmanagementv1.OfferingInstanceLastOperation)
				offeringInstanceLastOperationModel.Operation = core.StringPtr("testString")
				offeringInstanceLastOperationModel.State = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Message = core.StringPtr("testString")
				offeringInstanceLastOperationModel.TransactionID = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				offeringInstanceLastOperationModel.Code = core.StringPtr("testString")

				// Construct an instance of the CreateOfferingInstanceOptions model
				createOfferingInstanceOptionsModel := new(catalogmanagementv1.CreateOfferingInstanceOptions)
				createOfferingInstanceOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.ID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Rev = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.URL = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.CRN = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Label = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.CatalogID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.OfferingID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.KindFormat = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Version = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.VersionID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.ClusterID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.ClusterRegion = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.ClusterNamespaces = []string{"testString"}
				createOfferingInstanceOptionsModel.ClusterAllNamespaces = core.BoolPtr(true)
				createOfferingInstanceOptionsModel.SchematicsWorkspaceID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.InstallPlan = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Channel = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createOfferingInstanceOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createOfferingInstanceOptionsModel.Metadata = make(map[string]interface{})
				createOfferingInstanceOptionsModel.ResourceGroupID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Location = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Disabled = core.BoolPtr(true)
				createOfferingInstanceOptionsModel.Account = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.LastOperation = offeringInstanceLastOperationModel
				createOfferingInstanceOptionsModel.KindTarget = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Sha = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.CreateOfferingInstance(createOfferingInstanceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreateOfferingInstanceOptions model with no property values
				createOfferingInstanceOptionsModelNew := new(catalogmanagementv1.CreateOfferingInstanceOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.CreateOfferingInstance(createOfferingInstanceOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreateOfferingInstance successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the OfferingInstanceLastOperation model
				offeringInstanceLastOperationModel := new(catalogmanagementv1.OfferingInstanceLastOperation)
				offeringInstanceLastOperationModel.Operation = core.StringPtr("testString")
				offeringInstanceLastOperationModel.State = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Message = core.StringPtr("testString")
				offeringInstanceLastOperationModel.TransactionID = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				offeringInstanceLastOperationModel.Code = core.StringPtr("testString")

				// Construct an instance of the CreateOfferingInstanceOptions model
				createOfferingInstanceOptionsModel := new(catalogmanagementv1.CreateOfferingInstanceOptions)
				createOfferingInstanceOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.ID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Rev = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.URL = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.CRN = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Label = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.CatalogID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.OfferingID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.KindFormat = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Version = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.VersionID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.ClusterID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.ClusterRegion = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.ClusterNamespaces = []string{"testString"}
				createOfferingInstanceOptionsModel.ClusterAllNamespaces = core.BoolPtr(true)
				createOfferingInstanceOptionsModel.SchematicsWorkspaceID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.InstallPlan = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Channel = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createOfferingInstanceOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createOfferingInstanceOptionsModel.Metadata = make(map[string]interface{})
				createOfferingInstanceOptionsModel.ResourceGroupID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Location = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Disabled = core.BoolPtr(true)
				createOfferingInstanceOptionsModel.Account = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.LastOperation = offeringInstanceLastOperationModel
				createOfferingInstanceOptionsModel.KindTarget = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Sha = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.CreateOfferingInstance(createOfferingInstanceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetOfferingInstance(getOfferingInstanceOptions *GetOfferingInstanceOptions) - Operation response error`, func() {
		getOfferingInstancePath := "/instances/offerings/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingInstancePath))
					Expect(req.Method).To(Equal("GET"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetOfferingInstance with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingInstanceOptions model
				getOfferingInstanceOptionsModel := new(catalogmanagementv1.GetOfferingInstanceOptions)
				getOfferingInstanceOptionsModel.InstanceIdentifier = core.StringPtr("testString")
				getOfferingInstanceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetOfferingInstance(getOfferingInstanceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetOfferingInstance(getOfferingInstanceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetOfferingInstance(getOfferingInstanceOptions *GetOfferingInstanceOptions)`, func() {
		getOfferingInstancePath := "/instances/offerings/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingInstancePath))
					Expect(req.Method).To(Equal("GET"))

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "catalog_id": "CatalogID", "offering_id": "OfferingID", "kind_format": "KindFormat", "version": "Version", "version_id": "VersionID", "cluster_id": "ClusterID", "cluster_region": "ClusterRegion", "cluster_namespaces": ["ClusterNamespaces"], "cluster_all_namespaces": true, "schematics_workspace_id": "SchematicsWorkspaceID", "install_plan": "InstallPlan", "channel": "Channel", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "metadata": {"mapKey": "anyValue"}, "resource_group_id": "ResourceGroupID", "location": "Location", "disabled": true, "account": "Account", "last_operation": {"operation": "Operation", "state": "State", "message": "Message", "transaction_id": "TransactionID", "updated": "2019-01-01T12:00:00.000Z", "code": "Code"}, "kind_target": "KindTarget", "sha": "Sha"}`)
				}))
			})
			It(`Invoke GetOfferingInstance successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetOfferingInstanceOptions model
				getOfferingInstanceOptionsModel := new(catalogmanagementv1.GetOfferingInstanceOptions)
				getOfferingInstanceOptionsModel.InstanceIdentifier = core.StringPtr("testString")
				getOfferingInstanceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetOfferingInstanceWithContext(ctx, getOfferingInstanceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetOfferingInstance(getOfferingInstanceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetOfferingInstanceWithContext(ctx, getOfferingInstanceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingInstancePath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "catalog_id": "CatalogID", "offering_id": "OfferingID", "kind_format": "KindFormat", "version": "Version", "version_id": "VersionID", "cluster_id": "ClusterID", "cluster_region": "ClusterRegion", "cluster_namespaces": ["ClusterNamespaces"], "cluster_all_namespaces": true, "schematics_workspace_id": "SchematicsWorkspaceID", "install_plan": "InstallPlan", "channel": "Channel", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "metadata": {"mapKey": "anyValue"}, "resource_group_id": "ResourceGroupID", "location": "Location", "disabled": true, "account": "Account", "last_operation": {"operation": "Operation", "state": "State", "message": "Message", "transaction_id": "TransactionID", "updated": "2019-01-01T12:00:00.000Z", "code": "Code"}, "kind_target": "KindTarget", "sha": "Sha"}`)
				}))
			})
			It(`Invoke GetOfferingInstance successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetOfferingInstance(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetOfferingInstanceOptions model
				getOfferingInstanceOptionsModel := new(catalogmanagementv1.GetOfferingInstanceOptions)
				getOfferingInstanceOptionsModel.InstanceIdentifier = core.StringPtr("testString")
				getOfferingInstanceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetOfferingInstance(getOfferingInstanceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetOfferingInstance with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingInstanceOptions model
				getOfferingInstanceOptionsModel := new(catalogmanagementv1.GetOfferingInstanceOptions)
				getOfferingInstanceOptionsModel.InstanceIdentifier = core.StringPtr("testString")
				getOfferingInstanceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetOfferingInstance(getOfferingInstanceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetOfferingInstanceOptions model with no property values
				getOfferingInstanceOptionsModelNew := new(catalogmanagementv1.GetOfferingInstanceOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetOfferingInstance(getOfferingInstanceOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetOfferingInstance successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingInstanceOptions model
				getOfferingInstanceOptionsModel := new(catalogmanagementv1.GetOfferingInstanceOptions)
				getOfferingInstanceOptionsModel.InstanceIdentifier = core.StringPtr("testString")
				getOfferingInstanceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetOfferingInstance(getOfferingInstanceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`PutOfferingInstance(putOfferingInstanceOptions *PutOfferingInstanceOptions) - Operation response error`, func() {
		putOfferingInstancePath := "/instances/offerings/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(putOfferingInstancePath))
					Expect(req.Method).To(Equal("PUT"))
					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke PutOfferingInstance with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the OfferingInstanceLastOperation model
				offeringInstanceLastOperationModel := new(catalogmanagementv1.OfferingInstanceLastOperation)
				offeringInstanceLastOperationModel.Operation = core.StringPtr("testString")
				offeringInstanceLastOperationModel.State = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Message = core.StringPtr("testString")
				offeringInstanceLastOperationModel.TransactionID = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				offeringInstanceLastOperationModel.Code = core.StringPtr("testString")

				// Construct an instance of the PutOfferingInstanceOptions model
				putOfferingInstanceOptionsModel := new(catalogmanagementv1.PutOfferingInstanceOptions)
				putOfferingInstanceOptionsModel.InstanceIdentifier = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.ID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Rev = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.URL = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.CRN = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Label = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.CatalogID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.OfferingID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.KindFormat = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Version = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.VersionID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.ClusterID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.ClusterRegion = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.ClusterNamespaces = []string{"testString"}
				putOfferingInstanceOptionsModel.ClusterAllNamespaces = core.BoolPtr(true)
				putOfferingInstanceOptionsModel.SchematicsWorkspaceID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.InstallPlan = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Channel = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				putOfferingInstanceOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				putOfferingInstanceOptionsModel.Metadata = make(map[string]interface{})
				putOfferingInstanceOptionsModel.ResourceGroupID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Location = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Disabled = core.BoolPtr(true)
				putOfferingInstanceOptionsModel.Account = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.LastOperation = offeringInstanceLastOperationModel
				putOfferingInstanceOptionsModel.KindTarget = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Sha = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.PutOfferingInstance(putOfferingInstanceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.PutOfferingInstance(putOfferingInstanceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`PutOfferingInstance(putOfferingInstanceOptions *PutOfferingInstanceOptions)`, func() {
		putOfferingInstancePath := "/instances/offerings/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(putOfferingInstancePath))
					Expect(req.Method).To(Equal("PUT"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "catalog_id": "CatalogID", "offering_id": "OfferingID", "kind_format": "KindFormat", "version": "Version", "version_id": "VersionID", "cluster_id": "ClusterID", "cluster_region": "ClusterRegion", "cluster_namespaces": ["ClusterNamespaces"], "cluster_all_namespaces": true, "schematics_workspace_id": "SchematicsWorkspaceID", "install_plan": "InstallPlan", "channel": "Channel", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "metadata": {"mapKey": "anyValue"}, "resource_group_id": "ResourceGroupID", "location": "Location", "disabled": true, "account": "Account", "last_operation": {"operation": "Operation", "state": "State", "message": "Message", "transaction_id": "TransactionID", "updated": "2019-01-01T12:00:00.000Z", "code": "Code"}, "kind_target": "KindTarget", "sha": "Sha"}`)
				}))
			})
			It(`Invoke PutOfferingInstance successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the OfferingInstanceLastOperation model
				offeringInstanceLastOperationModel := new(catalogmanagementv1.OfferingInstanceLastOperation)
				offeringInstanceLastOperationModel.Operation = core.StringPtr("testString")
				offeringInstanceLastOperationModel.State = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Message = core.StringPtr("testString")
				offeringInstanceLastOperationModel.TransactionID = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				offeringInstanceLastOperationModel.Code = core.StringPtr("testString")

				// Construct an instance of the PutOfferingInstanceOptions model
				putOfferingInstanceOptionsModel := new(catalogmanagementv1.PutOfferingInstanceOptions)
				putOfferingInstanceOptionsModel.InstanceIdentifier = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.ID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Rev = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.URL = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.CRN = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Label = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.CatalogID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.OfferingID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.KindFormat = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Version = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.VersionID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.ClusterID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.ClusterRegion = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.ClusterNamespaces = []string{"testString"}
				putOfferingInstanceOptionsModel.ClusterAllNamespaces = core.BoolPtr(true)
				putOfferingInstanceOptionsModel.SchematicsWorkspaceID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.InstallPlan = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Channel = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				putOfferingInstanceOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				putOfferingInstanceOptionsModel.Metadata = make(map[string]interface{})
				putOfferingInstanceOptionsModel.ResourceGroupID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Location = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Disabled = core.BoolPtr(true)
				putOfferingInstanceOptionsModel.Account = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.LastOperation = offeringInstanceLastOperationModel
				putOfferingInstanceOptionsModel.KindTarget = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Sha = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.PutOfferingInstanceWithContext(ctx, putOfferingInstanceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.PutOfferingInstance(putOfferingInstanceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.PutOfferingInstanceWithContext(ctx, putOfferingInstanceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(putOfferingInstancePath))
					Expect(req.Method).To(Equal("PUT"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "catalog_id": "CatalogID", "offering_id": "OfferingID", "kind_format": "KindFormat", "version": "Version", "version_id": "VersionID", "cluster_id": "ClusterID", "cluster_region": "ClusterRegion", "cluster_namespaces": ["ClusterNamespaces"], "cluster_all_namespaces": true, "schematics_workspace_id": "SchematicsWorkspaceID", "install_plan": "InstallPlan", "channel": "Channel", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "metadata": {"mapKey": "anyValue"}, "resource_group_id": "ResourceGroupID", "location": "Location", "disabled": true, "account": "Account", "last_operation": {"operation": "Operation", "state": "State", "message": "Message", "transaction_id": "TransactionID", "updated": "2019-01-01T12:00:00.000Z", "code": "Code"}, "kind_target": "KindTarget", "sha": "Sha"}`)
				}))
			})
			It(`Invoke PutOfferingInstance successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.PutOfferingInstance(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the OfferingInstanceLastOperation model
				offeringInstanceLastOperationModel := new(catalogmanagementv1.OfferingInstanceLastOperation)
				offeringInstanceLastOperationModel.Operation = core.StringPtr("testString")
				offeringInstanceLastOperationModel.State = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Message = core.StringPtr("testString")
				offeringInstanceLastOperationModel.TransactionID = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				offeringInstanceLastOperationModel.Code = core.StringPtr("testString")

				// Construct an instance of the PutOfferingInstanceOptions model
				putOfferingInstanceOptionsModel := new(catalogmanagementv1.PutOfferingInstanceOptions)
				putOfferingInstanceOptionsModel.InstanceIdentifier = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.ID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Rev = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.URL = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.CRN = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Label = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.CatalogID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.OfferingID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.KindFormat = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Version = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.VersionID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.ClusterID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.ClusterRegion = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.ClusterNamespaces = []string{"testString"}
				putOfferingInstanceOptionsModel.ClusterAllNamespaces = core.BoolPtr(true)
				putOfferingInstanceOptionsModel.SchematicsWorkspaceID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.InstallPlan = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Channel = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				putOfferingInstanceOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				putOfferingInstanceOptionsModel.Metadata = make(map[string]interface{})
				putOfferingInstanceOptionsModel.ResourceGroupID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Location = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Disabled = core.BoolPtr(true)
				putOfferingInstanceOptionsModel.Account = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.LastOperation = offeringInstanceLastOperationModel
				putOfferingInstanceOptionsModel.KindTarget = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Sha = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.PutOfferingInstance(putOfferingInstanceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke PutOfferingInstance with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the OfferingInstanceLastOperation model
				offeringInstanceLastOperationModel := new(catalogmanagementv1.OfferingInstanceLastOperation)
				offeringInstanceLastOperationModel.Operation = core.StringPtr("testString")
				offeringInstanceLastOperationModel.State = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Message = core.StringPtr("testString")
				offeringInstanceLastOperationModel.TransactionID = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				offeringInstanceLastOperationModel.Code = core.StringPtr("testString")

				// Construct an instance of the PutOfferingInstanceOptions model
				putOfferingInstanceOptionsModel := new(catalogmanagementv1.PutOfferingInstanceOptions)
				putOfferingInstanceOptionsModel.InstanceIdentifier = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.ID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Rev = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.URL = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.CRN = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Label = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.CatalogID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.OfferingID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.KindFormat = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Version = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.VersionID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.ClusterID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.ClusterRegion = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.ClusterNamespaces = []string{"testString"}
				putOfferingInstanceOptionsModel.ClusterAllNamespaces = core.BoolPtr(true)
				putOfferingInstanceOptionsModel.SchematicsWorkspaceID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.InstallPlan = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Channel = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				putOfferingInstanceOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				putOfferingInstanceOptionsModel.Metadata = make(map[string]interface{})
				putOfferingInstanceOptionsModel.ResourceGroupID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Location = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Disabled = core.BoolPtr(true)
				putOfferingInstanceOptionsModel.Account = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.LastOperation = offeringInstanceLastOperationModel
				putOfferingInstanceOptionsModel.KindTarget = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Sha = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.PutOfferingInstance(putOfferingInstanceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the PutOfferingInstanceOptions model with no property values
				putOfferingInstanceOptionsModelNew := new(catalogmanagementv1.PutOfferingInstanceOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.PutOfferingInstance(putOfferingInstanceOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke PutOfferingInstance successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the OfferingInstanceLastOperation model
				offeringInstanceLastOperationModel := new(catalogmanagementv1.OfferingInstanceLastOperation)
				offeringInstanceLastOperationModel.Operation = core.StringPtr("testString")
				offeringInstanceLastOperationModel.State = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Message = core.StringPtr("testString")
				offeringInstanceLastOperationModel.TransactionID = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				offeringInstanceLastOperationModel.Code = core.StringPtr("testString")

				// Construct an instance of the PutOfferingInstanceOptions model
				putOfferingInstanceOptionsModel := new(catalogmanagementv1.PutOfferingInstanceOptions)
				putOfferingInstanceOptionsModel.InstanceIdentifier = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.ID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Rev = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.URL = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.CRN = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Label = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.CatalogID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.OfferingID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.KindFormat = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Version = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.VersionID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.ClusterID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.ClusterRegion = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.ClusterNamespaces = []string{"testString"}
				putOfferingInstanceOptionsModel.ClusterAllNamespaces = core.BoolPtr(true)
				putOfferingInstanceOptionsModel.SchematicsWorkspaceID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.InstallPlan = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Channel = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				putOfferingInstanceOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				putOfferingInstanceOptionsModel.Metadata = make(map[string]interface{})
				putOfferingInstanceOptionsModel.ResourceGroupID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Location = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Disabled = core.BoolPtr(true)
				putOfferingInstanceOptionsModel.Account = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.LastOperation = offeringInstanceLastOperationModel
				putOfferingInstanceOptionsModel.KindTarget = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Sha = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.PutOfferingInstance(putOfferingInstanceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteOfferingInstance(deleteOfferingInstanceOptions *DeleteOfferingInstanceOptions)`, func() {
		deleteOfferingInstancePath := "/instances/offerings/testString"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteOfferingInstancePath))
					Expect(req.Method).To(Equal("DELETE"))

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.WriteHeader(200)
				}))
			})
			It(`Invoke DeleteOfferingInstance successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.DeleteOfferingInstance(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteOfferingInstanceOptions model
				deleteOfferingInstanceOptionsModel := new(catalogmanagementv1.DeleteOfferingInstanceOptions)
				deleteOfferingInstanceOptionsModel.InstanceIdentifier = core.StringPtr("testString")
				deleteOfferingInstanceOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				deleteOfferingInstanceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.DeleteOfferingInstance(deleteOfferingInstanceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteOfferingInstance with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the DeleteOfferingInstanceOptions model
				deleteOfferingInstanceOptionsModel := new(catalogmanagementv1.DeleteOfferingInstanceOptions)
				deleteOfferingInstanceOptionsModel.InstanceIdentifier = core.StringPtr("testString")
				deleteOfferingInstanceOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				deleteOfferingInstanceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.DeleteOfferingInstance(deleteOfferingInstanceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeleteOfferingInstanceOptions model with no property values
				deleteOfferingInstanceOptionsModelNew := new(catalogmanagementv1.DeleteOfferingInstanceOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.DeleteOfferingInstance(deleteOfferingInstanceOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListOfferingInstanceAudits(listOfferingInstanceAuditsOptions *ListOfferingInstanceAuditsOptions) - Operation response error`, func() {
		listOfferingInstanceAuditsPath := "/instances/offerings/testString/audits"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listOfferingInstanceAuditsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// TODO: Add check for lookupnames query parameter
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListOfferingInstanceAudits with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListOfferingInstanceAuditsOptions model
				listOfferingInstanceAuditsOptionsModel := new(catalogmanagementv1.ListOfferingInstanceAuditsOptions)
				listOfferingInstanceAuditsOptionsModel.InstanceIdentifier = core.StringPtr("testString")
				listOfferingInstanceAuditsOptionsModel.Start = core.StringPtr("testString")
				listOfferingInstanceAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listOfferingInstanceAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listOfferingInstanceAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.ListOfferingInstanceAudits(listOfferingInstanceAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.ListOfferingInstanceAudits(listOfferingInstanceAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListOfferingInstanceAudits(listOfferingInstanceAuditsOptions *ListOfferingInstanceAuditsOptions)`, func() {
		listOfferingInstanceAuditsPath := "/instances/offerings/testString/audits"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listOfferingInstanceAuditsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// TODO: Add check for lookupnames query parameter
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"start": "Start", "limit": 5, "total_count": 10, "resource_count": 13, "first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}, "prev": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}, "audits": [{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message"}]}`)
				}))
			})
			It(`Invoke ListOfferingInstanceAudits successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the ListOfferingInstanceAuditsOptions model
				listOfferingInstanceAuditsOptionsModel := new(catalogmanagementv1.ListOfferingInstanceAuditsOptions)
				listOfferingInstanceAuditsOptionsModel.InstanceIdentifier = core.StringPtr("testString")
				listOfferingInstanceAuditsOptionsModel.Start = core.StringPtr("testString")
				listOfferingInstanceAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listOfferingInstanceAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listOfferingInstanceAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.ListOfferingInstanceAuditsWithContext(ctx, listOfferingInstanceAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.ListOfferingInstanceAudits(listOfferingInstanceAuditsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.ListOfferingInstanceAuditsWithContext(ctx, listOfferingInstanceAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listOfferingInstanceAuditsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// TODO: Add check for lookupnames query parameter
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"start": "Start", "limit": 5, "total_count": 10, "resource_count": 13, "first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}, "prev": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}, "audits": [{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message"}]}`)
				}))
			})
			It(`Invoke ListOfferingInstanceAudits successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.ListOfferingInstanceAudits(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListOfferingInstanceAuditsOptions model
				listOfferingInstanceAuditsOptionsModel := new(catalogmanagementv1.ListOfferingInstanceAuditsOptions)
				listOfferingInstanceAuditsOptionsModel.InstanceIdentifier = core.StringPtr("testString")
				listOfferingInstanceAuditsOptionsModel.Start = core.StringPtr("testString")
				listOfferingInstanceAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listOfferingInstanceAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listOfferingInstanceAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.ListOfferingInstanceAudits(listOfferingInstanceAuditsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListOfferingInstanceAudits with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListOfferingInstanceAuditsOptions model
				listOfferingInstanceAuditsOptionsModel := new(catalogmanagementv1.ListOfferingInstanceAuditsOptions)
				listOfferingInstanceAuditsOptionsModel.InstanceIdentifier = core.StringPtr("testString")
				listOfferingInstanceAuditsOptionsModel.Start = core.StringPtr("testString")
				listOfferingInstanceAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listOfferingInstanceAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listOfferingInstanceAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.ListOfferingInstanceAudits(listOfferingInstanceAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ListOfferingInstanceAuditsOptions model with no property values
				listOfferingInstanceAuditsOptionsModelNew := new(catalogmanagementv1.ListOfferingInstanceAuditsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.ListOfferingInstanceAudits(listOfferingInstanceAuditsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListOfferingInstanceAudits successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListOfferingInstanceAuditsOptions model
				listOfferingInstanceAuditsOptionsModel := new(catalogmanagementv1.ListOfferingInstanceAuditsOptions)
				listOfferingInstanceAuditsOptionsModel.InstanceIdentifier = core.StringPtr("testString")
				listOfferingInstanceAuditsOptionsModel.Start = core.StringPtr("testString")
				listOfferingInstanceAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listOfferingInstanceAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listOfferingInstanceAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.ListOfferingInstanceAudits(listOfferingInstanceAuditsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Test pagination helper method on response`, func() {
			It(`Invoke GetNextStart successfully`, func() {
				responseObject := new(catalogmanagementv1.AuditLogs)
				nextObject := new(catalogmanagementv1.PaginationTokenLink)
				nextObject.Start = core.StringPtr("abc-123")
				responseObject.Next = nextObject
	
				value, err := responseObject.GetNextStart()
				Expect(err).To(BeNil())
				Expect(value).To(Equal(core.StringPtr("abc-123")))
			})
			It(`Invoke GetNextStart without a "Next" property in the response`, func() {
				responseObject := new(catalogmanagementv1.AuditLogs)
	
				value, err := responseObject.GetNextStart()
				Expect(err).To(BeNil())
				Expect(value).To(BeNil())
			})
		})
		Context(`Using mock server endpoint - paginated response`, func() {
			BeforeEach(func() {
				var requestNumber int = 0
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listOfferingInstanceAuditsPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					requestNumber++
					if requestNumber == 1 {
						fmt.Fprintf(res, "%s", `{"next":{"start":"1"},"total_count":2,"limit":1,"audits":[{"id":"ID","_rev":"Rev","created":"2019-01-01T12:00:00.000Z","change_type":"ChangeType","target_type":"TargetType","target_id":"TargetID","who_email":"WhoEmail","who_delegate_email":"WhoDelegateEmail","message":"Message"}]}`)
					} else if requestNumber == 2 {
						fmt.Fprintf(res, "%s", `{"total_count":2,"limit":1,"audits":[{"id":"ID","_rev":"Rev","created":"2019-01-01T12:00:00.000Z","change_type":"ChangeType","target_type":"TargetType","target_id":"TargetID","who_email":"WhoEmail","who_delegate_email":"WhoDelegateEmail","message":"Message"}]}`)
					} else {
						res.WriteHeader(400)
					}
				}))
			})
			It(`Use OfferingInstanceAuditsPager.GetNext successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				listOfferingInstanceAuditsOptionsModel := &catalogmanagementv1.ListOfferingInstanceAuditsOptions{
					InstanceIdentifier: core.StringPtr("testString"),
					Limit: core.Int64Ptr(int64(10)),
					Lookupnames: core.BoolPtr(true),
				}

				pager, err := catalogManagementService.NewOfferingInstanceAuditsPager(listOfferingInstanceAuditsOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				var allResults []catalogmanagementv1.AuditLogDigest
				for pager.HasNext() {
					nextPage, err := pager.GetNext()
					Expect(err).To(BeNil())
					Expect(nextPage).ToNot(BeNil())
					allResults = append(allResults, nextPage...)
				}
				Expect(len(allResults)).To(Equal(2))
			})
			It(`Use OfferingInstanceAuditsPager.GetAll successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				listOfferingInstanceAuditsOptionsModel := &catalogmanagementv1.ListOfferingInstanceAuditsOptions{
					InstanceIdentifier: core.StringPtr("testString"),
					Limit: core.Int64Ptr(int64(10)),
					Lookupnames: core.BoolPtr(true),
				}

				pager, err := catalogManagementService.NewOfferingInstanceAuditsPager(listOfferingInstanceAuditsOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				allResults, err := pager.GetAll()
				Expect(err).To(BeNil())
				Expect(allResults).ToNot(BeNil())
				Expect(len(allResults)).To(Equal(2))
			})
		})
	})
	Describe(`GetOfferingInstanceAudit(getOfferingInstanceAuditOptions *GetOfferingInstanceAuditOptions) - Operation response error`, func() {
		getOfferingInstanceAuditPath := "/instances/offerings/testString/audits/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingInstanceAuditPath))
					Expect(req.Method).To(Equal("GET"))
					// TODO: Add check for lookupnames query parameter
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetOfferingInstanceAudit with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingInstanceAuditOptions model
				getOfferingInstanceAuditOptionsModel := new(catalogmanagementv1.GetOfferingInstanceAuditOptions)
				getOfferingInstanceAuditOptionsModel.InstanceIdentifier = core.StringPtr("testString")
				getOfferingInstanceAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getOfferingInstanceAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getOfferingInstanceAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetOfferingInstanceAudit(getOfferingInstanceAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetOfferingInstanceAudit(getOfferingInstanceAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetOfferingInstanceAudit(getOfferingInstanceAuditOptions *GetOfferingInstanceAuditOptions)`, func() {
		getOfferingInstanceAuditPath := "/instances/offerings/testString/audits/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingInstanceAuditPath))
					Expect(req.Method).To(Equal("GET"))

					// TODO: Add check for lookupnames query parameter
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message", "gid": "Gid", "who_id": "WhoID", "who_name": "WhoName", "who_delegate_id": "WhoDelegateID", "who_delegate_name": "WhoDelegateName", "data": "anyValue"}`)
				}))
			})
			It(`Invoke GetOfferingInstanceAudit successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetOfferingInstanceAuditOptions model
				getOfferingInstanceAuditOptionsModel := new(catalogmanagementv1.GetOfferingInstanceAuditOptions)
				getOfferingInstanceAuditOptionsModel.InstanceIdentifier = core.StringPtr("testString")
				getOfferingInstanceAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getOfferingInstanceAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getOfferingInstanceAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetOfferingInstanceAuditWithContext(ctx, getOfferingInstanceAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetOfferingInstanceAudit(getOfferingInstanceAuditOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetOfferingInstanceAuditWithContext(ctx, getOfferingInstanceAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingInstanceAuditPath))
					Expect(req.Method).To(Equal("GET"))

					// TODO: Add check for lookupnames query parameter
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message", "gid": "Gid", "who_id": "WhoID", "who_name": "WhoName", "who_delegate_id": "WhoDelegateID", "who_delegate_name": "WhoDelegateName", "data": "anyValue"}`)
				}))
			})
			It(`Invoke GetOfferingInstanceAudit successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetOfferingInstanceAudit(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetOfferingInstanceAuditOptions model
				getOfferingInstanceAuditOptionsModel := new(catalogmanagementv1.GetOfferingInstanceAuditOptions)
				getOfferingInstanceAuditOptionsModel.InstanceIdentifier = core.StringPtr("testString")
				getOfferingInstanceAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getOfferingInstanceAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getOfferingInstanceAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetOfferingInstanceAudit(getOfferingInstanceAuditOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetOfferingInstanceAudit with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingInstanceAuditOptions model
				getOfferingInstanceAuditOptionsModel := new(catalogmanagementv1.GetOfferingInstanceAuditOptions)
				getOfferingInstanceAuditOptionsModel.InstanceIdentifier = core.StringPtr("testString")
				getOfferingInstanceAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getOfferingInstanceAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getOfferingInstanceAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetOfferingInstanceAudit(getOfferingInstanceAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetOfferingInstanceAuditOptions model with no property values
				getOfferingInstanceAuditOptionsModelNew := new(catalogmanagementv1.GetOfferingInstanceAuditOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetOfferingInstanceAudit(getOfferingInstanceAuditOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetOfferingInstanceAudit successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingInstanceAuditOptions model
				getOfferingInstanceAuditOptionsModel := new(catalogmanagementv1.GetOfferingInstanceAuditOptions)
				getOfferingInstanceAuditOptionsModel.InstanceIdentifier = core.StringPtr("testString")
				getOfferingInstanceAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getOfferingInstanceAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getOfferingInstanceAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetOfferingInstanceAudit(getOfferingInstanceAuditOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`Model constructor tests`, func() {
		Context(`Using a service client instance`, func() {
			catalogManagementService, _ := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
				URL:           "http://catalogmanagementv1modelgenerator.com",
				Authenticator: &core.NoAuthAuthenticator{},
			})
			It(`Invoke NewAccountPublishObjectOptions successfully`, func() {
				// Construct an instance of the AccountPublishObjectOptions model
				catalogIdentifier := "testString"
				objectIdentifier := "testString"
				accountPublishObjectOptionsModel := catalogManagementService.NewAccountPublishObjectOptions(catalogIdentifier, objectIdentifier)
				accountPublishObjectOptionsModel.SetCatalogIdentifier("testString")
				accountPublishObjectOptionsModel.SetObjectIdentifier("testString")
				accountPublishObjectOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(accountPublishObjectOptionsModel).ToNot(BeNil())
				Expect(accountPublishObjectOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(accountPublishObjectOptionsModel.ObjectIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(accountPublishObjectOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewAccountPublishVersionOptions successfully`, func() {
				// Construct an instance of the AccountPublishVersionOptions model
				versionLocID := "testString"
				accountPublishVersionOptionsModel := catalogManagementService.NewAccountPublishVersionOptions(versionLocID)
				accountPublishVersionOptionsModel.SetVersionLocID("testString")
				accountPublishVersionOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(accountPublishVersionOptionsModel).ToNot(BeNil())
				Expect(accountPublishVersionOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(accountPublishVersionOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewAddObjectAccessListOptions successfully`, func() {
				// Construct an instance of the AddObjectAccessListOptions model
				catalogIdentifier := "testString"
				objectIdentifier := "testString"
				accesses := []string{"testString"}
				addObjectAccessListOptionsModel := catalogManagementService.NewAddObjectAccessListOptions(catalogIdentifier, objectIdentifier, accesses)
				addObjectAccessListOptionsModel.SetCatalogIdentifier("testString")
				addObjectAccessListOptionsModel.SetObjectIdentifier("testString")
				addObjectAccessListOptionsModel.SetAccesses([]string{"testString"})
				addObjectAccessListOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(addObjectAccessListOptionsModel).ToNot(BeNil())
				Expect(addObjectAccessListOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(addObjectAccessListOptionsModel.ObjectIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(addObjectAccessListOptionsModel.Accesses).To(Equal([]string{"testString"}))
				Expect(addObjectAccessListOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewAddOfferingAccessListOptions successfully`, func() {
				// Construct an instance of the AddOfferingAccessListOptions model
				catalogIdentifier := "testString"
				offeringID := "testString"
				accesses := []string{"testString"}
				addOfferingAccessListOptionsModel := catalogManagementService.NewAddOfferingAccessListOptions(catalogIdentifier, offeringID, accesses)
				addOfferingAccessListOptionsModel.SetCatalogIdentifier("testString")
				addOfferingAccessListOptionsModel.SetOfferingID("testString")
				addOfferingAccessListOptionsModel.SetAccesses([]string{"testString"})
				addOfferingAccessListOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(addOfferingAccessListOptionsModel).ToNot(BeNil())
				Expect(addOfferingAccessListOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(addOfferingAccessListOptionsModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(addOfferingAccessListOptionsModel.Accesses).To(Equal([]string{"testString"}))
				Expect(addOfferingAccessListOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewArchiveVersionOptions successfully`, func() {
				// Construct an instance of the ArchiveVersionOptions model
				versionLocID := "testString"
				archiveVersionOptionsModel := catalogManagementService.NewArchiveVersionOptions(versionLocID)
				archiveVersionOptionsModel.SetVersionLocID("testString")
				archiveVersionOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(archiveVersionOptionsModel).ToNot(BeNil())
				Expect(archiveVersionOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(archiveVersionOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCommitVersionOptions successfully`, func() {
				// Construct an instance of the CommitVersionOptions model
				versionLocID := "testString"
				commitVersionOptionsModel := catalogManagementService.NewCommitVersionOptions(versionLocID)
				commitVersionOptionsModel.SetVersionLocID("testString")
				commitVersionOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(commitVersionOptionsModel).ToNot(BeNil())
				Expect(commitVersionOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(commitVersionOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewConsumableShareObjectOptions successfully`, func() {
				// Construct an instance of the ConsumableShareObjectOptions model
				catalogIdentifier := "testString"
				objectIdentifier := "testString"
				consumableShareObjectOptionsModel := catalogManagementService.NewConsumableShareObjectOptions(catalogIdentifier, objectIdentifier)
				consumableShareObjectOptionsModel.SetCatalogIdentifier("testString")
				consumableShareObjectOptionsModel.SetObjectIdentifier("testString")
				consumableShareObjectOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(consumableShareObjectOptionsModel).ToNot(BeNil())
				Expect(consumableShareObjectOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(consumableShareObjectOptionsModel.ObjectIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(consumableShareObjectOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewConsumableVersionOptions successfully`, func() {
				// Construct an instance of the ConsumableVersionOptions model
				versionLocID := "testString"
				consumableVersionOptionsModel := catalogManagementService.NewConsumableVersionOptions(versionLocID)
				consumableVersionOptionsModel.SetVersionLocID("testString")
				consumableVersionOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(consumableVersionOptionsModel).ToNot(BeNil())
				Expect(consumableVersionOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(consumableVersionOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCopyFromPreviousVersionOptions successfully`, func() {
				// Construct an instance of the CopyFromPreviousVersionOptions model
				versionLocID := "testString"
				typeVar := "testString"
				versionLocIDToCopyFrom := "testString"
				copyFromPreviousVersionOptionsModel := catalogManagementService.NewCopyFromPreviousVersionOptions(versionLocID, typeVar, versionLocIDToCopyFrom)
				copyFromPreviousVersionOptionsModel.SetVersionLocID("testString")
				copyFromPreviousVersionOptionsModel.SetType("testString")
				copyFromPreviousVersionOptionsModel.SetVersionLocIDToCopyFrom("testString")
				copyFromPreviousVersionOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(copyFromPreviousVersionOptionsModel).ToNot(BeNil())
				Expect(copyFromPreviousVersionOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(copyFromPreviousVersionOptionsModel.Type).To(Equal(core.StringPtr("testString")))
				Expect(copyFromPreviousVersionOptionsModel.VersionLocIDToCopyFrom).To(Equal(core.StringPtr("testString")))
				Expect(copyFromPreviousVersionOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCopyVersionOptions successfully`, func() {
				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				Expect(flavorModel).ToNot(BeNil())
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = make(map[string]string)
				flavorModel.Index = core.Int64Ptr(int64(38))
				Expect(flavorModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(flavorModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(flavorModel.LabelI18n).To(Equal(make(map[string]string)))
				Expect(flavorModel.Index).To(Equal(core.Int64Ptr(int64(38))))

				// Construct an instance of the CopyVersionOptions model
				versionLocID := "testString"
				copyVersionOptionsModel := catalogManagementService.NewCopyVersionOptions(versionLocID)
				copyVersionOptionsModel.SetVersionLocID("testString")
				copyVersionOptionsModel.SetTags([]string{"testString"})
				copyVersionOptionsModel.SetContent(*CreateMockByteArray("This is a mock byte array value."))
				copyVersionOptionsModel.SetTargetKinds([]string{"testString"})
				copyVersionOptionsModel.SetFormatKind("testString")
				copyVersionOptionsModel.SetFlavor(flavorModel)
				copyVersionOptionsModel.SetWorkingDirectory("testString")
				copyVersionOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(copyVersionOptionsModel).ToNot(BeNil())
				Expect(copyVersionOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(copyVersionOptionsModel.Tags).To(Equal([]string{"testString"}))
				Expect(copyVersionOptionsModel.Content).To(Equal(CreateMockByteArray("This is a mock byte array value.")))
				Expect(copyVersionOptionsModel.TargetKinds).To(Equal([]string{"testString"}))
				Expect(copyVersionOptionsModel.FormatKind).To(Equal(core.StringPtr("testString")))
				Expect(copyVersionOptionsModel.Flavor).To(Equal(flavorModel))
				Expect(copyVersionOptionsModel.WorkingDirectory).To(Equal(core.StringPtr("testString")))
				Expect(copyVersionOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateCatalogOptions successfully`, func() {
				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				Expect(featureModel).ToNot(BeNil())
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = make(map[string]string)
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = make(map[string]string)
				Expect(featureModel.Title).To(Equal(core.StringPtr("testString")))
				Expect(featureModel.TitleI18n).To(Equal(make(map[string]string)))
				Expect(featureModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(featureModel.DescriptionI18n).To(Equal(make(map[string]string)))

				// Construct an instance of the FilterTerms model
				filterTermsModel := new(catalogmanagementv1.FilterTerms)
				Expect(filterTermsModel).ToNot(BeNil())
				filterTermsModel.FilterTerms = []string{"testString"}
				Expect(filterTermsModel.FilterTerms).To(Equal([]string{"testString"}))

				// Construct an instance of the CategoryFilter model
				categoryFilterModel := new(catalogmanagementv1.CategoryFilter)
				Expect(categoryFilterModel).ToNot(BeNil())
				categoryFilterModel.Include = core.BoolPtr(true)
				categoryFilterModel.Filter = filterTermsModel
				Expect(categoryFilterModel.Include).To(Equal(core.BoolPtr(true)))
				Expect(categoryFilterModel.Filter).To(Equal(filterTermsModel))

				// Construct an instance of the IDFilter model
				idFilterModel := new(catalogmanagementv1.IDFilter)
				Expect(idFilterModel).ToNot(BeNil())
				idFilterModel.Include = filterTermsModel
				idFilterModel.Exclude = filterTermsModel
				Expect(idFilterModel.Include).To(Equal(filterTermsModel))
				Expect(idFilterModel.Exclude).To(Equal(filterTermsModel))

				// Construct an instance of the Filters model
				filtersModel := new(catalogmanagementv1.Filters)
				Expect(filtersModel).ToNot(BeNil())
				filtersModel.IncludeAll = core.BoolPtr(true)
				filtersModel.CategoryFilters = make(map[string]catalogmanagementv1.CategoryFilter)
				filtersModel.IDFilters = idFilterModel
				filtersModel.CategoryFilters["foo"] = *categoryFilterModel
				Expect(filtersModel.IncludeAll).To(Equal(core.BoolPtr(true)))
				Expect(filtersModel.IDFilters).To(Equal(idFilterModel))
				Expect(filtersModel.CategoryFilters["foo"]).To(Equal(*categoryFilterModel))

				// Construct an instance of the SyndicationCluster model
				syndicationClusterModel := new(catalogmanagementv1.SyndicationCluster)
				Expect(syndicationClusterModel).ToNot(BeNil())
				syndicationClusterModel.Region = core.StringPtr("testString")
				syndicationClusterModel.ID = core.StringPtr("testString")
				syndicationClusterModel.Name = core.StringPtr("testString")
				syndicationClusterModel.ResourceGroupName = core.StringPtr("testString")
				syndicationClusterModel.Type = core.StringPtr("testString")
				syndicationClusterModel.Namespaces = []string{"testString"}
				syndicationClusterModel.AllNamespaces = core.BoolPtr(true)
				Expect(syndicationClusterModel.Region).To(Equal(core.StringPtr("testString")))
				Expect(syndicationClusterModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(syndicationClusterModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(syndicationClusterModel.ResourceGroupName).To(Equal(core.StringPtr("testString")))
				Expect(syndicationClusterModel.Type).To(Equal(core.StringPtr("testString")))
				Expect(syndicationClusterModel.Namespaces).To(Equal([]string{"testString"}))
				Expect(syndicationClusterModel.AllNamespaces).To(Equal(core.BoolPtr(true)))

				// Construct an instance of the SyndicationHistory model
				syndicationHistoryModel := new(catalogmanagementv1.SyndicationHistory)
				Expect(syndicationHistoryModel).ToNot(BeNil())
				syndicationHistoryModel.Namespaces = []string{"testString"}
				syndicationHistoryModel.Clusters = []catalogmanagementv1.SyndicationCluster{*syndicationClusterModel}
				syndicationHistoryModel.LastRun = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				Expect(syndicationHistoryModel.Namespaces).To(Equal([]string{"testString"}))
				Expect(syndicationHistoryModel.Clusters).To(Equal([]catalogmanagementv1.SyndicationCluster{*syndicationClusterModel}))
				Expect(syndicationHistoryModel.LastRun).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))

				// Construct an instance of the SyndicationAuthorization model
				syndicationAuthorizationModel := new(catalogmanagementv1.SyndicationAuthorization)
				Expect(syndicationAuthorizationModel).ToNot(BeNil())
				syndicationAuthorizationModel.Token = core.StringPtr("testString")
				syndicationAuthorizationModel.LastRun = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				Expect(syndicationAuthorizationModel.Token).To(Equal(core.StringPtr("testString")))
				Expect(syndicationAuthorizationModel.LastRun).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))

				// Construct an instance of the SyndicationResource model
				syndicationResourceModel := new(catalogmanagementv1.SyndicationResource)
				Expect(syndicationResourceModel).ToNot(BeNil())
				syndicationResourceModel.RemoveRelatedComponents = core.BoolPtr(true)
				syndicationResourceModel.Clusters = []catalogmanagementv1.SyndicationCluster{*syndicationClusterModel}
				syndicationResourceModel.History = syndicationHistoryModel
				syndicationResourceModel.Authorization = syndicationAuthorizationModel
				Expect(syndicationResourceModel.RemoveRelatedComponents).To(Equal(core.BoolPtr(true)))
				Expect(syndicationResourceModel.Clusters).To(Equal([]catalogmanagementv1.SyndicationCluster{*syndicationClusterModel}))
				Expect(syndicationResourceModel.History).To(Equal(syndicationHistoryModel))
				Expect(syndicationResourceModel.Authorization).To(Equal(syndicationAuthorizationModel))

				// Construct an instance of the CreateCatalogOptions model
				createCatalogOptionsModel := catalogManagementService.NewCreateCatalogOptions()
				createCatalogOptionsModel.SetID("testString")
				createCatalogOptionsModel.SetRev("testString")
				createCatalogOptionsModel.SetLabel("testString")
				createCatalogOptionsModel.SetLabelI18n(make(map[string]string))
				createCatalogOptionsModel.SetShortDescription("testString")
				createCatalogOptionsModel.SetShortDescriptionI18n(make(map[string]string))
				createCatalogOptionsModel.SetCatalogIconURL("testString")
				createCatalogOptionsModel.SetTags([]string{"testString"})
				createCatalogOptionsModel.SetFeatures([]catalogmanagementv1.Feature{*featureModel})
				createCatalogOptionsModel.SetDisabled(true)
				createCatalogOptionsModel.SetResourceGroupID("testString")
				createCatalogOptionsModel.SetOwningAccount("testString")
				createCatalogOptionsModel.SetCatalogFilters(filtersModel)
				createCatalogOptionsModel.SetSyndicationSettings(syndicationResourceModel)
				createCatalogOptionsModel.SetKind("testString")
				createCatalogOptionsModel.SetMetadata(make(map[string]interface{}))
				createCatalogOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createCatalogOptionsModel).ToNot(BeNil())
				Expect(createCatalogOptionsModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(createCatalogOptionsModel.Rev).To(Equal(core.StringPtr("testString")))
				Expect(createCatalogOptionsModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(createCatalogOptionsModel.LabelI18n).To(Equal(make(map[string]string)))
				Expect(createCatalogOptionsModel.ShortDescription).To(Equal(core.StringPtr("testString")))
				Expect(createCatalogOptionsModel.ShortDescriptionI18n).To(Equal(make(map[string]string)))
				Expect(createCatalogOptionsModel.CatalogIconURL).To(Equal(core.StringPtr("testString")))
				Expect(createCatalogOptionsModel.Tags).To(Equal([]string{"testString"}))
				Expect(createCatalogOptionsModel.Features).To(Equal([]catalogmanagementv1.Feature{*featureModel}))
				Expect(createCatalogOptionsModel.Disabled).To(Equal(core.BoolPtr(true)))
				Expect(createCatalogOptionsModel.ResourceGroupID).To(Equal(core.StringPtr("testString")))
				Expect(createCatalogOptionsModel.OwningAccount).To(Equal(core.StringPtr("testString")))
				Expect(createCatalogOptionsModel.CatalogFilters).To(Equal(filtersModel))
				Expect(createCatalogOptionsModel.SyndicationSettings).To(Equal(syndicationResourceModel))
				Expect(createCatalogOptionsModel.Kind).To(Equal(core.StringPtr("testString")))
				Expect(createCatalogOptionsModel.Metadata).To(Equal(make(map[string]interface{})))
				Expect(createCatalogOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateObjectAccessOptions successfully`, func() {
				// Construct an instance of the CreateObjectAccessOptions model
				catalogIdentifier := "testString"
				objectIdentifier := "testString"
				accessIdentifier := "testString"
				createObjectAccessOptionsModel := catalogManagementService.NewCreateObjectAccessOptions(catalogIdentifier, objectIdentifier, accessIdentifier)
				createObjectAccessOptionsModel.SetCatalogIdentifier("testString")
				createObjectAccessOptionsModel.SetObjectIdentifier("testString")
				createObjectAccessOptionsModel.SetAccessIdentifier("testString")
				createObjectAccessOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createObjectAccessOptionsModel).ToNot(BeNil())
				Expect(createObjectAccessOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(createObjectAccessOptionsModel.ObjectIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(createObjectAccessOptionsModel.AccessIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(createObjectAccessOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateObjectOptions successfully`, func() {
				// Construct an instance of the PublishObject model
				publishObjectModel := new(catalogmanagementv1.PublishObject)
				Expect(publishObjectModel).ToNot(BeNil())
				publishObjectModel.PermitIBMPublicPublish = core.BoolPtr(true)
				publishObjectModel.IBMApproved = core.BoolPtr(true)
				publishObjectModel.PublicApproved = core.BoolPtr(true)
				publishObjectModel.PortalApprovalRecord = core.StringPtr("testString")
				publishObjectModel.PortalURL = core.StringPtr("testString")
				Expect(publishObjectModel.PermitIBMPublicPublish).To(Equal(core.BoolPtr(true)))
				Expect(publishObjectModel.IBMApproved).To(Equal(core.BoolPtr(true)))
				Expect(publishObjectModel.PublicApproved).To(Equal(core.BoolPtr(true)))
				Expect(publishObjectModel.PortalApprovalRecord).To(Equal(core.StringPtr("testString")))
				Expect(publishObjectModel.PortalURL).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				Expect(stateModel).ToNot(BeNil())
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")
				Expect(stateModel.Current).To(Equal(core.StringPtr("testString")))
				Expect(stateModel.CurrentEntered).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(stateModel.Pending).To(Equal(core.StringPtr("testString")))
				Expect(stateModel.PendingRequested).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(stateModel.Previous).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the CreateObjectOptions model
				catalogIdentifier := "testString"
				createObjectOptionsModel := catalogManagementService.NewCreateObjectOptions(catalogIdentifier)
				createObjectOptionsModel.SetCatalogIdentifier("testString")
				createObjectOptionsModel.SetID("testString")
				createObjectOptionsModel.SetName("testString")
				createObjectOptionsModel.SetRev("testString")
				createObjectOptionsModel.SetCRN("testString")
				createObjectOptionsModel.SetURL("testString")
				createObjectOptionsModel.SetParentID("testString")
				createObjectOptionsModel.SetLabelI18n(make(map[string]string))
				createObjectOptionsModel.SetLabel("testString")
				createObjectOptionsModel.SetTags([]string{"testString"})
				createObjectOptionsModel.SetCreated(CreateMockDateTime("2019-01-01T12:00:00.000Z"))
				createObjectOptionsModel.SetUpdated(CreateMockDateTime("2019-01-01T12:00:00.000Z"))
				createObjectOptionsModel.SetShortDescription("testString")
				createObjectOptionsModel.SetShortDescriptionI18n(make(map[string]string))
				createObjectOptionsModel.SetKind("testString")
				createObjectOptionsModel.SetPublish(publishObjectModel)
				createObjectOptionsModel.SetState(stateModel)
				createObjectOptionsModel.SetCatalogID("testString")
				createObjectOptionsModel.SetCatalogName("testString")
				createObjectOptionsModel.SetData(make(map[string]interface{}))
				createObjectOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createObjectOptionsModel).ToNot(BeNil())
				Expect(createObjectOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(createObjectOptionsModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(createObjectOptionsModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(createObjectOptionsModel.Rev).To(Equal(core.StringPtr("testString")))
				Expect(createObjectOptionsModel.CRN).To(Equal(core.StringPtr("testString")))
				Expect(createObjectOptionsModel.URL).To(Equal(core.StringPtr("testString")))
				Expect(createObjectOptionsModel.ParentID).To(Equal(core.StringPtr("testString")))
				Expect(createObjectOptionsModel.LabelI18n).To(Equal(make(map[string]string)))
				Expect(createObjectOptionsModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(createObjectOptionsModel.Tags).To(Equal([]string{"testString"}))
				Expect(createObjectOptionsModel.Created).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(createObjectOptionsModel.Updated).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(createObjectOptionsModel.ShortDescription).To(Equal(core.StringPtr("testString")))
				Expect(createObjectOptionsModel.ShortDescriptionI18n).To(Equal(make(map[string]string)))
				Expect(createObjectOptionsModel.Kind).To(Equal(core.StringPtr("testString")))
				Expect(createObjectOptionsModel.Publish).To(Equal(publishObjectModel))
				Expect(createObjectOptionsModel.State).To(Equal(stateModel))
				Expect(createObjectOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(createObjectOptionsModel.CatalogName).To(Equal(core.StringPtr("testString")))
				Expect(createObjectOptionsModel.Data).To(Equal(make(map[string]interface{})))
				Expect(createObjectOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateOfferingInstanceOptions successfully`, func() {
				// Construct an instance of the OfferingInstanceLastOperation model
				offeringInstanceLastOperationModel := new(catalogmanagementv1.OfferingInstanceLastOperation)
				Expect(offeringInstanceLastOperationModel).ToNot(BeNil())
				offeringInstanceLastOperationModel.Operation = core.StringPtr("testString")
				offeringInstanceLastOperationModel.State = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Message = core.StringPtr("testString")
				offeringInstanceLastOperationModel.TransactionID = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				offeringInstanceLastOperationModel.Code = core.StringPtr("testString")
				Expect(offeringInstanceLastOperationModel.Operation).To(Equal(core.StringPtr("testString")))
				Expect(offeringInstanceLastOperationModel.State).To(Equal(core.StringPtr("testString")))
				Expect(offeringInstanceLastOperationModel.Message).To(Equal(core.StringPtr("testString")))
				Expect(offeringInstanceLastOperationModel.TransactionID).To(Equal(core.StringPtr("testString")))
				Expect(offeringInstanceLastOperationModel.Updated).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(offeringInstanceLastOperationModel.Code).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the CreateOfferingInstanceOptions model
				xAuthRefreshToken := "testString"
				createOfferingInstanceOptionsModel := catalogManagementService.NewCreateOfferingInstanceOptions(xAuthRefreshToken)
				createOfferingInstanceOptionsModel.SetXAuthRefreshToken("testString")
				createOfferingInstanceOptionsModel.SetID("testString")
				createOfferingInstanceOptionsModel.SetRev("testString")
				createOfferingInstanceOptionsModel.SetURL("testString")
				createOfferingInstanceOptionsModel.SetCRN("testString")
				createOfferingInstanceOptionsModel.SetLabel("testString")
				createOfferingInstanceOptionsModel.SetCatalogID("testString")
				createOfferingInstanceOptionsModel.SetOfferingID("testString")
				createOfferingInstanceOptionsModel.SetKindFormat("testString")
				createOfferingInstanceOptionsModel.SetVersion("testString")
				createOfferingInstanceOptionsModel.SetVersionID("testString")
				createOfferingInstanceOptionsModel.SetClusterID("testString")
				createOfferingInstanceOptionsModel.SetClusterRegion("testString")
				createOfferingInstanceOptionsModel.SetClusterNamespaces([]string{"testString"})
				createOfferingInstanceOptionsModel.SetClusterAllNamespaces(true)
				createOfferingInstanceOptionsModel.SetSchematicsWorkspaceID("testString")
				createOfferingInstanceOptionsModel.SetInstallPlan("testString")
				createOfferingInstanceOptionsModel.SetChannel("testString")
				createOfferingInstanceOptionsModel.SetCreated(CreateMockDateTime("2019-01-01T12:00:00.000Z"))
				createOfferingInstanceOptionsModel.SetUpdated(CreateMockDateTime("2019-01-01T12:00:00.000Z"))
				createOfferingInstanceOptionsModel.SetMetadata(make(map[string]interface{}))
				createOfferingInstanceOptionsModel.SetResourceGroupID("testString")
				createOfferingInstanceOptionsModel.SetLocation("testString")
				createOfferingInstanceOptionsModel.SetDisabled(true)
				createOfferingInstanceOptionsModel.SetAccount("testString")
				createOfferingInstanceOptionsModel.SetLastOperation(offeringInstanceLastOperationModel)
				createOfferingInstanceOptionsModel.SetKindTarget("testString")
				createOfferingInstanceOptionsModel.SetSha("testString")
				createOfferingInstanceOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createOfferingInstanceOptionsModel).ToNot(BeNil())
				Expect(createOfferingInstanceOptionsModel.XAuthRefreshToken).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingInstanceOptionsModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingInstanceOptionsModel.Rev).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingInstanceOptionsModel.URL).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingInstanceOptionsModel.CRN).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingInstanceOptionsModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingInstanceOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingInstanceOptionsModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingInstanceOptionsModel.KindFormat).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingInstanceOptionsModel.Version).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingInstanceOptionsModel.VersionID).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingInstanceOptionsModel.ClusterID).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingInstanceOptionsModel.ClusterRegion).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingInstanceOptionsModel.ClusterNamespaces).To(Equal([]string{"testString"}))
				Expect(createOfferingInstanceOptionsModel.ClusterAllNamespaces).To(Equal(core.BoolPtr(true)))
				Expect(createOfferingInstanceOptionsModel.SchematicsWorkspaceID).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingInstanceOptionsModel.InstallPlan).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingInstanceOptionsModel.Channel).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingInstanceOptionsModel.Created).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(createOfferingInstanceOptionsModel.Updated).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(createOfferingInstanceOptionsModel.Metadata).To(Equal(make(map[string]interface{})))
				Expect(createOfferingInstanceOptionsModel.ResourceGroupID).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingInstanceOptionsModel.Location).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingInstanceOptionsModel.Disabled).To(Equal(core.BoolPtr(true)))
				Expect(createOfferingInstanceOptionsModel.Account).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingInstanceOptionsModel.LastOperation).To(Equal(offeringInstanceLastOperationModel))
				Expect(createOfferingInstanceOptionsModel.KindTarget).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingInstanceOptionsModel.Sha).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingInstanceOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateOfferingOptions successfully`, func() {
				// Construct an instance of the Rating model
				ratingModel := new(catalogmanagementv1.Rating)
				Expect(ratingModel).ToNot(BeNil())
				ratingModel.OneStarCount = core.Int64Ptr(int64(38))
				ratingModel.TwoStarCount = core.Int64Ptr(int64(38))
				ratingModel.ThreeStarCount = core.Int64Ptr(int64(38))
				ratingModel.FourStarCount = core.Int64Ptr(int64(38))
				Expect(ratingModel.OneStarCount).To(Equal(core.Int64Ptr(int64(38))))
				Expect(ratingModel.TwoStarCount).To(Equal(core.Int64Ptr(int64(38))))
				Expect(ratingModel.ThreeStarCount).To(Equal(core.Int64Ptr(int64(38))))
				Expect(ratingModel.FourStarCount).To(Equal(core.Int64Ptr(int64(38))))

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				Expect(featureModel).ToNot(BeNil())
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = make(map[string]string)
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = make(map[string]string)
				Expect(featureModel.Title).To(Equal(core.StringPtr("testString")))
				Expect(featureModel.TitleI18n).To(Equal(make(map[string]string)))
				Expect(featureModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(featureModel.DescriptionI18n).To(Equal(make(map[string]string)))

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				Expect(flavorModel).ToNot(BeNil())
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = make(map[string]string)
				flavorModel.Index = core.Int64Ptr(int64(38))
				Expect(flavorModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(flavorModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(flavorModel.LabelI18n).To(Equal(make(map[string]string)))
				Expect(flavorModel.Index).To(Equal(core.Int64Ptr(int64(38))))

				// Construct an instance of the RenderTypeAssociationsParametersItem model
				renderTypeAssociationsParametersItemModel := new(catalogmanagementv1.RenderTypeAssociationsParametersItem)
				Expect(renderTypeAssociationsParametersItemModel).ToNot(BeNil())
				renderTypeAssociationsParametersItemModel.Name = core.StringPtr("testString")
				renderTypeAssociationsParametersItemModel.OptionsRefresh = core.BoolPtr(true)
				Expect(renderTypeAssociationsParametersItemModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(renderTypeAssociationsParametersItemModel.OptionsRefresh).To(Equal(core.BoolPtr(true)))

				// Construct an instance of the RenderTypeAssociations model
				renderTypeAssociationsModel := new(catalogmanagementv1.RenderTypeAssociations)
				Expect(renderTypeAssociationsModel).ToNot(BeNil())
				renderTypeAssociationsModel.Parameters = []catalogmanagementv1.RenderTypeAssociationsParametersItem{*renderTypeAssociationsParametersItemModel}
				Expect(renderTypeAssociationsModel.Parameters).To(Equal([]catalogmanagementv1.RenderTypeAssociationsParametersItem{*renderTypeAssociationsParametersItemModel}))

				// Construct an instance of the RenderType model
				renderTypeModel := new(catalogmanagementv1.RenderType)
				Expect(renderTypeModel).ToNot(BeNil())
				renderTypeModel.Type = core.StringPtr("testString")
				renderTypeModel.Grouping = core.StringPtr("testString")
				renderTypeModel.OriginalGrouping = core.StringPtr("testString")
				renderTypeModel.GroupingIndex = core.Int64Ptr(int64(38))
				renderTypeModel.ConfigConstraints = map[string]interface{}{"anyKey": "anyValue"}
				renderTypeModel.Associations = renderTypeAssociationsModel
				Expect(renderTypeModel.Type).To(Equal(core.StringPtr("testString")))
				Expect(renderTypeModel.Grouping).To(Equal(core.StringPtr("testString")))
				Expect(renderTypeModel.OriginalGrouping).To(Equal(core.StringPtr("testString")))
				Expect(renderTypeModel.GroupingIndex).To(Equal(core.Int64Ptr(int64(38))))
				Expect(renderTypeModel.ConfigConstraints).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(renderTypeModel.Associations).To(Equal(renderTypeAssociationsModel))

				// Construct an instance of the Configuration model
				configurationModel := new(catalogmanagementv1.Configuration)
				Expect(configurationModel).ToNot(BeNil())
				configurationModel.Key = core.StringPtr("testString")
				configurationModel.Type = core.StringPtr("testString")
				configurationModel.DefaultValue = core.StringPtr("testString")
				configurationModel.DisplayName = core.StringPtr("testString")
				configurationModel.ValueConstraint = core.StringPtr("testString")
				configurationModel.Description = core.StringPtr("testString")
				configurationModel.Required = core.BoolPtr(true)
				configurationModel.Options = []interface{}{"testString"}
				configurationModel.Hidden = core.BoolPtr(true)
				configurationModel.CustomConfig = renderTypeModel
				configurationModel.TypeMetadata = core.StringPtr("testString")
				Expect(configurationModel.Key).To(Equal(core.StringPtr("testString")))
				Expect(configurationModel.Type).To(Equal(core.StringPtr("testString")))
				Expect(configurationModel.DefaultValue).To(Equal(core.StringPtr("testString")))
				Expect(configurationModel.DisplayName).To(Equal(core.StringPtr("testString")))
				Expect(configurationModel.ValueConstraint).To(Equal(core.StringPtr("testString")))
				Expect(configurationModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(configurationModel.Required).To(Equal(core.BoolPtr(true)))
				Expect(configurationModel.Options).To(Equal([]interface{}{"testString"}))
				Expect(configurationModel.Hidden).To(Equal(core.BoolPtr(true)))
				Expect(configurationModel.CustomConfig).To(Equal(renderTypeModel))
				Expect(configurationModel.TypeMetadata).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the Output model
				outputModel := new(catalogmanagementv1.Output)
				Expect(outputModel).ToNot(BeNil())
				outputModel.Key = core.StringPtr("testString")
				outputModel.Description = core.StringPtr("testString")
				Expect(outputModel.Key).To(Equal(core.StringPtr("testString")))
				Expect(outputModel.Description).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the IamResource model
				iamResourceModel := new(catalogmanagementv1.IamResource)
				Expect(iamResourceModel).ToNot(BeNil())
				iamResourceModel.Name = core.StringPtr("testString")
				iamResourceModel.Description = core.StringPtr("testString")
				iamResourceModel.RoleCrns = []string{"testString"}
				Expect(iamResourceModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(iamResourceModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(iamResourceModel.RoleCrns).To(Equal([]string{"testString"}))

				// Construct an instance of the IamPermission model
				iamPermissionModel := new(catalogmanagementv1.IamPermission)
				Expect(iamPermissionModel).ToNot(BeNil())
				iamPermissionModel.ServiceName = core.StringPtr("testString")
				iamPermissionModel.RoleCrns = []string{"testString"}
				iamPermissionModel.Resources = []catalogmanagementv1.IamResource{*iamResourceModel}
				Expect(iamPermissionModel.ServiceName).To(Equal(core.StringPtr("testString")))
				Expect(iamPermissionModel.RoleCrns).To(Equal([]string{"testString"}))
				Expect(iamPermissionModel.Resources).To(Equal([]catalogmanagementv1.IamResource{*iamResourceModel}))

				// Construct an instance of the Validation model
				validationModel := new(catalogmanagementv1.Validation)
				Expect(validationModel).ToNot(BeNil())
				validationModel.Validated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.Requested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.State = core.StringPtr("testString")
				validationModel.LastOperation = core.StringPtr("testString")
				validationModel.Target = make(map[string]interface{})
				validationModel.Message = core.StringPtr("testString")
				Expect(validationModel.Validated).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(validationModel.Requested).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(validationModel.State).To(Equal(core.StringPtr("testString")))
				Expect(validationModel.LastOperation).To(Equal(core.StringPtr("testString")))
				Expect(validationModel.Target).To(Equal(make(map[string]interface{})))
				Expect(validationModel.Message).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the Resource model
				resourceModel := new(catalogmanagementv1.Resource)
				Expect(resourceModel).ToNot(BeNil())
				resourceModel.Type = core.StringPtr("mem")
				resourceModel.Value = core.StringPtr("testString")
				Expect(resourceModel.Type).To(Equal(core.StringPtr("mem")))
				Expect(resourceModel.Value).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the Script model
				scriptModel := new(catalogmanagementv1.Script)
				Expect(scriptModel).ToNot(BeNil())
				scriptModel.Instructions = core.StringPtr("testString")
				scriptModel.InstructionsI18n = make(map[string]string)
				scriptModel.Script = core.StringPtr("testString")
				scriptModel.ScriptPermission = core.StringPtr("testString")
				scriptModel.DeleteScript = core.StringPtr("testString")
				scriptModel.Scope = core.StringPtr("testString")
				Expect(scriptModel.Instructions).To(Equal(core.StringPtr("testString")))
				Expect(scriptModel.InstructionsI18n).To(Equal(make(map[string]string)))
				Expect(scriptModel.Script).To(Equal(core.StringPtr("testString")))
				Expect(scriptModel.ScriptPermission).To(Equal(core.StringPtr("testString")))
				Expect(scriptModel.DeleteScript).To(Equal(core.StringPtr("testString")))
				Expect(scriptModel.Scope).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the VersionEntitlement model
				versionEntitlementModel := new(catalogmanagementv1.VersionEntitlement)
				Expect(versionEntitlementModel).ToNot(BeNil())
				versionEntitlementModel.ProviderName = core.StringPtr("testString")
				versionEntitlementModel.ProviderID = core.StringPtr("testString")
				versionEntitlementModel.ProductID = core.StringPtr("testString")
				versionEntitlementModel.PartNumbers = []string{"testString"}
				versionEntitlementModel.ImageRepoName = core.StringPtr("testString")
				Expect(versionEntitlementModel.ProviderName).To(Equal(core.StringPtr("testString")))
				Expect(versionEntitlementModel.ProviderID).To(Equal(core.StringPtr("testString")))
				Expect(versionEntitlementModel.ProductID).To(Equal(core.StringPtr("testString")))
				Expect(versionEntitlementModel.PartNumbers).To(Equal([]string{"testString"}))
				Expect(versionEntitlementModel.ImageRepoName).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the License model
				licenseModel := new(catalogmanagementv1.License)
				Expect(licenseModel).ToNot(BeNil())
				licenseModel.ID = core.StringPtr("testString")
				licenseModel.Name = core.StringPtr("testString")
				licenseModel.Type = core.StringPtr("testString")
				licenseModel.URL = core.StringPtr("testString")
				licenseModel.Description = core.StringPtr("testString")
				Expect(licenseModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(licenseModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(licenseModel.Type).To(Equal(core.StringPtr("testString")))
				Expect(licenseModel.URL).To(Equal(core.StringPtr("testString")))
				Expect(licenseModel.Description).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				Expect(stateModel).ToNot(BeNil())
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")
				Expect(stateModel.Current).To(Equal(core.StringPtr("testString")))
				Expect(stateModel.CurrentEntered).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(stateModel.Pending).To(Equal(core.StringPtr("testString")))
				Expect(stateModel.PendingRequested).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(stateModel.Previous).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the DeprecatePending model
				deprecatePendingModel := new(catalogmanagementv1.DeprecatePending)
				Expect(deprecatePendingModel).ToNot(BeNil())
				deprecatePendingModel.DeprecateDate = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				deprecatePendingModel.DeprecateState = core.StringPtr("testString")
				deprecatePendingModel.Description = core.StringPtr("testString")
				Expect(deprecatePendingModel.DeprecateDate).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(deprecatePendingModel.DeprecateState).To(Equal(core.StringPtr("testString")))
				Expect(deprecatePendingModel.Description).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the URLProxy model
				urlProxyModel := new(catalogmanagementv1.URLProxy)
				Expect(urlProxyModel).ToNot(BeNil())
				urlProxyModel.URL = core.StringPtr("testString")
				urlProxyModel.Sha = core.StringPtr("testString")
				Expect(urlProxyModel.URL).To(Equal(core.StringPtr("testString")))
				Expect(urlProxyModel.Sha).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the MediaItem model
				mediaItemModel := new(catalogmanagementv1.MediaItem)
				Expect(mediaItemModel).ToNot(BeNil())
				mediaItemModel.URL = core.StringPtr("testString")
				mediaItemModel.APIURL = core.StringPtr("testString")
				mediaItemModel.URLProxy = urlProxyModel
				mediaItemModel.Caption = core.StringPtr("testString")
				mediaItemModel.CaptionI18n = make(map[string]string)
				mediaItemModel.Type = core.StringPtr("testString")
				mediaItemModel.ThumbnailURL = core.StringPtr("testString")
				Expect(mediaItemModel.URL).To(Equal(core.StringPtr("testString")))
				Expect(mediaItemModel.APIURL).To(Equal(core.StringPtr("testString")))
				Expect(mediaItemModel.URLProxy).To(Equal(urlProxyModel))
				Expect(mediaItemModel.Caption).To(Equal(core.StringPtr("testString")))
				Expect(mediaItemModel.CaptionI18n).To(Equal(make(map[string]string)))
				Expect(mediaItemModel.Type).To(Equal(core.StringPtr("testString")))
				Expect(mediaItemModel.ThumbnailURL).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the ArchitectureDiagram model
				architectureDiagramModel := new(catalogmanagementv1.ArchitectureDiagram)
				Expect(architectureDiagramModel).ToNot(BeNil())
				architectureDiagramModel.Diagram = mediaItemModel
				architectureDiagramModel.Description = core.StringPtr("testString")
				architectureDiagramModel.DescriptionI18n = make(map[string]string)
				Expect(architectureDiagramModel.Diagram).To(Equal(mediaItemModel))
				Expect(architectureDiagramModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(architectureDiagramModel.DescriptionI18n).To(Equal(make(map[string]string)))

				// Construct an instance of the CostComponent model
				costComponentModel := new(catalogmanagementv1.CostComponent)
				Expect(costComponentModel).ToNot(BeNil())
				costComponentModel.Name = core.StringPtr("testString")
				costComponentModel.Unit = core.StringPtr("testString")
				costComponentModel.HourlyQuantity = core.StringPtr("testString")
				costComponentModel.MonthlyQuantity = core.StringPtr("testString")
				costComponentModel.Price = core.StringPtr("testString")
				costComponentModel.HourlyCost = core.StringPtr("testString")
				costComponentModel.MonthlyCost = core.StringPtr("testString")
				Expect(costComponentModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(costComponentModel.Unit).To(Equal(core.StringPtr("testString")))
				Expect(costComponentModel.HourlyQuantity).To(Equal(core.StringPtr("testString")))
				Expect(costComponentModel.MonthlyQuantity).To(Equal(core.StringPtr("testString")))
				Expect(costComponentModel.Price).To(Equal(core.StringPtr("testString")))
				Expect(costComponentModel.HourlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costComponentModel.MonthlyCost).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the CostResource model
				costResourceModel := new(catalogmanagementv1.CostResource)
				Expect(costResourceModel).ToNot(BeNil())
				costResourceModel.Name = core.StringPtr("testString")
				costResourceModel.Metadata = make(map[string]interface{})
				costResourceModel.HourlyCost = core.StringPtr("testString")
				costResourceModel.MonthlyCost = core.StringPtr("testString")
				costResourceModel.CostComponents = []catalogmanagementv1.CostComponent{*costComponentModel}
				Expect(costResourceModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(costResourceModel.Metadata).To(Equal(make(map[string]interface{})))
				Expect(costResourceModel.HourlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costResourceModel.MonthlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costResourceModel.CostComponents).To(Equal([]catalogmanagementv1.CostComponent{*costComponentModel}))

				// Construct an instance of the CostBreakdown model
				costBreakdownModel := new(catalogmanagementv1.CostBreakdown)
				Expect(costBreakdownModel).ToNot(BeNil())
				costBreakdownModel.TotalHourlyCost = core.StringPtr("testString")
				costBreakdownModel.TotalMonthlyCOst = core.StringPtr("testString")
				costBreakdownModel.Resources = []catalogmanagementv1.CostResource{*costResourceModel}
				Expect(costBreakdownModel.TotalHourlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costBreakdownModel.TotalMonthlyCOst).To(Equal(core.StringPtr("testString")))
				Expect(costBreakdownModel.Resources).To(Equal([]catalogmanagementv1.CostResource{*costResourceModel}))

				// Construct an instance of the CostSummary model
				costSummaryModel := new(catalogmanagementv1.CostSummary)
				Expect(costSummaryModel).ToNot(BeNil())
				costSummaryModel.TotalDetectedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalSupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUnsupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUsageBasedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalNoPriceResources = core.Int64Ptr(int64(38))
				costSummaryModel.UnsupportedResourceCounts = make(map[string]int64)
				costSummaryModel.NoPriceResourceCounts = make(map[string]int64)
				Expect(costSummaryModel.TotalDetectedResources).To(Equal(core.Int64Ptr(int64(38))))
				Expect(costSummaryModel.TotalSupportedResources).To(Equal(core.Int64Ptr(int64(38))))
				Expect(costSummaryModel.TotalUnsupportedResources).To(Equal(core.Int64Ptr(int64(38))))
				Expect(costSummaryModel.TotalUsageBasedResources).To(Equal(core.Int64Ptr(int64(38))))
				Expect(costSummaryModel.TotalNoPriceResources).To(Equal(core.Int64Ptr(int64(38))))
				Expect(costSummaryModel.UnsupportedResourceCounts).To(Equal(make(map[string]int64)))
				Expect(costSummaryModel.NoPriceResourceCounts).To(Equal(make(map[string]int64)))

				// Construct an instance of the Project model
				projectModel := new(catalogmanagementv1.Project)
				Expect(projectModel).ToNot(BeNil())
				projectModel.Name = core.StringPtr("testString")
				projectModel.Metadata = make(map[string]interface{})
				projectModel.PastBreakdown = costBreakdownModel
				projectModel.Breakdown = costBreakdownModel
				projectModel.Diff = costBreakdownModel
				projectModel.Summary = costSummaryModel
				Expect(projectModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(projectModel.Metadata).To(Equal(make(map[string]interface{})))
				Expect(projectModel.PastBreakdown).To(Equal(costBreakdownModel))
				Expect(projectModel.Breakdown).To(Equal(costBreakdownModel))
				Expect(projectModel.Diff).To(Equal(costBreakdownModel))
				Expect(projectModel.Summary).To(Equal(costSummaryModel))

				// Construct an instance of the CostEstimate model
				costEstimateModel := new(catalogmanagementv1.CostEstimate)
				Expect(costEstimateModel).ToNot(BeNil())
				costEstimateModel.Version = core.StringPtr("testString")
				costEstimateModel.Currency = core.StringPtr("testString")
				costEstimateModel.Projects = []catalogmanagementv1.Project{*projectModel}
				costEstimateModel.Summary = costSummaryModel
				costEstimateModel.TotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.TotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.TimeGenerated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				Expect(costEstimateModel.Version).To(Equal(core.StringPtr("testString")))
				Expect(costEstimateModel.Currency).To(Equal(core.StringPtr("testString")))
				Expect(costEstimateModel.Projects).To(Equal([]catalogmanagementv1.Project{*projectModel}))
				Expect(costEstimateModel.Summary).To(Equal(costSummaryModel))
				Expect(costEstimateModel.TotalHourlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costEstimateModel.TotalMonthlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costEstimateModel.PastTotalHourlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costEstimateModel.PastTotalMonthlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costEstimateModel.DiffTotalHourlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costEstimateModel.DiffTotalMonthlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costEstimateModel.TimeGenerated).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))

				// Construct an instance of the Dependency model
				dependencyModel := new(catalogmanagementv1.Dependency)
				Expect(dependencyModel).ToNot(BeNil())
				dependencyModel.CatalogID = core.StringPtr("testString")
				dependencyModel.ID = core.StringPtr("testString")
				dependencyModel.Name = core.StringPtr("testString")
				dependencyModel.Version = core.StringPtr("testString")
				dependencyModel.Flavors = []string{"testString"}
				Expect(dependencyModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(dependencyModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(dependencyModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(dependencyModel.Version).To(Equal(core.StringPtr("testString")))
				Expect(dependencyModel.Flavors).To(Equal([]string{"testString"}))

				// Construct an instance of the SolutionInfo model
				solutionInfoModel := new(catalogmanagementv1.SolutionInfo)
				Expect(solutionInfoModel).ToNot(BeNil())
				solutionInfoModel.ArchitectureDiagrams = []catalogmanagementv1.ArchitectureDiagram{*architectureDiagramModel}
				solutionInfoModel.Features = []catalogmanagementv1.Feature{*featureModel}
				solutionInfoModel.CostEstimate = costEstimateModel
				solutionInfoModel.Dependencies = []catalogmanagementv1.Dependency{*dependencyModel}
				Expect(solutionInfoModel.ArchitectureDiagrams).To(Equal([]catalogmanagementv1.ArchitectureDiagram{*architectureDiagramModel}))
				Expect(solutionInfoModel.Features).To(Equal([]catalogmanagementv1.Feature{*featureModel}))
				Expect(solutionInfoModel.CostEstimate).To(Equal(costEstimateModel))
				Expect(solutionInfoModel.Dependencies).To(Equal([]catalogmanagementv1.Dependency{*dependencyModel}))

				// Construct an instance of the Version model
				versionModel := new(catalogmanagementv1.Version)
				Expect(versionModel).ToNot(BeNil())
				versionModel.ID = core.StringPtr("testString")
				versionModel.Rev = core.StringPtr("testString")
				versionModel.CRN = core.StringPtr("testString")
				versionModel.Version = core.StringPtr("testString")
				versionModel.Flavor = flavorModel
				versionModel.Sha = core.StringPtr("testString")
				versionModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.OfferingID = core.StringPtr("testString")
				versionModel.CatalogID = core.StringPtr("testString")
				versionModel.KindID = core.StringPtr("testString")
				versionModel.Tags = []string{"testString"}
				versionModel.RepoURL = core.StringPtr("testString")
				versionModel.SourceURL = core.StringPtr("testString")
				versionModel.TgzURL = core.StringPtr("testString")
				versionModel.Configuration = []catalogmanagementv1.Configuration{*configurationModel}
				versionModel.Outputs = []catalogmanagementv1.Output{*outputModel}
				versionModel.IamPermissions = []catalogmanagementv1.IamPermission{*iamPermissionModel}
				versionModel.Metadata = make(map[string]interface{})
				versionModel.Validation = validationModel
				versionModel.RequiredResources = []catalogmanagementv1.Resource{*resourceModel}
				versionModel.SingleInstance = core.BoolPtr(true)
				versionModel.Install = scriptModel
				versionModel.PreInstall = []catalogmanagementv1.Script{*scriptModel}
				versionModel.Entitlement = versionEntitlementModel
				versionModel.Licenses = []catalogmanagementv1.License{*licenseModel}
				versionModel.ImageManifestURL = core.StringPtr("testString")
				versionModel.Deprecated = core.BoolPtr(true)
				versionModel.PackageVersion = core.StringPtr("testString")
				versionModel.State = stateModel
				versionModel.VersionLocator = core.StringPtr("testString")
				versionModel.LongDescription = core.StringPtr("testString")
				versionModel.LongDescriptionI18n = make(map[string]string)
				versionModel.WhitelistedAccounts = []string{"testString"}
				versionModel.ImagePullKeyName = core.StringPtr("testString")
				versionModel.DeprecatePending = deprecatePendingModel
				versionModel.SolutionInfo = solutionInfoModel
				versionModel.IsConsumable = core.BoolPtr(true)
				Expect(versionModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.Rev).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.CRN).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.Version).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.Flavor).To(Equal(flavorModel))
				Expect(versionModel.Sha).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.Created).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(versionModel.Updated).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(versionModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.KindID).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.Tags).To(Equal([]string{"testString"}))
				Expect(versionModel.RepoURL).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.SourceURL).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.TgzURL).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.Configuration).To(Equal([]catalogmanagementv1.Configuration{*configurationModel}))
				Expect(versionModel.Outputs).To(Equal([]catalogmanagementv1.Output{*outputModel}))
				Expect(versionModel.IamPermissions).To(Equal([]catalogmanagementv1.IamPermission{*iamPermissionModel}))
				Expect(versionModel.Metadata).To(Equal(make(map[string]interface{})))
				Expect(versionModel.Validation).To(Equal(validationModel))
				Expect(versionModel.RequiredResources).To(Equal([]catalogmanagementv1.Resource{*resourceModel}))
				Expect(versionModel.SingleInstance).To(Equal(core.BoolPtr(true)))
				Expect(versionModel.Install).To(Equal(scriptModel))
				Expect(versionModel.PreInstall).To(Equal([]catalogmanagementv1.Script{*scriptModel}))
				Expect(versionModel.Entitlement).To(Equal(versionEntitlementModel))
				Expect(versionModel.Licenses).To(Equal([]catalogmanagementv1.License{*licenseModel}))
				Expect(versionModel.ImageManifestURL).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.Deprecated).To(Equal(core.BoolPtr(true)))
				Expect(versionModel.PackageVersion).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.State).To(Equal(stateModel))
				Expect(versionModel.VersionLocator).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.LongDescription).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.LongDescriptionI18n).To(Equal(make(map[string]string)))
				Expect(versionModel.WhitelistedAccounts).To(Equal([]string{"testString"}))
				Expect(versionModel.ImagePullKeyName).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.DeprecatePending).To(Equal(deprecatePendingModel))
				Expect(versionModel.SolutionInfo).To(Equal(solutionInfoModel))
				Expect(versionModel.IsConsumable).To(Equal(core.BoolPtr(true)))

				// Construct an instance of the Deployment model
				deploymentModel := new(catalogmanagementv1.Deployment)
				Expect(deploymentModel).ToNot(BeNil())
				deploymentModel.ID = core.StringPtr("testString")
				deploymentModel.Label = core.StringPtr("testString")
				deploymentModel.Name = core.StringPtr("testString")
				deploymentModel.ShortDescription = core.StringPtr("testString")
				deploymentModel.LongDescription = core.StringPtr("testString")
				deploymentModel.Metadata = make(map[string]interface{})
				deploymentModel.Tags = []string{"testString"}
				deploymentModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				deploymentModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				Expect(deploymentModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(deploymentModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(deploymentModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(deploymentModel.ShortDescription).To(Equal(core.StringPtr("testString")))
				Expect(deploymentModel.LongDescription).To(Equal(core.StringPtr("testString")))
				Expect(deploymentModel.Metadata).To(Equal(make(map[string]interface{})))
				Expect(deploymentModel.Tags).To(Equal([]string{"testString"}))
				Expect(deploymentModel.Created).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(deploymentModel.Updated).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))

				// Construct an instance of the Plan model
				planModel := new(catalogmanagementv1.Plan)
				Expect(planModel).ToNot(BeNil())
				planModel.ID = core.StringPtr("testString")
				planModel.Label = core.StringPtr("testString")
				planModel.Name = core.StringPtr("testString")
				planModel.ShortDescription = core.StringPtr("testString")
				planModel.LongDescription = core.StringPtr("testString")
				planModel.Metadata = make(map[string]interface{})
				planModel.Tags = []string{"testString"}
				planModel.AdditionalFeatures = []catalogmanagementv1.Feature{*featureModel}
				planModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.Deployments = []catalogmanagementv1.Deployment{*deploymentModel}
				Expect(planModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(planModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(planModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(planModel.ShortDescription).To(Equal(core.StringPtr("testString")))
				Expect(planModel.LongDescription).To(Equal(core.StringPtr("testString")))
				Expect(planModel.Metadata).To(Equal(make(map[string]interface{})))
				Expect(planModel.Tags).To(Equal([]string{"testString"}))
				Expect(planModel.AdditionalFeatures).To(Equal([]catalogmanagementv1.Feature{*featureModel}))
				Expect(planModel.Created).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(planModel.Updated).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(planModel.Deployments).To(Equal([]catalogmanagementv1.Deployment{*deploymentModel}))

				// Construct an instance of the Kind model
				kindModel := new(catalogmanagementv1.Kind)
				Expect(kindModel).ToNot(BeNil())
				kindModel.ID = core.StringPtr("testString")
				kindModel.FormatKind = core.StringPtr("testString")
				kindModel.InstallKind = core.StringPtr("testString")
				kindModel.TargetKind = core.StringPtr("testString")
				kindModel.Metadata = make(map[string]interface{})
				kindModel.Tags = []string{"testString"}
				kindModel.AdditionalFeatures = []catalogmanagementv1.Feature{*featureModel}
				kindModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Versions = []catalogmanagementv1.Version{*versionModel}
				kindModel.Plans = []catalogmanagementv1.Plan{*planModel}
				Expect(kindModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(kindModel.FormatKind).To(Equal(core.StringPtr("testString")))
				Expect(kindModel.InstallKind).To(Equal(core.StringPtr("testString")))
				Expect(kindModel.TargetKind).To(Equal(core.StringPtr("testString")))
				Expect(kindModel.Metadata).To(Equal(make(map[string]interface{})))
				Expect(kindModel.Tags).To(Equal([]string{"testString"}))
				Expect(kindModel.AdditionalFeatures).To(Equal([]catalogmanagementv1.Feature{*featureModel}))
				Expect(kindModel.Created).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(kindModel.Updated).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(kindModel.Versions).To(Equal([]catalogmanagementv1.Version{*versionModel}))
				Expect(kindModel.Plans).To(Equal([]catalogmanagementv1.Plan{*planModel}))

				// Construct an instance of the ProviderInfo model
				providerInfoModel := new(catalogmanagementv1.ProviderInfo)
				Expect(providerInfoModel).ToNot(BeNil())
				providerInfoModel.ID = core.StringPtr("testString")
				providerInfoModel.Name = core.StringPtr("testString")
				Expect(providerInfoModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(providerInfoModel.Name).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the RepoInfo model
				repoInfoModel := new(catalogmanagementv1.RepoInfo)
				Expect(repoInfoModel).ToNot(BeNil())
				repoInfoModel.Token = core.StringPtr("testString")
				repoInfoModel.Type = core.StringPtr("testString")
				Expect(repoInfoModel.Token).To(Equal(core.StringPtr("testString")))
				Expect(repoInfoModel.Type).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the ImagePullKey model
				imagePullKeyModel := new(catalogmanagementv1.ImagePullKey)
				Expect(imagePullKeyModel).ToNot(BeNil())
				imagePullKeyModel.Name = core.StringPtr("testString")
				imagePullKeyModel.Value = core.StringPtr("testString")
				imagePullKeyModel.Description = core.StringPtr("testString")
				Expect(imagePullKeyModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(imagePullKeyModel.Value).To(Equal(core.StringPtr("testString")))
				Expect(imagePullKeyModel.Description).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the SupportWaitTime model
				supportWaitTimeModel := new(catalogmanagementv1.SupportWaitTime)
				Expect(supportWaitTimeModel).ToNot(BeNil())
				supportWaitTimeModel.Value = core.Int64Ptr(int64(38))
				supportWaitTimeModel.Type = core.StringPtr("testString")
				Expect(supportWaitTimeModel.Value).To(Equal(core.Int64Ptr(int64(38))))
				Expect(supportWaitTimeModel.Type).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the SupportTime model
				supportTimeModel := new(catalogmanagementv1.SupportTime)
				Expect(supportTimeModel).ToNot(BeNil())
				supportTimeModel.Day = core.Int64Ptr(int64(38))
				supportTimeModel.StartTime = core.StringPtr("testString")
				supportTimeModel.EndTime = core.StringPtr("testString")
				Expect(supportTimeModel.Day).To(Equal(core.Int64Ptr(int64(38))))
				Expect(supportTimeModel.StartTime).To(Equal(core.StringPtr("testString")))
				Expect(supportTimeModel.EndTime).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the SupportAvailability model
				supportAvailabilityModel := new(catalogmanagementv1.SupportAvailability)
				Expect(supportAvailabilityModel).ToNot(BeNil())
				supportAvailabilityModel.Times = []catalogmanagementv1.SupportTime{*supportTimeModel}
				supportAvailabilityModel.Timezone = core.StringPtr("testString")
				supportAvailabilityModel.AlwaysAvailable = core.BoolPtr(true)
				Expect(supportAvailabilityModel.Times).To(Equal([]catalogmanagementv1.SupportTime{*supportTimeModel}))
				Expect(supportAvailabilityModel.Timezone).To(Equal(core.StringPtr("testString")))
				Expect(supportAvailabilityModel.AlwaysAvailable).To(Equal(core.BoolPtr(true)))

				// Construct an instance of the SupportDetail model
				supportDetailModel := new(catalogmanagementv1.SupportDetail)
				Expect(supportDetailModel).ToNot(BeNil())
				supportDetailModel.Type = core.StringPtr("testString")
				supportDetailModel.Contact = core.StringPtr("testString")
				supportDetailModel.ResponseWaitTime = supportWaitTimeModel
				supportDetailModel.Availability = supportAvailabilityModel
				Expect(supportDetailModel.Type).To(Equal(core.StringPtr("testString")))
				Expect(supportDetailModel.Contact).To(Equal(core.StringPtr("testString")))
				Expect(supportDetailModel.ResponseWaitTime).To(Equal(supportWaitTimeModel))
				Expect(supportDetailModel.Availability).To(Equal(supportAvailabilityModel))

				// Construct an instance of the SupportEscalation model
				supportEscalationModel := new(catalogmanagementv1.SupportEscalation)
				Expect(supportEscalationModel).ToNot(BeNil())
				supportEscalationModel.EscalationWaitTime = supportWaitTimeModel
				supportEscalationModel.ResponseWaitTime = supportWaitTimeModel
				supportEscalationModel.Contact = core.StringPtr("testString")
				Expect(supportEscalationModel.EscalationWaitTime).To(Equal(supportWaitTimeModel))
				Expect(supportEscalationModel.ResponseWaitTime).To(Equal(supportWaitTimeModel))
				Expect(supportEscalationModel.Contact).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the Support model
				supportModel := new(catalogmanagementv1.Support)
				Expect(supportModel).ToNot(BeNil())
				supportModel.URL = core.StringPtr("testString")
				supportModel.Process = core.StringPtr("testString")
				supportModel.ProcessI18n = make(map[string]string)
				supportModel.Locations = []string{"testString"}
				supportModel.SupportDetails = []catalogmanagementv1.SupportDetail{*supportDetailModel}
				supportModel.SupportEscalation = supportEscalationModel
				supportModel.SupportType = core.StringPtr("testString")
				Expect(supportModel.URL).To(Equal(core.StringPtr("testString")))
				Expect(supportModel.Process).To(Equal(core.StringPtr("testString")))
				Expect(supportModel.ProcessI18n).To(Equal(make(map[string]string)))
				Expect(supportModel.Locations).To(Equal([]string{"testString"}))
				Expect(supportModel.SupportDetails).To(Equal([]catalogmanagementv1.SupportDetail{*supportDetailModel}))
				Expect(supportModel.SupportEscalation).To(Equal(supportEscalationModel))
				Expect(supportModel.SupportType).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the LearnMoreLinks model
				learnMoreLinksModel := new(catalogmanagementv1.LearnMoreLinks)
				Expect(learnMoreLinksModel).ToNot(BeNil())
				learnMoreLinksModel.FirstParty = core.StringPtr("testString")
				learnMoreLinksModel.ThirdParty = core.StringPtr("testString")
				Expect(learnMoreLinksModel.FirstParty).To(Equal(core.StringPtr("testString")))
				Expect(learnMoreLinksModel.ThirdParty).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the Constraint model
				constraintModel := new(catalogmanagementv1.Constraint)
				Expect(constraintModel).ToNot(BeNil())
				constraintModel.Type = core.StringPtr("testString")
				constraintModel.Rule = core.StringPtr("testString")
				Expect(constraintModel.Type).To(Equal(core.StringPtr("testString")))
				Expect(constraintModel.Rule).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the Badge model
				badgeModel := new(catalogmanagementv1.Badge)
				Expect(badgeModel).ToNot(BeNil())
				badgeModel.ID = core.StringPtr("testString")
				badgeModel.Label = core.StringPtr("testString")
				badgeModel.LabelI18n = make(map[string]string)
				badgeModel.Description = core.StringPtr("testString")
				badgeModel.DescriptionI18n = make(map[string]string)
				badgeModel.Icon = core.StringPtr("testString")
				badgeModel.Authority = core.StringPtr("testString")
				badgeModel.Tag = core.StringPtr("testString")
				badgeModel.LearnMoreLinks = learnMoreLinksModel
				badgeModel.Constraints = []catalogmanagementv1.Constraint{*constraintModel}
				Expect(badgeModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(badgeModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(badgeModel.LabelI18n).To(Equal(make(map[string]string)))
				Expect(badgeModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(badgeModel.DescriptionI18n).To(Equal(make(map[string]string)))
				Expect(badgeModel.Icon).To(Equal(core.StringPtr("testString")))
				Expect(badgeModel.Authority).To(Equal(core.StringPtr("testString")))
				Expect(badgeModel.Tag).To(Equal(core.StringPtr("testString")))
				Expect(badgeModel.LearnMoreLinks).To(Equal(learnMoreLinksModel))
				Expect(badgeModel.Constraints).To(Equal([]catalogmanagementv1.Constraint{*constraintModel}))

				// Construct an instance of the CreateOfferingOptions model
				catalogIdentifier := "testString"
				createOfferingOptionsModel := catalogManagementService.NewCreateOfferingOptions(catalogIdentifier)
				createOfferingOptionsModel.SetCatalogIdentifier("testString")
				createOfferingOptionsModel.SetID("testString")
				createOfferingOptionsModel.SetRev("testString")
				createOfferingOptionsModel.SetURL("testString")
				createOfferingOptionsModel.SetCRN("testString")
				createOfferingOptionsModel.SetLabel("testString")
				createOfferingOptionsModel.SetLabelI18n(make(map[string]string))
				createOfferingOptionsModel.SetName("testString")
				createOfferingOptionsModel.SetOfferingIconURL("testString")
				createOfferingOptionsModel.SetOfferingDocsURL("testString")
				createOfferingOptionsModel.SetOfferingSupportURL("testString")
				createOfferingOptionsModel.SetTags([]string{"testString"})
				createOfferingOptionsModel.SetKeywords([]string{"testString"})
				createOfferingOptionsModel.SetRating(ratingModel)
				createOfferingOptionsModel.SetCreated(CreateMockDateTime("2019-01-01T12:00:00.000Z"))
				createOfferingOptionsModel.SetUpdated(CreateMockDateTime("2019-01-01T12:00:00.000Z"))
				createOfferingOptionsModel.SetShortDescription("testString")
				createOfferingOptionsModel.SetShortDescriptionI18n(make(map[string]string))
				createOfferingOptionsModel.SetLongDescription("testString")
				createOfferingOptionsModel.SetLongDescriptionI18n(make(map[string]string))
				createOfferingOptionsModel.SetFeatures([]catalogmanagementv1.Feature{*featureModel})
				createOfferingOptionsModel.SetKinds([]catalogmanagementv1.Kind{*kindModel})
				createOfferingOptionsModel.SetPcManaged(true)
				createOfferingOptionsModel.SetPublishApproved(true)
				createOfferingOptionsModel.SetShareWithAll(true)
				createOfferingOptionsModel.SetShareWithIBM(true)
				createOfferingOptionsModel.SetShareEnabled(true)
				createOfferingOptionsModel.SetPermitRequestIBMPublicPublish(true)
				createOfferingOptionsModel.SetIBMPublishApproved(true)
				createOfferingOptionsModel.SetPublicPublishApproved(true)
				createOfferingOptionsModel.SetPublicOriginalCRN("testString")
				createOfferingOptionsModel.SetPublishPublicCRN("testString")
				createOfferingOptionsModel.SetPortalApprovalRecord("testString")
				createOfferingOptionsModel.SetPortalUIURL("testString")
				createOfferingOptionsModel.SetCatalogID("testString")
				createOfferingOptionsModel.SetCatalogName("testString")
				createOfferingOptionsModel.SetMetadata(make(map[string]interface{}))
				createOfferingOptionsModel.SetDisclaimer("testString")
				createOfferingOptionsModel.SetHidden(true)
				createOfferingOptionsModel.SetProvider("testString")
				createOfferingOptionsModel.SetProviderInfo(providerInfoModel)
				createOfferingOptionsModel.SetRepoInfo(repoInfoModel)
				createOfferingOptionsModel.SetImagePullKeys([]catalogmanagementv1.ImagePullKey{*imagePullKeyModel})
				createOfferingOptionsModel.SetSupport(supportModel)
				createOfferingOptionsModel.SetMedia([]catalogmanagementv1.MediaItem{*mediaItemModel})
				createOfferingOptionsModel.SetDeprecatePending(deprecatePendingModel)
				createOfferingOptionsModel.SetProductKind("testString")
				createOfferingOptionsModel.SetBadges([]catalogmanagementv1.Badge{*badgeModel})
				createOfferingOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createOfferingOptionsModel).ToNot(BeNil())
				Expect(createOfferingOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingOptionsModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingOptionsModel.Rev).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingOptionsModel.URL).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingOptionsModel.CRN).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingOptionsModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingOptionsModel.LabelI18n).To(Equal(make(map[string]string)))
				Expect(createOfferingOptionsModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingOptionsModel.OfferingIconURL).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingOptionsModel.OfferingDocsURL).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingOptionsModel.OfferingSupportURL).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingOptionsModel.Tags).To(Equal([]string{"testString"}))
				Expect(createOfferingOptionsModel.Keywords).To(Equal([]string{"testString"}))
				Expect(createOfferingOptionsModel.Rating).To(Equal(ratingModel))
				Expect(createOfferingOptionsModel.Created).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(createOfferingOptionsModel.Updated).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(createOfferingOptionsModel.ShortDescription).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingOptionsModel.ShortDescriptionI18n).To(Equal(make(map[string]string)))
				Expect(createOfferingOptionsModel.LongDescription).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingOptionsModel.LongDescriptionI18n).To(Equal(make(map[string]string)))
				Expect(createOfferingOptionsModel.Features).To(Equal([]catalogmanagementv1.Feature{*featureModel}))
				Expect(createOfferingOptionsModel.Kinds).To(Equal([]catalogmanagementv1.Kind{*kindModel}))
				Expect(createOfferingOptionsModel.PcManaged).To(Equal(core.BoolPtr(true)))
				Expect(createOfferingOptionsModel.PublishApproved).To(Equal(core.BoolPtr(true)))
				Expect(createOfferingOptionsModel.ShareWithAll).To(Equal(core.BoolPtr(true)))
				Expect(createOfferingOptionsModel.ShareWithIBM).To(Equal(core.BoolPtr(true)))
				Expect(createOfferingOptionsModel.ShareEnabled).To(Equal(core.BoolPtr(true)))
				Expect(createOfferingOptionsModel.PermitRequestIBMPublicPublish).To(Equal(core.BoolPtr(true)))
				Expect(createOfferingOptionsModel.IBMPublishApproved).To(Equal(core.BoolPtr(true)))
				Expect(createOfferingOptionsModel.PublicPublishApproved).To(Equal(core.BoolPtr(true)))
				Expect(createOfferingOptionsModel.PublicOriginalCRN).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingOptionsModel.PublishPublicCRN).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingOptionsModel.PortalApprovalRecord).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingOptionsModel.PortalUIURL).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingOptionsModel.CatalogName).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingOptionsModel.Metadata).To(Equal(make(map[string]interface{})))
				Expect(createOfferingOptionsModel.Disclaimer).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingOptionsModel.Hidden).To(Equal(core.BoolPtr(true)))
				Expect(createOfferingOptionsModel.Provider).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingOptionsModel.ProviderInfo).To(Equal(providerInfoModel))
				Expect(createOfferingOptionsModel.RepoInfo).To(Equal(repoInfoModel))
				Expect(createOfferingOptionsModel.ImagePullKeys).To(Equal([]catalogmanagementv1.ImagePullKey{*imagePullKeyModel}))
				Expect(createOfferingOptionsModel.Support).To(Equal(supportModel))
				Expect(createOfferingOptionsModel.Media).To(Equal([]catalogmanagementv1.MediaItem{*mediaItemModel}))
				Expect(createOfferingOptionsModel.DeprecatePending).To(Equal(deprecatePendingModel))
				Expect(createOfferingOptionsModel.ProductKind).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingOptionsModel.Badges).To(Equal([]catalogmanagementv1.Badge{*badgeModel}))
				Expect(createOfferingOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteCatalogOptions successfully`, func() {
				// Construct an instance of the DeleteCatalogOptions model
				catalogIdentifier := "testString"
				deleteCatalogOptionsModel := catalogManagementService.NewDeleteCatalogOptions(catalogIdentifier)
				deleteCatalogOptionsModel.SetCatalogIdentifier("testString")
				deleteCatalogOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteCatalogOptionsModel).ToNot(BeNil())
				Expect(deleteCatalogOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(deleteCatalogOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteObjectAccessListOptions successfully`, func() {
				// Construct an instance of the DeleteObjectAccessListOptions model
				catalogIdentifier := "testString"
				objectIdentifier := "testString"
				accesses := []string{"testString"}
				deleteObjectAccessListOptionsModel := catalogManagementService.NewDeleteObjectAccessListOptions(catalogIdentifier, objectIdentifier, accesses)
				deleteObjectAccessListOptionsModel.SetCatalogIdentifier("testString")
				deleteObjectAccessListOptionsModel.SetObjectIdentifier("testString")
				deleteObjectAccessListOptionsModel.SetAccesses([]string{"testString"})
				deleteObjectAccessListOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteObjectAccessListOptionsModel).ToNot(BeNil())
				Expect(deleteObjectAccessListOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(deleteObjectAccessListOptionsModel.ObjectIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(deleteObjectAccessListOptionsModel.Accesses).To(Equal([]string{"testString"}))
				Expect(deleteObjectAccessListOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteObjectAccessOptions successfully`, func() {
				// Construct an instance of the DeleteObjectAccessOptions model
				catalogIdentifier := "testString"
				objectIdentifier := "testString"
				accessIdentifier := "testString"
				deleteObjectAccessOptionsModel := catalogManagementService.NewDeleteObjectAccessOptions(catalogIdentifier, objectIdentifier, accessIdentifier)
				deleteObjectAccessOptionsModel.SetCatalogIdentifier("testString")
				deleteObjectAccessOptionsModel.SetObjectIdentifier("testString")
				deleteObjectAccessOptionsModel.SetAccessIdentifier("testString")
				deleteObjectAccessOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteObjectAccessOptionsModel).ToNot(BeNil())
				Expect(deleteObjectAccessOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(deleteObjectAccessOptionsModel.ObjectIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(deleteObjectAccessOptionsModel.AccessIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(deleteObjectAccessOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteObjectOptions successfully`, func() {
				// Construct an instance of the DeleteObjectOptions model
				catalogIdentifier := "testString"
				objectIdentifier := "testString"
				deleteObjectOptionsModel := catalogManagementService.NewDeleteObjectOptions(catalogIdentifier, objectIdentifier)
				deleteObjectOptionsModel.SetCatalogIdentifier("testString")
				deleteObjectOptionsModel.SetObjectIdentifier("testString")
				deleteObjectOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteObjectOptionsModel).ToNot(BeNil())
				Expect(deleteObjectOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(deleteObjectOptionsModel.ObjectIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(deleteObjectOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteOfferingAccessListOptions successfully`, func() {
				// Construct an instance of the DeleteOfferingAccessListOptions model
				catalogIdentifier := "testString"
				offeringID := "testString"
				accesses := []string{"testString"}
				deleteOfferingAccessListOptionsModel := catalogManagementService.NewDeleteOfferingAccessListOptions(catalogIdentifier, offeringID, accesses)
				deleteOfferingAccessListOptionsModel.SetCatalogIdentifier("testString")
				deleteOfferingAccessListOptionsModel.SetOfferingID("testString")
				deleteOfferingAccessListOptionsModel.SetAccesses([]string{"testString"})
				deleteOfferingAccessListOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteOfferingAccessListOptionsModel).ToNot(BeNil())
				Expect(deleteOfferingAccessListOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(deleteOfferingAccessListOptionsModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(deleteOfferingAccessListOptionsModel.Accesses).To(Equal([]string{"testString"}))
				Expect(deleteOfferingAccessListOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteOfferingInstanceOptions successfully`, func() {
				// Construct an instance of the DeleteOfferingInstanceOptions model
				instanceIdentifier := "testString"
				xAuthRefreshToken := "testString"
				deleteOfferingInstanceOptionsModel := catalogManagementService.NewDeleteOfferingInstanceOptions(instanceIdentifier, xAuthRefreshToken)
				deleteOfferingInstanceOptionsModel.SetInstanceIdentifier("testString")
				deleteOfferingInstanceOptionsModel.SetXAuthRefreshToken("testString")
				deleteOfferingInstanceOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteOfferingInstanceOptionsModel).ToNot(BeNil())
				Expect(deleteOfferingInstanceOptionsModel.InstanceIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(deleteOfferingInstanceOptionsModel.XAuthRefreshToken).To(Equal(core.StringPtr("testString")))
				Expect(deleteOfferingInstanceOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteOfferingOptions successfully`, func() {
				// Construct an instance of the DeleteOfferingOptions model
				catalogIdentifier := "testString"
				offeringID := "testString"
				deleteOfferingOptionsModel := catalogManagementService.NewDeleteOfferingOptions(catalogIdentifier, offeringID)
				deleteOfferingOptionsModel.SetCatalogIdentifier("testString")
				deleteOfferingOptionsModel.SetOfferingID("testString")
				deleteOfferingOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteOfferingOptionsModel).ToNot(BeNil())
				Expect(deleteOfferingOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(deleteOfferingOptionsModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(deleteOfferingOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteOperatorsOptions successfully`, func() {
				// Construct an instance of the DeleteOperatorsOptions model
				xAuthRefreshToken := "testString"
				clusterID := "testString"
				region := "testString"
				versionLocatorID := "testString"
				deleteOperatorsOptionsModel := catalogManagementService.NewDeleteOperatorsOptions(xAuthRefreshToken, clusterID, region, versionLocatorID)
				deleteOperatorsOptionsModel.SetXAuthRefreshToken("testString")
				deleteOperatorsOptionsModel.SetClusterID("testString")
				deleteOperatorsOptionsModel.SetRegion("testString")
				deleteOperatorsOptionsModel.SetVersionLocatorID("testString")
				deleteOperatorsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteOperatorsOptionsModel).ToNot(BeNil())
				Expect(deleteOperatorsOptionsModel.XAuthRefreshToken).To(Equal(core.StringPtr("testString")))
				Expect(deleteOperatorsOptionsModel.ClusterID).To(Equal(core.StringPtr("testString")))
				Expect(deleteOperatorsOptionsModel.Region).To(Equal(core.StringPtr("testString")))
				Expect(deleteOperatorsOptionsModel.VersionLocatorID).To(Equal(core.StringPtr("testString")))
				Expect(deleteOperatorsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteVersionOptions successfully`, func() {
				// Construct an instance of the DeleteVersionOptions model
				versionLocID := "testString"
				deleteVersionOptionsModel := catalogManagementService.NewDeleteVersionOptions(versionLocID)
				deleteVersionOptionsModel.SetVersionLocID("testString")
				deleteVersionOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteVersionOptionsModel).ToNot(BeNil())
				Expect(deleteVersionOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(deleteVersionOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeployOperatorsOptions successfully`, func() {
				// Construct an instance of the DeployOperatorsOptions model
				xAuthRefreshToken := "testString"
				deployOperatorsOptionsModel := catalogManagementService.NewDeployOperatorsOptions(xAuthRefreshToken)
				deployOperatorsOptionsModel.SetXAuthRefreshToken("testString")
				deployOperatorsOptionsModel.SetClusterID("testString")
				deployOperatorsOptionsModel.SetRegion("testString")
				deployOperatorsOptionsModel.SetNamespaces([]string{"testString"})
				deployOperatorsOptionsModel.SetAllNamespaces(true)
				deployOperatorsOptionsModel.SetVersionLocatorID("testString")
				deployOperatorsOptionsModel.SetChannel("testString")
				deployOperatorsOptionsModel.SetInstallPlan("testString")
				deployOperatorsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deployOperatorsOptionsModel).ToNot(BeNil())
				Expect(deployOperatorsOptionsModel.XAuthRefreshToken).To(Equal(core.StringPtr("testString")))
				Expect(deployOperatorsOptionsModel.ClusterID).To(Equal(core.StringPtr("testString")))
				Expect(deployOperatorsOptionsModel.Region).To(Equal(core.StringPtr("testString")))
				Expect(deployOperatorsOptionsModel.Namespaces).To(Equal([]string{"testString"}))
				Expect(deployOperatorsOptionsModel.AllNamespaces).To(Equal(core.BoolPtr(true)))
				Expect(deployOperatorsOptionsModel.VersionLocatorID).To(Equal(core.StringPtr("testString")))
				Expect(deployOperatorsOptionsModel.Channel).To(Equal(core.StringPtr("testString")))
				Expect(deployOperatorsOptionsModel.InstallPlan).To(Equal(core.StringPtr("testString")))
				Expect(deployOperatorsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeprecateOfferingOptions successfully`, func() {
				// Construct an instance of the DeprecateOfferingOptions model
				catalogIdentifier := "testString"
				offeringID := "testString"
				setting := "true"
				deprecateOfferingOptionsModel := catalogManagementService.NewDeprecateOfferingOptions(catalogIdentifier, offeringID, setting)
				deprecateOfferingOptionsModel.SetCatalogIdentifier("testString")
				deprecateOfferingOptionsModel.SetOfferingID("testString")
				deprecateOfferingOptionsModel.SetSetting("true")
				deprecateOfferingOptionsModel.SetDescription("testString")
				deprecateOfferingOptionsModel.SetDaysUntilDeprecate(int64(38))
				deprecateOfferingOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deprecateOfferingOptionsModel).ToNot(BeNil())
				Expect(deprecateOfferingOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(deprecateOfferingOptionsModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(deprecateOfferingOptionsModel.Setting).To(Equal(core.StringPtr("true")))
				Expect(deprecateOfferingOptionsModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(deprecateOfferingOptionsModel.DaysUntilDeprecate).To(Equal(core.Int64Ptr(int64(38))))
				Expect(deprecateOfferingOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeprecateVersionOptions successfully`, func() {
				// Construct an instance of the DeprecateVersionOptions model
				versionLocID := "testString"
				deprecateVersionOptionsModel := catalogManagementService.NewDeprecateVersionOptions(versionLocID)
				deprecateVersionOptionsModel.SetVersionLocID("testString")
				deprecateVersionOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deprecateVersionOptionsModel).ToNot(BeNil())
				Expect(deprecateVersionOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(deprecateVersionOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetCatalogAccountAuditOptions successfully`, func() {
				// Construct an instance of the GetCatalogAccountAuditOptions model
				auditlogIdentifier := "testString"
				getCatalogAccountAuditOptionsModel := catalogManagementService.NewGetCatalogAccountAuditOptions(auditlogIdentifier)
				getCatalogAccountAuditOptionsModel.SetAuditlogIdentifier("testString")
				getCatalogAccountAuditOptionsModel.SetLookupnames(true)
				getCatalogAccountAuditOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getCatalogAccountAuditOptionsModel).ToNot(BeNil())
				Expect(getCatalogAccountAuditOptionsModel.AuditlogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getCatalogAccountAuditOptionsModel.Lookupnames).To(Equal(core.BoolPtr(true)))
				Expect(getCatalogAccountAuditOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetCatalogAccountFiltersOptions successfully`, func() {
				// Construct an instance of the GetCatalogAccountFiltersOptions model
				getCatalogAccountFiltersOptionsModel := catalogManagementService.NewGetCatalogAccountFiltersOptions()
				getCatalogAccountFiltersOptionsModel.SetCatalog("testString")
				getCatalogAccountFiltersOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getCatalogAccountFiltersOptionsModel).ToNot(BeNil())
				Expect(getCatalogAccountFiltersOptionsModel.Catalog).To(Equal(core.StringPtr("testString")))
				Expect(getCatalogAccountFiltersOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetCatalogAccountOptions successfully`, func() {
				// Construct an instance of the GetCatalogAccountOptions model
				getCatalogAccountOptionsModel := catalogManagementService.NewGetCatalogAccountOptions()
				getCatalogAccountOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getCatalogAccountOptionsModel).ToNot(BeNil())
				Expect(getCatalogAccountOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetCatalogAuditOptions successfully`, func() {
				// Construct an instance of the GetCatalogAuditOptions model
				catalogIdentifier := "testString"
				auditlogIdentifier := "testString"
				getCatalogAuditOptionsModel := catalogManagementService.NewGetCatalogAuditOptions(catalogIdentifier, auditlogIdentifier)
				getCatalogAuditOptionsModel.SetCatalogIdentifier("testString")
				getCatalogAuditOptionsModel.SetAuditlogIdentifier("testString")
				getCatalogAuditOptionsModel.SetLookupnames(true)
				getCatalogAuditOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getCatalogAuditOptionsModel).ToNot(BeNil())
				Expect(getCatalogAuditOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getCatalogAuditOptionsModel.AuditlogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getCatalogAuditOptionsModel.Lookupnames).To(Equal(core.BoolPtr(true)))
				Expect(getCatalogAuditOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetCatalogOptions successfully`, func() {
				// Construct an instance of the GetCatalogOptions model
				catalogIdentifier := "testString"
				getCatalogOptionsModel := catalogManagementService.NewGetCatalogOptions(catalogIdentifier)
				getCatalogOptionsModel.SetCatalogIdentifier("testString")
				getCatalogOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getCatalogOptionsModel).ToNot(BeNil())
				Expect(getCatalogOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getCatalogOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetClusterOptions successfully`, func() {
				// Construct an instance of the GetClusterOptions model
				clusterID := "testString"
				region := "testString"
				xAuthRefreshToken := "testString"
				getClusterOptionsModel := catalogManagementService.NewGetClusterOptions(clusterID, region, xAuthRefreshToken)
				getClusterOptionsModel.SetClusterID("testString")
				getClusterOptionsModel.SetRegion("testString")
				getClusterOptionsModel.SetXAuthRefreshToken("testString")
				getClusterOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getClusterOptionsModel).ToNot(BeNil())
				Expect(getClusterOptionsModel.ClusterID).To(Equal(core.StringPtr("testString")))
				Expect(getClusterOptionsModel.Region).To(Equal(core.StringPtr("testString")))
				Expect(getClusterOptionsModel.XAuthRefreshToken).To(Equal(core.StringPtr("testString")))
				Expect(getClusterOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetConsumptionOfferingsOptions successfully`, func() {
				// Construct an instance of the GetConsumptionOfferingsOptions model
				getConsumptionOfferingsOptionsModel := catalogManagementService.NewGetConsumptionOfferingsOptions()
				getConsumptionOfferingsOptionsModel.SetDigest(true)
				getConsumptionOfferingsOptionsModel.SetCatalog("testString")
				getConsumptionOfferingsOptionsModel.SetSelect("all")
				getConsumptionOfferingsOptionsModel.SetIncludeHidden(true)
				getConsumptionOfferingsOptionsModel.SetLimit(int64(1000))
				getConsumptionOfferingsOptionsModel.SetOffset(int64(38))
				getConsumptionOfferingsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getConsumptionOfferingsOptionsModel).ToNot(BeNil())
				Expect(getConsumptionOfferingsOptionsModel.Digest).To(Equal(core.BoolPtr(true)))
				Expect(getConsumptionOfferingsOptionsModel.Catalog).To(Equal(core.StringPtr("testString")))
				Expect(getConsumptionOfferingsOptionsModel.Select).To(Equal(core.StringPtr("all")))
				Expect(getConsumptionOfferingsOptionsModel.IncludeHidden).To(Equal(core.BoolPtr(true)))
				Expect(getConsumptionOfferingsOptionsModel.Limit).To(Equal(core.Int64Ptr(int64(1000))))
				Expect(getConsumptionOfferingsOptionsModel.Offset).To(Equal(core.Int64Ptr(int64(38))))
				Expect(getConsumptionOfferingsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetEnterpriseAuditOptions successfully`, func() {
				// Construct an instance of the GetEnterpriseAuditOptions model
				enterpriseIdentifier := "testString"
				auditlogIdentifier := "testString"
				getEnterpriseAuditOptionsModel := catalogManagementService.NewGetEnterpriseAuditOptions(enterpriseIdentifier, auditlogIdentifier)
				getEnterpriseAuditOptionsModel.SetEnterpriseIdentifier("testString")
				getEnterpriseAuditOptionsModel.SetAuditlogIdentifier("testString")
				getEnterpriseAuditOptionsModel.SetLookupnames(true)
				getEnterpriseAuditOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getEnterpriseAuditOptionsModel).ToNot(BeNil())
				Expect(getEnterpriseAuditOptionsModel.EnterpriseIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getEnterpriseAuditOptionsModel.AuditlogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getEnterpriseAuditOptionsModel.Lookupnames).To(Equal(core.BoolPtr(true)))
				Expect(getEnterpriseAuditOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetNamespacesOptions successfully`, func() {
				// Construct an instance of the GetNamespacesOptions model
				clusterID := "testString"
				region := "testString"
				xAuthRefreshToken := "testString"
				getNamespacesOptionsModel := catalogManagementService.NewGetNamespacesOptions(clusterID, region, xAuthRefreshToken)
				getNamespacesOptionsModel.SetClusterID("testString")
				getNamespacesOptionsModel.SetRegion("testString")
				getNamespacesOptionsModel.SetXAuthRefreshToken("testString")
				getNamespacesOptionsModel.SetLimit(int64(1000))
				getNamespacesOptionsModel.SetOffset(int64(38))
				getNamespacesOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getNamespacesOptionsModel).ToNot(BeNil())
				Expect(getNamespacesOptionsModel.ClusterID).To(Equal(core.StringPtr("testString")))
				Expect(getNamespacesOptionsModel.Region).To(Equal(core.StringPtr("testString")))
				Expect(getNamespacesOptionsModel.XAuthRefreshToken).To(Equal(core.StringPtr("testString")))
				Expect(getNamespacesOptionsModel.Limit).To(Equal(core.Int64Ptr(int64(1000))))
				Expect(getNamespacesOptionsModel.Offset).To(Equal(core.Int64Ptr(int64(38))))
				Expect(getNamespacesOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetObjectAccessListDeprecatedOptions successfully`, func() {
				// Construct an instance of the GetObjectAccessListDeprecatedOptions model
				catalogIdentifier := "testString"
				objectIdentifier := "testString"
				getObjectAccessListDeprecatedOptionsModel := catalogManagementService.NewGetObjectAccessListDeprecatedOptions(catalogIdentifier, objectIdentifier)
				getObjectAccessListDeprecatedOptionsModel.SetCatalogIdentifier("testString")
				getObjectAccessListDeprecatedOptionsModel.SetObjectIdentifier("testString")
				getObjectAccessListDeprecatedOptionsModel.SetLimit(int64(1000))
				getObjectAccessListDeprecatedOptionsModel.SetOffset(int64(38))
				getObjectAccessListDeprecatedOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getObjectAccessListDeprecatedOptionsModel).ToNot(BeNil())
				Expect(getObjectAccessListDeprecatedOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getObjectAccessListDeprecatedOptionsModel.ObjectIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getObjectAccessListDeprecatedOptionsModel.Limit).To(Equal(core.Int64Ptr(int64(1000))))
				Expect(getObjectAccessListDeprecatedOptionsModel.Offset).To(Equal(core.Int64Ptr(int64(38))))
				Expect(getObjectAccessListDeprecatedOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetObjectAccessListOptions successfully`, func() {
				// Construct an instance of the GetObjectAccessListOptions model
				catalogIdentifier := "testString"
				objectIdentifier := "testString"
				getObjectAccessListOptionsModel := catalogManagementService.NewGetObjectAccessListOptions(catalogIdentifier, objectIdentifier)
				getObjectAccessListOptionsModel.SetCatalogIdentifier("testString")
				getObjectAccessListOptionsModel.SetObjectIdentifier("testString")
				getObjectAccessListOptionsModel.SetStart("testString")
				getObjectAccessListOptionsModel.SetLimit(int64(10))
				getObjectAccessListOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getObjectAccessListOptionsModel).ToNot(BeNil())
				Expect(getObjectAccessListOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getObjectAccessListOptionsModel.ObjectIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getObjectAccessListOptionsModel.Start).To(Equal(core.StringPtr("testString")))
				Expect(getObjectAccessListOptionsModel.Limit).To(Equal(core.Int64Ptr(int64(10))))
				Expect(getObjectAccessListOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetObjectAccessOptions successfully`, func() {
				// Construct an instance of the GetObjectAccessOptions model
				catalogIdentifier := "testString"
				objectIdentifier := "testString"
				accessIdentifier := "testString"
				getObjectAccessOptionsModel := catalogManagementService.NewGetObjectAccessOptions(catalogIdentifier, objectIdentifier, accessIdentifier)
				getObjectAccessOptionsModel.SetCatalogIdentifier("testString")
				getObjectAccessOptionsModel.SetObjectIdentifier("testString")
				getObjectAccessOptionsModel.SetAccessIdentifier("testString")
				getObjectAccessOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getObjectAccessOptionsModel).ToNot(BeNil())
				Expect(getObjectAccessOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getObjectAccessOptionsModel.ObjectIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getObjectAccessOptionsModel.AccessIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getObjectAccessOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetObjectAuditOptions successfully`, func() {
				// Construct an instance of the GetObjectAuditOptions model
				catalogIdentifier := "testString"
				objectIdentifier := "testString"
				auditlogIdentifier := "testString"
				getObjectAuditOptionsModel := catalogManagementService.NewGetObjectAuditOptions(catalogIdentifier, objectIdentifier, auditlogIdentifier)
				getObjectAuditOptionsModel.SetCatalogIdentifier("testString")
				getObjectAuditOptionsModel.SetObjectIdentifier("testString")
				getObjectAuditOptionsModel.SetAuditlogIdentifier("testString")
				getObjectAuditOptionsModel.SetLookupnames(true)
				getObjectAuditOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getObjectAuditOptionsModel).ToNot(BeNil())
				Expect(getObjectAuditOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getObjectAuditOptionsModel.ObjectIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getObjectAuditOptionsModel.AuditlogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getObjectAuditOptionsModel.Lookupnames).To(Equal(core.BoolPtr(true)))
				Expect(getObjectAuditOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetObjectOptions successfully`, func() {
				// Construct an instance of the GetObjectOptions model
				catalogIdentifier := "testString"
				objectIdentifier := "testString"
				getObjectOptionsModel := catalogManagementService.NewGetObjectOptions(catalogIdentifier, objectIdentifier)
				getObjectOptionsModel.SetCatalogIdentifier("testString")
				getObjectOptionsModel.SetObjectIdentifier("testString")
				getObjectOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getObjectOptionsModel).ToNot(BeNil())
				Expect(getObjectOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getObjectOptionsModel.ObjectIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getObjectOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetOfferingAboutOptions successfully`, func() {
				// Construct an instance of the GetOfferingAboutOptions model
				versionLocID := "testString"
				getOfferingAboutOptionsModel := catalogManagementService.NewGetOfferingAboutOptions(versionLocID)
				getOfferingAboutOptionsModel.SetVersionLocID("testString")
				getOfferingAboutOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getOfferingAboutOptionsModel).ToNot(BeNil())
				Expect(getOfferingAboutOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingAboutOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetOfferingAccessListOptions successfully`, func() {
				// Construct an instance of the GetOfferingAccessListOptions model
				catalogIdentifier := "testString"
				offeringID := "testString"
				getOfferingAccessListOptionsModel := catalogManagementService.NewGetOfferingAccessListOptions(catalogIdentifier, offeringID)
				getOfferingAccessListOptionsModel.SetCatalogIdentifier("testString")
				getOfferingAccessListOptionsModel.SetOfferingID("testString")
				getOfferingAccessListOptionsModel.SetStart("testString")
				getOfferingAccessListOptionsModel.SetLimit(int64(10))
				getOfferingAccessListOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getOfferingAccessListOptionsModel).ToNot(BeNil())
				Expect(getOfferingAccessListOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingAccessListOptionsModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingAccessListOptionsModel.Start).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingAccessListOptionsModel.Limit).To(Equal(core.Int64Ptr(int64(10))))
				Expect(getOfferingAccessListOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetOfferingAccessOptions successfully`, func() {
				// Construct an instance of the GetOfferingAccessOptions model
				catalogIdentifier := "testString"
				offeringID := "testString"
				accessIdentifier := "testString"
				getOfferingAccessOptionsModel := catalogManagementService.NewGetOfferingAccessOptions(catalogIdentifier, offeringID, accessIdentifier)
				getOfferingAccessOptionsModel.SetCatalogIdentifier("testString")
				getOfferingAccessOptionsModel.SetOfferingID("testString")
				getOfferingAccessOptionsModel.SetAccessIdentifier("testString")
				getOfferingAccessOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getOfferingAccessOptionsModel).ToNot(BeNil())
				Expect(getOfferingAccessOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingAccessOptionsModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingAccessOptionsModel.AccessIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingAccessOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetOfferingAuditOptions successfully`, func() {
				// Construct an instance of the GetOfferingAuditOptions model
				catalogIdentifier := "testString"
				offeringID := "testString"
				auditlogIdentifier := "testString"
				getOfferingAuditOptionsModel := catalogManagementService.NewGetOfferingAuditOptions(catalogIdentifier, offeringID, auditlogIdentifier)
				getOfferingAuditOptionsModel.SetCatalogIdentifier("testString")
				getOfferingAuditOptionsModel.SetOfferingID("testString")
				getOfferingAuditOptionsModel.SetAuditlogIdentifier("testString")
				getOfferingAuditOptionsModel.SetLookupnames(true)
				getOfferingAuditOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getOfferingAuditOptionsModel).ToNot(BeNil())
				Expect(getOfferingAuditOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingAuditOptionsModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingAuditOptionsModel.AuditlogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingAuditOptionsModel.Lookupnames).To(Equal(core.BoolPtr(true)))
				Expect(getOfferingAuditOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetOfferingContainerImagesOptions successfully`, func() {
				// Construct an instance of the GetOfferingContainerImagesOptions model
				versionLocID := "testString"
				getOfferingContainerImagesOptionsModel := catalogManagementService.NewGetOfferingContainerImagesOptions(versionLocID)
				getOfferingContainerImagesOptionsModel.SetVersionLocID("testString")
				getOfferingContainerImagesOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getOfferingContainerImagesOptionsModel).ToNot(BeNil())
				Expect(getOfferingContainerImagesOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingContainerImagesOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetOfferingInstanceAuditOptions successfully`, func() {
				// Construct an instance of the GetOfferingInstanceAuditOptions model
				instanceIdentifier := "testString"
				auditlogIdentifier := "testString"
				getOfferingInstanceAuditOptionsModel := catalogManagementService.NewGetOfferingInstanceAuditOptions(instanceIdentifier, auditlogIdentifier)
				getOfferingInstanceAuditOptionsModel.SetInstanceIdentifier("testString")
				getOfferingInstanceAuditOptionsModel.SetAuditlogIdentifier("testString")
				getOfferingInstanceAuditOptionsModel.SetLookupnames(true)
				getOfferingInstanceAuditOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getOfferingInstanceAuditOptionsModel).ToNot(BeNil())
				Expect(getOfferingInstanceAuditOptionsModel.InstanceIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingInstanceAuditOptionsModel.AuditlogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingInstanceAuditOptionsModel.Lookupnames).To(Equal(core.BoolPtr(true)))
				Expect(getOfferingInstanceAuditOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetOfferingInstanceOptions successfully`, func() {
				// Construct an instance of the GetOfferingInstanceOptions model
				instanceIdentifier := "testString"
				getOfferingInstanceOptionsModel := catalogManagementService.NewGetOfferingInstanceOptions(instanceIdentifier)
				getOfferingInstanceOptionsModel.SetInstanceIdentifier("testString")
				getOfferingInstanceOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getOfferingInstanceOptionsModel).ToNot(BeNil())
				Expect(getOfferingInstanceOptionsModel.InstanceIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingInstanceOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetOfferingLicenseOptions successfully`, func() {
				// Construct an instance of the GetOfferingLicenseOptions model
				versionLocID := "testString"
				licenseID := "testString"
				getOfferingLicenseOptionsModel := catalogManagementService.NewGetOfferingLicenseOptions(versionLocID, licenseID)
				getOfferingLicenseOptionsModel.SetVersionLocID("testString")
				getOfferingLicenseOptionsModel.SetLicenseID("testString")
				getOfferingLicenseOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getOfferingLicenseOptionsModel).ToNot(BeNil())
				Expect(getOfferingLicenseOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingLicenseOptionsModel.LicenseID).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingLicenseOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetOfferingOptions successfully`, func() {
				// Construct an instance of the GetOfferingOptions model
				catalogIdentifier := "testString"
				offeringID := "testString"
				getOfferingOptionsModel := catalogManagementService.NewGetOfferingOptions(catalogIdentifier, offeringID)
				getOfferingOptionsModel.SetCatalogIdentifier("testString")
				getOfferingOptionsModel.SetOfferingID("testString")
				getOfferingOptionsModel.SetType("testString")
				getOfferingOptionsModel.SetDigest(true)
				getOfferingOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getOfferingOptionsModel).ToNot(BeNil())
				Expect(getOfferingOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingOptionsModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingOptionsModel.Type).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingOptionsModel.Digest).To(Equal(core.BoolPtr(true)))
				Expect(getOfferingOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetOfferingSourceOptions successfully`, func() {
				// Construct an instance of the GetOfferingSourceOptions model
				version := "testString"
				getOfferingSourceOptionsModel := catalogManagementService.NewGetOfferingSourceOptions(version)
				getOfferingSourceOptionsModel.SetVersion("testString")
				getOfferingSourceOptionsModel.SetAccept("application/yaml")
				getOfferingSourceOptionsModel.SetCatalogID("testString")
				getOfferingSourceOptionsModel.SetName("testString")
				getOfferingSourceOptionsModel.SetID("testString")
				getOfferingSourceOptionsModel.SetKind("testString")
				getOfferingSourceOptionsModel.SetChannel("testString")
				getOfferingSourceOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getOfferingSourceOptionsModel).ToNot(BeNil())
				Expect(getOfferingSourceOptionsModel.Version).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingSourceOptionsModel.Accept).To(Equal(core.StringPtr("application/yaml")))
				Expect(getOfferingSourceOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingSourceOptionsModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingSourceOptionsModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingSourceOptionsModel.Kind).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingSourceOptionsModel.Channel).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingSourceOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetOfferingSourceURLOptions successfully`, func() {
				// Construct an instance of the GetOfferingSourceURLOptions model
				keyIdentifier := "testString"
				getOfferingSourceURLOptionsModel := catalogManagementService.NewGetOfferingSourceURLOptions(keyIdentifier)
				getOfferingSourceURLOptionsModel.SetKeyIdentifier("testString")
				getOfferingSourceURLOptionsModel.SetAccept("application/yaml")
				getOfferingSourceURLOptionsModel.SetCatalogID("testString")
				getOfferingSourceURLOptionsModel.SetName("testString")
				getOfferingSourceURLOptionsModel.SetID("testString")
				getOfferingSourceURLOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getOfferingSourceURLOptionsModel).ToNot(BeNil())
				Expect(getOfferingSourceURLOptionsModel.KeyIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingSourceURLOptionsModel.Accept).To(Equal(core.StringPtr("application/yaml")))
				Expect(getOfferingSourceURLOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingSourceURLOptionsModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingSourceURLOptionsModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingSourceURLOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetOfferingUpdatesOptions successfully`, func() {
				// Construct an instance of the GetOfferingUpdatesOptions model
				catalogIdentifier := "testString"
				offeringID := "testString"
				kind := "testString"
				xAuthRefreshToken := "testString"
				getOfferingUpdatesOptionsModel := catalogManagementService.NewGetOfferingUpdatesOptions(catalogIdentifier, offeringID, kind, xAuthRefreshToken)
				getOfferingUpdatesOptionsModel.SetCatalogIdentifier("testString")
				getOfferingUpdatesOptionsModel.SetOfferingID("testString")
				getOfferingUpdatesOptionsModel.SetKind("testString")
				getOfferingUpdatesOptionsModel.SetXAuthRefreshToken("testString")
				getOfferingUpdatesOptionsModel.SetTarget("testString")
				getOfferingUpdatesOptionsModel.SetVersion("testString")
				getOfferingUpdatesOptionsModel.SetClusterID("testString")
				getOfferingUpdatesOptionsModel.SetRegion("testString")
				getOfferingUpdatesOptionsModel.SetResourceGroupID("testString")
				getOfferingUpdatesOptionsModel.SetNamespace("testString")
				getOfferingUpdatesOptionsModel.SetSha("testString")
				getOfferingUpdatesOptionsModel.SetChannel("testString")
				getOfferingUpdatesOptionsModel.SetNamespaces([]string{"testString"})
				getOfferingUpdatesOptionsModel.SetAllNamespaces(true)
				getOfferingUpdatesOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getOfferingUpdatesOptionsModel).ToNot(BeNil())
				Expect(getOfferingUpdatesOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingUpdatesOptionsModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingUpdatesOptionsModel.Kind).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingUpdatesOptionsModel.XAuthRefreshToken).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingUpdatesOptionsModel.Target).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingUpdatesOptionsModel.Version).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingUpdatesOptionsModel.ClusterID).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingUpdatesOptionsModel.Region).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingUpdatesOptionsModel.ResourceGroupID).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingUpdatesOptionsModel.Namespace).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingUpdatesOptionsModel.Sha).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingUpdatesOptionsModel.Channel).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingUpdatesOptionsModel.Namespaces).To(Equal([]string{"testString"}))
				Expect(getOfferingUpdatesOptionsModel.AllNamespaces).To(Equal(core.BoolPtr(true)))
				Expect(getOfferingUpdatesOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetOfferingWorkingCopyOptions successfully`, func() {
				// Construct an instance of the GetOfferingWorkingCopyOptions model
				versionLocID := "testString"
				getOfferingWorkingCopyOptionsModel := catalogManagementService.NewGetOfferingWorkingCopyOptions(versionLocID)
				getOfferingWorkingCopyOptionsModel.SetVersionLocID("testString")
				getOfferingWorkingCopyOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getOfferingWorkingCopyOptionsModel).ToNot(BeNil())
				Expect(getOfferingWorkingCopyOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingWorkingCopyOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetOverrideValuesOptions successfully`, func() {
				// Construct an instance of the GetOverrideValuesOptions model
				versionLocID := "testString"
				getOverrideValuesOptionsModel := catalogManagementService.NewGetOverrideValuesOptions(versionLocID)
				getOverrideValuesOptionsModel.SetVersionLocID("testString")
				getOverrideValuesOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getOverrideValuesOptionsModel).ToNot(BeNil())
				Expect(getOverrideValuesOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(getOverrideValuesOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetPreinstallOptions successfully`, func() {
				// Construct an instance of the GetPreinstallOptions model
				versionLocID := "testString"
				xAuthRefreshToken := "testString"
				getPreinstallOptionsModel := catalogManagementService.NewGetPreinstallOptions(versionLocID, xAuthRefreshToken)
				getPreinstallOptionsModel.SetVersionLocID("testString")
				getPreinstallOptionsModel.SetXAuthRefreshToken("testString")
				getPreinstallOptionsModel.SetClusterID("testString")
				getPreinstallOptionsModel.SetRegion("testString")
				getPreinstallOptionsModel.SetNamespace("testString")
				getPreinstallOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getPreinstallOptionsModel).ToNot(BeNil())
				Expect(getPreinstallOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(getPreinstallOptionsModel.XAuthRefreshToken).To(Equal(core.StringPtr("testString")))
				Expect(getPreinstallOptionsModel.ClusterID).To(Equal(core.StringPtr("testString")))
				Expect(getPreinstallOptionsModel.Region).To(Equal(core.StringPtr("testString")))
				Expect(getPreinstallOptionsModel.Namespace).To(Equal(core.StringPtr("testString")))
				Expect(getPreinstallOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetValidationStatusOptions successfully`, func() {
				// Construct an instance of the GetValidationStatusOptions model
				versionLocID := "testString"
				xAuthRefreshToken := "testString"
				getValidationStatusOptionsModel := catalogManagementService.NewGetValidationStatusOptions(versionLocID, xAuthRefreshToken)
				getValidationStatusOptionsModel.SetVersionLocID("testString")
				getValidationStatusOptionsModel.SetXAuthRefreshToken("testString")
				getValidationStatusOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getValidationStatusOptionsModel).ToNot(BeNil())
				Expect(getValidationStatusOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(getValidationStatusOptionsModel.XAuthRefreshToken).To(Equal(core.StringPtr("testString")))
				Expect(getValidationStatusOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetVersionOptions successfully`, func() {
				// Construct an instance of the GetVersionOptions model
				versionLocID := "testString"
				getVersionOptionsModel := catalogManagementService.NewGetVersionOptions(versionLocID)
				getVersionOptionsModel.SetVersionLocID("testString")
				getVersionOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getVersionOptionsModel).ToNot(BeNil())
				Expect(getVersionOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(getVersionOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewIBMPublishObjectOptions successfully`, func() {
				// Construct an instance of the IBMPublishObjectOptions model
				catalogIdentifier := "testString"
				objectIdentifier := "testString"
				ibmPublishObjectOptionsModel := catalogManagementService.NewIBMPublishObjectOptions(catalogIdentifier, objectIdentifier)
				ibmPublishObjectOptionsModel.SetCatalogIdentifier("testString")
				ibmPublishObjectOptionsModel.SetObjectIdentifier("testString")
				ibmPublishObjectOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(ibmPublishObjectOptionsModel).ToNot(BeNil())
				Expect(ibmPublishObjectOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(ibmPublishObjectOptionsModel.ObjectIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(ibmPublishObjectOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewIBMPublishVersionOptions successfully`, func() {
				// Construct an instance of the IBMPublishVersionOptions model
				versionLocID := "testString"
				ibmPublishVersionOptionsModel := catalogManagementService.NewIBMPublishVersionOptions(versionLocID)
				ibmPublishVersionOptionsModel.SetVersionLocID("testString")
				ibmPublishVersionOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(ibmPublishVersionOptionsModel).ToNot(BeNil())
				Expect(ibmPublishVersionOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(ibmPublishVersionOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewImportOfferingOptions successfully`, func() {
				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				Expect(flavorModel).ToNot(BeNil())
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = make(map[string]string)
				flavorModel.Index = core.Int64Ptr(int64(38))
				Expect(flavorModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(flavorModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(flavorModel.LabelI18n).To(Equal(make(map[string]string)))
				Expect(flavorModel.Index).To(Equal(core.Int64Ptr(int64(38))))

				// Construct an instance of the ImportOfferingBodyMetadataOperatingSystem model
				importOfferingBodyMetadataOperatingSystemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataOperatingSystem)
				Expect(importOfferingBodyMetadataOperatingSystemModel).ToNot(BeNil())
				importOfferingBodyMetadataOperatingSystemModel.DedicatedHostOnly = core.BoolPtr(true)
				importOfferingBodyMetadataOperatingSystemModel.Vendor = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Href = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.DisplayName = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Family = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Version = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Architecture = core.StringPtr("testString")
				Expect(importOfferingBodyMetadataOperatingSystemModel.DedicatedHostOnly).To(Equal(core.BoolPtr(true)))
				Expect(importOfferingBodyMetadataOperatingSystemModel.Vendor).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingBodyMetadataOperatingSystemModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingBodyMetadataOperatingSystemModel.Href).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingBodyMetadataOperatingSystemModel.DisplayName).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingBodyMetadataOperatingSystemModel.Family).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingBodyMetadataOperatingSystemModel.Version).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingBodyMetadataOperatingSystemModel.Architecture).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the ImportOfferingBodyMetadataFile model
				importOfferingBodyMetadataFileModel := new(catalogmanagementv1.ImportOfferingBodyMetadataFile)
				Expect(importOfferingBodyMetadataFileModel).ToNot(BeNil())
				importOfferingBodyMetadataFileModel.Size = core.Int64Ptr(int64(38))
				Expect(importOfferingBodyMetadataFileModel.Size).To(Equal(core.Int64Ptr(int64(38))))

				// Construct an instance of the ImportOfferingBodyMetadataImagesItem model
				importOfferingBodyMetadataImagesItemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataImagesItem)
				Expect(importOfferingBodyMetadataImagesItemModel).ToNot(BeNil())
				importOfferingBodyMetadataImagesItemModel.ID = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Region = core.StringPtr("testString")
				Expect(importOfferingBodyMetadataImagesItemModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingBodyMetadataImagesItemModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingBodyMetadataImagesItemModel.Region).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the ImportOfferingBodyMetadata model
				importOfferingBodyMetadataModel := new(catalogmanagementv1.ImportOfferingBodyMetadata)
				Expect(importOfferingBodyMetadataModel).ToNot(BeNil())
				importOfferingBodyMetadataModel.OperatingSystem = importOfferingBodyMetadataOperatingSystemModel
				importOfferingBodyMetadataModel.File = importOfferingBodyMetadataFileModel
				importOfferingBodyMetadataModel.MinimumProvisionedSize = core.Int64Ptr(int64(38))
				importOfferingBodyMetadataModel.Images = []catalogmanagementv1.ImportOfferingBodyMetadataImagesItem{*importOfferingBodyMetadataImagesItemModel}
				Expect(importOfferingBodyMetadataModel.OperatingSystem).To(Equal(importOfferingBodyMetadataOperatingSystemModel))
				Expect(importOfferingBodyMetadataModel.File).To(Equal(importOfferingBodyMetadataFileModel))
				Expect(importOfferingBodyMetadataModel.MinimumProvisionedSize).To(Equal(core.Int64Ptr(int64(38))))
				Expect(importOfferingBodyMetadataModel.Images).To(Equal([]catalogmanagementv1.ImportOfferingBodyMetadataImagesItem{*importOfferingBodyMetadataImagesItemModel}))

				// Construct an instance of the ImportOfferingOptions model
				catalogIdentifier := "testString"
				importOfferingOptionsModel := catalogManagementService.NewImportOfferingOptions(catalogIdentifier)
				importOfferingOptionsModel.SetCatalogIdentifier("testString")
				importOfferingOptionsModel.SetTags([]string{"testString"})
				importOfferingOptionsModel.SetContent(*CreateMockByteArray("This is a mock byte array value."))
				importOfferingOptionsModel.SetName("testString")
				importOfferingOptionsModel.SetLabel("testString")
				importOfferingOptionsModel.SetInstallKind("testString")
				importOfferingOptionsModel.SetTargetKinds([]string{"testString"})
				importOfferingOptionsModel.SetFormatKind("testString")
				importOfferingOptionsModel.SetProductKind("testString")
				importOfferingOptionsModel.SetSha("testString")
				importOfferingOptionsModel.SetVersion("testString")
				importOfferingOptionsModel.SetFlavor(flavorModel)
				importOfferingOptionsModel.SetMetadata(importOfferingBodyMetadataModel)
				importOfferingOptionsModel.SetWorkingDirectory("testString")
				importOfferingOptionsModel.SetZipurl("testString")
				importOfferingOptionsModel.SetOfferingID("testString")
				importOfferingOptionsModel.SetTargetVersion("testString")
				importOfferingOptionsModel.SetIncludeConfig(true)
				importOfferingOptionsModel.SetIsVsi(true)
				importOfferingOptionsModel.SetRepotype("testString")
				importOfferingOptionsModel.SetXAuthToken("testString")
				importOfferingOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(importOfferingOptionsModel).ToNot(BeNil())
				Expect(importOfferingOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingOptionsModel.Tags).To(Equal([]string{"testString"}))
				Expect(importOfferingOptionsModel.Content).To(Equal(CreateMockByteArray("This is a mock byte array value.")))
				Expect(importOfferingOptionsModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingOptionsModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingOptionsModel.InstallKind).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingOptionsModel.TargetKinds).To(Equal([]string{"testString"}))
				Expect(importOfferingOptionsModel.FormatKind).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingOptionsModel.ProductKind).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingOptionsModel.Sha).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingOptionsModel.Version).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingOptionsModel.Flavor).To(Equal(flavorModel))
				Expect(importOfferingOptionsModel.Metadata).To(Equal(importOfferingBodyMetadataModel))
				Expect(importOfferingOptionsModel.WorkingDirectory).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingOptionsModel.Zipurl).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingOptionsModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingOptionsModel.TargetVersion).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingOptionsModel.IncludeConfig).To(Equal(core.BoolPtr(true)))
				Expect(importOfferingOptionsModel.IsVsi).To(Equal(core.BoolPtr(true)))
				Expect(importOfferingOptionsModel.Repotype).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingOptionsModel.XAuthToken).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewImportOfferingVersionOptions successfully`, func() {
				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				Expect(flavorModel).ToNot(BeNil())
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = make(map[string]string)
				flavorModel.Index = core.Int64Ptr(int64(38))
				Expect(flavorModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(flavorModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(flavorModel.LabelI18n).To(Equal(make(map[string]string)))
				Expect(flavorModel.Index).To(Equal(core.Int64Ptr(int64(38))))

				// Construct an instance of the ImportOfferingBodyMetadataOperatingSystem model
				importOfferingBodyMetadataOperatingSystemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataOperatingSystem)
				Expect(importOfferingBodyMetadataOperatingSystemModel).ToNot(BeNil())
				importOfferingBodyMetadataOperatingSystemModel.DedicatedHostOnly = core.BoolPtr(true)
				importOfferingBodyMetadataOperatingSystemModel.Vendor = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Href = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.DisplayName = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Family = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Version = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Architecture = core.StringPtr("testString")
				Expect(importOfferingBodyMetadataOperatingSystemModel.DedicatedHostOnly).To(Equal(core.BoolPtr(true)))
				Expect(importOfferingBodyMetadataOperatingSystemModel.Vendor).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingBodyMetadataOperatingSystemModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingBodyMetadataOperatingSystemModel.Href).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingBodyMetadataOperatingSystemModel.DisplayName).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingBodyMetadataOperatingSystemModel.Family).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingBodyMetadataOperatingSystemModel.Version).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingBodyMetadataOperatingSystemModel.Architecture).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the ImportOfferingBodyMetadataFile model
				importOfferingBodyMetadataFileModel := new(catalogmanagementv1.ImportOfferingBodyMetadataFile)
				Expect(importOfferingBodyMetadataFileModel).ToNot(BeNil())
				importOfferingBodyMetadataFileModel.Size = core.Int64Ptr(int64(38))
				Expect(importOfferingBodyMetadataFileModel.Size).To(Equal(core.Int64Ptr(int64(38))))

				// Construct an instance of the ImportOfferingBodyMetadataImagesItem model
				importOfferingBodyMetadataImagesItemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataImagesItem)
				Expect(importOfferingBodyMetadataImagesItemModel).ToNot(BeNil())
				importOfferingBodyMetadataImagesItemModel.ID = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Region = core.StringPtr("testString")
				Expect(importOfferingBodyMetadataImagesItemModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingBodyMetadataImagesItemModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingBodyMetadataImagesItemModel.Region).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the ImportOfferingBodyMetadata model
				importOfferingBodyMetadataModel := new(catalogmanagementv1.ImportOfferingBodyMetadata)
				Expect(importOfferingBodyMetadataModel).ToNot(BeNil())
				importOfferingBodyMetadataModel.OperatingSystem = importOfferingBodyMetadataOperatingSystemModel
				importOfferingBodyMetadataModel.File = importOfferingBodyMetadataFileModel
				importOfferingBodyMetadataModel.MinimumProvisionedSize = core.Int64Ptr(int64(38))
				importOfferingBodyMetadataModel.Images = []catalogmanagementv1.ImportOfferingBodyMetadataImagesItem{*importOfferingBodyMetadataImagesItemModel}
				Expect(importOfferingBodyMetadataModel.OperatingSystem).To(Equal(importOfferingBodyMetadataOperatingSystemModel))
				Expect(importOfferingBodyMetadataModel.File).To(Equal(importOfferingBodyMetadataFileModel))
				Expect(importOfferingBodyMetadataModel.MinimumProvisionedSize).To(Equal(core.Int64Ptr(int64(38))))
				Expect(importOfferingBodyMetadataModel.Images).To(Equal([]catalogmanagementv1.ImportOfferingBodyMetadataImagesItem{*importOfferingBodyMetadataImagesItemModel}))

				// Construct an instance of the ImportOfferingVersionOptions model
				catalogIdentifier := "testString"
				offeringID := "testString"
				importOfferingVersionOptionsModel := catalogManagementService.NewImportOfferingVersionOptions(catalogIdentifier, offeringID)
				importOfferingVersionOptionsModel.SetCatalogIdentifier("testString")
				importOfferingVersionOptionsModel.SetOfferingID("testString")
				importOfferingVersionOptionsModel.SetTags([]string{"testString"})
				importOfferingVersionOptionsModel.SetContent(*CreateMockByteArray("This is a mock byte array value."))
				importOfferingVersionOptionsModel.SetName("testString")
				importOfferingVersionOptionsModel.SetLabel("testString")
				importOfferingVersionOptionsModel.SetInstallKind("testString")
				importOfferingVersionOptionsModel.SetTargetKinds([]string{"testString"})
				importOfferingVersionOptionsModel.SetFormatKind("testString")
				importOfferingVersionOptionsModel.SetProductKind("testString")
				importOfferingVersionOptionsModel.SetSha("testString")
				importOfferingVersionOptionsModel.SetVersion("testString")
				importOfferingVersionOptionsModel.SetFlavor(flavorModel)
				importOfferingVersionOptionsModel.SetMetadata(importOfferingBodyMetadataModel)
				importOfferingVersionOptionsModel.SetWorkingDirectory("testString")
				importOfferingVersionOptionsModel.SetZipurl("testString")
				importOfferingVersionOptionsModel.SetTargetVersion("testString")
				importOfferingVersionOptionsModel.SetIncludeConfig(true)
				importOfferingVersionOptionsModel.SetIsVsi(true)
				importOfferingVersionOptionsModel.SetRepotype("testString")
				importOfferingVersionOptionsModel.SetXAuthToken("testString")
				importOfferingVersionOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(importOfferingVersionOptionsModel).ToNot(BeNil())
				Expect(importOfferingVersionOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingVersionOptionsModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingVersionOptionsModel.Tags).To(Equal([]string{"testString"}))
				Expect(importOfferingVersionOptionsModel.Content).To(Equal(CreateMockByteArray("This is a mock byte array value.")))
				Expect(importOfferingVersionOptionsModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingVersionOptionsModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingVersionOptionsModel.InstallKind).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingVersionOptionsModel.TargetKinds).To(Equal([]string{"testString"}))
				Expect(importOfferingVersionOptionsModel.FormatKind).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingVersionOptionsModel.ProductKind).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingVersionOptionsModel.Sha).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingVersionOptionsModel.Version).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingVersionOptionsModel.Flavor).To(Equal(flavorModel))
				Expect(importOfferingVersionOptionsModel.Metadata).To(Equal(importOfferingBodyMetadataModel))
				Expect(importOfferingVersionOptionsModel.WorkingDirectory).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingVersionOptionsModel.Zipurl).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingVersionOptionsModel.TargetVersion).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingVersionOptionsModel.IncludeConfig).To(Equal(core.BoolPtr(true)))
				Expect(importOfferingVersionOptionsModel.IsVsi).To(Equal(core.BoolPtr(true)))
				Expect(importOfferingVersionOptionsModel.Repotype).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingVersionOptionsModel.XAuthToken).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingVersionOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewInstallVersionOptions successfully`, func() {
				// Construct an instance of the DeployRequestBodyOverrideValues model
				deployRequestBodyOverrideValuesModel := new(catalogmanagementv1.DeployRequestBodyOverrideValues)
				Expect(deployRequestBodyOverrideValuesModel).ToNot(BeNil())
				deployRequestBodyOverrideValuesModel.VsiInstanceName = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCProfile = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SubnetID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SubnetZone = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SSHKeyID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCRegion = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SetProperty("foo", core.StringPtr("testString"))
				Expect(deployRequestBodyOverrideValuesModel.VsiInstanceName).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyOverrideValuesModel.VPCProfile).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyOverrideValuesModel.SubnetID).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyOverrideValuesModel.VPCID).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyOverrideValuesModel.SubnetZone).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyOverrideValuesModel.SSHKeyID).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyOverrideValuesModel.VPCRegion).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyOverrideValuesModel.GetProperties()).ToNot(BeEmpty())
				Expect(deployRequestBodyOverrideValuesModel.GetProperty("foo")).To(Equal(core.StringPtr("testString")))

				deployRequestBodyOverrideValuesModel.SetProperties(nil)
				Expect(deployRequestBodyOverrideValuesModel.GetProperties()).To(BeEmpty())

				deployRequestBodyOverrideValuesModelExpectedMap := make(map[string]interface{})
				deployRequestBodyOverrideValuesModelExpectedMap["foo"] = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SetProperties(deployRequestBodyOverrideValuesModelExpectedMap)
				deployRequestBodyOverrideValuesModelActualMap := deployRequestBodyOverrideValuesModel.GetProperties()
				Expect(deployRequestBodyOverrideValuesModelActualMap).To(Equal(deployRequestBodyOverrideValuesModelExpectedMap))

				// Construct an instance of the DeployRequestBodyEnvironmentVariablesItem model
				deployRequestBodyEnvironmentVariablesItemModel := new(catalogmanagementv1.DeployRequestBodyEnvironmentVariablesItem)
				Expect(deployRequestBodyEnvironmentVariablesItemModel).ToNot(BeNil())
				deployRequestBodyEnvironmentVariablesItemModel.Name = core.StringPtr("testString")
				deployRequestBodyEnvironmentVariablesItemModel.Value = core.StringPtr("testString")
				deployRequestBodyEnvironmentVariablesItemModel.Secure = core.BoolPtr(true)
				Expect(deployRequestBodyEnvironmentVariablesItemModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyEnvironmentVariablesItemModel.Value).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyEnvironmentVariablesItemModel.Secure).To(Equal(core.BoolPtr(true)))

				// Construct an instance of the DeployRequestBodySchematics model
				deployRequestBodySchematicsModel := new(catalogmanagementv1.DeployRequestBodySchematics)
				Expect(deployRequestBodySchematicsModel).ToNot(BeNil())
				deployRequestBodySchematicsModel.Name = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Description = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Tags = []string{"testString"}
				deployRequestBodySchematicsModel.ResourceGroupID = core.StringPtr("testString")
				deployRequestBodySchematicsModel.TerraformVersion = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Region = core.StringPtr("testString")
				Expect(deployRequestBodySchematicsModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodySchematicsModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodySchematicsModel.Tags).To(Equal([]string{"testString"}))
				Expect(deployRequestBodySchematicsModel.ResourceGroupID).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodySchematicsModel.TerraformVersion).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodySchematicsModel.Region).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the InstallVersionOptions model
				versionLocID := "testString"
				xAuthRefreshToken := "testString"
				installVersionOptionsModel := catalogManagementService.NewInstallVersionOptions(versionLocID, xAuthRefreshToken)
				installVersionOptionsModel.SetVersionLocID("testString")
				installVersionOptionsModel.SetXAuthRefreshToken("testString")
				installVersionOptionsModel.SetClusterID("testString")
				installVersionOptionsModel.SetRegion("testString")
				installVersionOptionsModel.SetNamespace("testString")
				installVersionOptionsModel.SetOverrideValues(deployRequestBodyOverrideValuesModel)
				installVersionOptionsModel.SetEnvironmentVariables([]catalogmanagementv1.DeployRequestBodyEnvironmentVariablesItem{*deployRequestBodyEnvironmentVariablesItemModel})
				installVersionOptionsModel.SetEntitlementApikey("testString")
				installVersionOptionsModel.SetSchematics(deployRequestBodySchematicsModel)
				installVersionOptionsModel.SetScript("testString")
				installVersionOptionsModel.SetScriptID("testString")
				installVersionOptionsModel.SetVersionLocatorID("testString")
				installVersionOptionsModel.SetVcenterID("testString")
				installVersionOptionsModel.SetVcenterLocation("testString")
				installVersionOptionsModel.SetVcenterUser("testString")
				installVersionOptionsModel.SetVcenterPassword("testString")
				installVersionOptionsModel.SetVcenterDatastore("testString")
				installVersionOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(installVersionOptionsModel).ToNot(BeNil())
				Expect(installVersionOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(installVersionOptionsModel.XAuthRefreshToken).To(Equal(core.StringPtr("testString")))
				Expect(installVersionOptionsModel.ClusterID).To(Equal(core.StringPtr("testString")))
				Expect(installVersionOptionsModel.Region).To(Equal(core.StringPtr("testString")))
				Expect(installVersionOptionsModel.Namespace).To(Equal(core.StringPtr("testString")))
				Expect(installVersionOptionsModel.OverrideValues).To(Equal(deployRequestBodyOverrideValuesModel))
				Expect(installVersionOptionsModel.EnvironmentVariables).To(Equal([]catalogmanagementv1.DeployRequestBodyEnvironmentVariablesItem{*deployRequestBodyEnvironmentVariablesItemModel}))
				Expect(installVersionOptionsModel.EntitlementApikey).To(Equal(core.StringPtr("testString")))
				Expect(installVersionOptionsModel.Schematics).To(Equal(deployRequestBodySchematicsModel))
				Expect(installVersionOptionsModel.Script).To(Equal(core.StringPtr("testString")))
				Expect(installVersionOptionsModel.ScriptID).To(Equal(core.StringPtr("testString")))
				Expect(installVersionOptionsModel.VersionLocatorID).To(Equal(core.StringPtr("testString")))
				Expect(installVersionOptionsModel.VcenterID).To(Equal(core.StringPtr("testString")))
				Expect(installVersionOptionsModel.VcenterLocation).To(Equal(core.StringPtr("testString")))
				Expect(installVersionOptionsModel.VcenterUser).To(Equal(core.StringPtr("testString")))
				Expect(installVersionOptionsModel.VcenterPassword).To(Equal(core.StringPtr("testString")))
				Expect(installVersionOptionsModel.VcenterDatastore).To(Equal(core.StringPtr("testString")))
				Expect(installVersionOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewJSONPatchOperation successfully`, func() {
				op := "add"
				path := "testString"
				_model, err := catalogManagementService.NewJSONPatchOperation(op, path)
				Expect(_model).ToNot(BeNil())
				Expect(err).To(BeNil())
			})
			It(`Invoke NewListCatalogAccountAuditsOptions successfully`, func() {
				// Construct an instance of the ListCatalogAccountAuditsOptions model
				listCatalogAccountAuditsOptionsModel := catalogManagementService.NewListCatalogAccountAuditsOptions()
				listCatalogAccountAuditsOptionsModel.SetStart("testString")
				listCatalogAccountAuditsOptionsModel.SetLimit(int64(10))
				listCatalogAccountAuditsOptionsModel.SetLookupnames(true)
				listCatalogAccountAuditsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listCatalogAccountAuditsOptionsModel).ToNot(BeNil())
				Expect(listCatalogAccountAuditsOptionsModel.Start).To(Equal(core.StringPtr("testString")))
				Expect(listCatalogAccountAuditsOptionsModel.Limit).To(Equal(core.Int64Ptr(int64(10))))
				Expect(listCatalogAccountAuditsOptionsModel.Lookupnames).To(Equal(core.BoolPtr(true)))
				Expect(listCatalogAccountAuditsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListCatalogAuditsOptions successfully`, func() {
				// Construct an instance of the ListCatalogAuditsOptions model
				catalogIdentifier := "testString"
				listCatalogAuditsOptionsModel := catalogManagementService.NewListCatalogAuditsOptions(catalogIdentifier)
				listCatalogAuditsOptionsModel.SetCatalogIdentifier("testString")
				listCatalogAuditsOptionsModel.SetStart("testString")
				listCatalogAuditsOptionsModel.SetLimit(int64(10))
				listCatalogAuditsOptionsModel.SetLookupnames(true)
				listCatalogAuditsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listCatalogAuditsOptionsModel).ToNot(BeNil())
				Expect(listCatalogAuditsOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(listCatalogAuditsOptionsModel.Start).To(Equal(core.StringPtr("testString")))
				Expect(listCatalogAuditsOptionsModel.Limit).To(Equal(core.Int64Ptr(int64(10))))
				Expect(listCatalogAuditsOptionsModel.Lookupnames).To(Equal(core.BoolPtr(true)))
				Expect(listCatalogAuditsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListCatalogsOptions successfully`, func() {
				// Construct an instance of the ListCatalogsOptions model
				listCatalogsOptionsModel := catalogManagementService.NewListCatalogsOptions()
				listCatalogsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listCatalogsOptionsModel).ToNot(BeNil())
				Expect(listCatalogsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListEnterpriseAuditsOptions successfully`, func() {
				// Construct an instance of the ListEnterpriseAuditsOptions model
				enterpriseIdentifier := "testString"
				listEnterpriseAuditsOptionsModel := catalogManagementService.NewListEnterpriseAuditsOptions(enterpriseIdentifier)
				listEnterpriseAuditsOptionsModel.SetEnterpriseIdentifier("testString")
				listEnterpriseAuditsOptionsModel.SetStart("testString")
				listEnterpriseAuditsOptionsModel.SetLimit(int64(10))
				listEnterpriseAuditsOptionsModel.SetLookupnames(true)
				listEnterpriseAuditsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listEnterpriseAuditsOptionsModel).ToNot(BeNil())
				Expect(listEnterpriseAuditsOptionsModel.EnterpriseIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(listEnterpriseAuditsOptionsModel.Start).To(Equal(core.StringPtr("testString")))
				Expect(listEnterpriseAuditsOptionsModel.Limit).To(Equal(core.Int64Ptr(int64(10))))
				Expect(listEnterpriseAuditsOptionsModel.Lookupnames).To(Equal(core.BoolPtr(true)))
				Expect(listEnterpriseAuditsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListObjectAuditsOptions successfully`, func() {
				// Construct an instance of the ListObjectAuditsOptions model
				catalogIdentifier := "testString"
				objectIdentifier := "testString"
				listObjectAuditsOptionsModel := catalogManagementService.NewListObjectAuditsOptions(catalogIdentifier, objectIdentifier)
				listObjectAuditsOptionsModel.SetCatalogIdentifier("testString")
				listObjectAuditsOptionsModel.SetObjectIdentifier("testString")
				listObjectAuditsOptionsModel.SetStart("testString")
				listObjectAuditsOptionsModel.SetLimit(int64(10))
				listObjectAuditsOptionsModel.SetLookupnames(true)
				listObjectAuditsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listObjectAuditsOptionsModel).ToNot(BeNil())
				Expect(listObjectAuditsOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(listObjectAuditsOptionsModel.ObjectIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(listObjectAuditsOptionsModel.Start).To(Equal(core.StringPtr("testString")))
				Expect(listObjectAuditsOptionsModel.Limit).To(Equal(core.Int64Ptr(int64(10))))
				Expect(listObjectAuditsOptionsModel.Lookupnames).To(Equal(core.BoolPtr(true)))
				Expect(listObjectAuditsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListObjectsOptions successfully`, func() {
				// Construct an instance of the ListObjectsOptions model
				catalogIdentifier := "testString"
				listObjectsOptionsModel := catalogManagementService.NewListObjectsOptions(catalogIdentifier)
				listObjectsOptionsModel.SetCatalogIdentifier("testString")
				listObjectsOptionsModel.SetLimit(int64(1000))
				listObjectsOptionsModel.SetOffset(int64(38))
				listObjectsOptionsModel.SetName("testString")
				listObjectsOptionsModel.SetSort("testString")
				listObjectsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listObjectsOptionsModel).ToNot(BeNil())
				Expect(listObjectsOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(listObjectsOptionsModel.Limit).To(Equal(core.Int64Ptr(int64(1000))))
				Expect(listObjectsOptionsModel.Offset).To(Equal(core.Int64Ptr(int64(38))))
				Expect(listObjectsOptionsModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(listObjectsOptionsModel.Sort).To(Equal(core.StringPtr("testString")))
				Expect(listObjectsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListOfferingAuditsOptions successfully`, func() {
				// Construct an instance of the ListOfferingAuditsOptions model
				catalogIdentifier := "testString"
				offeringID := "testString"
				listOfferingAuditsOptionsModel := catalogManagementService.NewListOfferingAuditsOptions(catalogIdentifier, offeringID)
				listOfferingAuditsOptionsModel.SetCatalogIdentifier("testString")
				listOfferingAuditsOptionsModel.SetOfferingID("testString")
				listOfferingAuditsOptionsModel.SetStart("testString")
				listOfferingAuditsOptionsModel.SetLimit(int64(10))
				listOfferingAuditsOptionsModel.SetLookupnames(true)
				listOfferingAuditsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listOfferingAuditsOptionsModel).ToNot(BeNil())
				Expect(listOfferingAuditsOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(listOfferingAuditsOptionsModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(listOfferingAuditsOptionsModel.Start).To(Equal(core.StringPtr("testString")))
				Expect(listOfferingAuditsOptionsModel.Limit).To(Equal(core.Int64Ptr(int64(10))))
				Expect(listOfferingAuditsOptionsModel.Lookupnames).To(Equal(core.BoolPtr(true)))
				Expect(listOfferingAuditsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListOfferingInstanceAuditsOptions successfully`, func() {
				// Construct an instance of the ListOfferingInstanceAuditsOptions model
				instanceIdentifier := "testString"
				listOfferingInstanceAuditsOptionsModel := catalogManagementService.NewListOfferingInstanceAuditsOptions(instanceIdentifier)
				listOfferingInstanceAuditsOptionsModel.SetInstanceIdentifier("testString")
				listOfferingInstanceAuditsOptionsModel.SetStart("testString")
				listOfferingInstanceAuditsOptionsModel.SetLimit(int64(10))
				listOfferingInstanceAuditsOptionsModel.SetLookupnames(true)
				listOfferingInstanceAuditsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listOfferingInstanceAuditsOptionsModel).ToNot(BeNil())
				Expect(listOfferingInstanceAuditsOptionsModel.InstanceIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(listOfferingInstanceAuditsOptionsModel.Start).To(Equal(core.StringPtr("testString")))
				Expect(listOfferingInstanceAuditsOptionsModel.Limit).To(Equal(core.Int64Ptr(int64(10))))
				Expect(listOfferingInstanceAuditsOptionsModel.Lookupnames).To(Equal(core.BoolPtr(true)))
				Expect(listOfferingInstanceAuditsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListOfferingsOptions successfully`, func() {
				// Construct an instance of the ListOfferingsOptions model
				catalogIdentifier := "testString"
				listOfferingsOptionsModel := catalogManagementService.NewListOfferingsOptions(catalogIdentifier)
				listOfferingsOptionsModel.SetCatalogIdentifier("testString")
				listOfferingsOptionsModel.SetDigest(true)
				listOfferingsOptionsModel.SetLimit(int64(1000))
				listOfferingsOptionsModel.SetOffset(int64(38))
				listOfferingsOptionsModel.SetName("testString")
				listOfferingsOptionsModel.SetSort("testString")
				listOfferingsOptionsModel.SetIncludeHidden(true)
				listOfferingsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listOfferingsOptionsModel).ToNot(BeNil())
				Expect(listOfferingsOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(listOfferingsOptionsModel.Digest).To(Equal(core.BoolPtr(true)))
				Expect(listOfferingsOptionsModel.Limit).To(Equal(core.Int64Ptr(int64(1000))))
				Expect(listOfferingsOptionsModel.Offset).To(Equal(core.Int64Ptr(int64(38))))
				Expect(listOfferingsOptionsModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(listOfferingsOptionsModel.Sort).To(Equal(core.StringPtr("testString")))
				Expect(listOfferingsOptionsModel.IncludeHidden).To(Equal(core.BoolPtr(true)))
				Expect(listOfferingsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListOperatorsOptions successfully`, func() {
				// Construct an instance of the ListOperatorsOptions model
				xAuthRefreshToken := "testString"
				clusterID := "testString"
				region := "testString"
				versionLocatorID := "testString"
				listOperatorsOptionsModel := catalogManagementService.NewListOperatorsOptions(xAuthRefreshToken, clusterID, region, versionLocatorID)
				listOperatorsOptionsModel.SetXAuthRefreshToken("testString")
				listOperatorsOptionsModel.SetClusterID("testString")
				listOperatorsOptionsModel.SetRegion("testString")
				listOperatorsOptionsModel.SetVersionLocatorID("testString")
				listOperatorsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listOperatorsOptionsModel).ToNot(BeNil())
				Expect(listOperatorsOptionsModel.XAuthRefreshToken).To(Equal(core.StringPtr("testString")))
				Expect(listOperatorsOptionsModel.ClusterID).To(Equal(core.StringPtr("testString")))
				Expect(listOperatorsOptionsModel.Region).To(Equal(core.StringPtr("testString")))
				Expect(listOperatorsOptionsModel.VersionLocatorID).To(Equal(core.StringPtr("testString")))
				Expect(listOperatorsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewPreinstallVersionOptions successfully`, func() {
				// Construct an instance of the DeployRequestBodyOverrideValues model
				deployRequestBodyOverrideValuesModel := new(catalogmanagementv1.DeployRequestBodyOverrideValues)
				Expect(deployRequestBodyOverrideValuesModel).ToNot(BeNil())
				deployRequestBodyOverrideValuesModel.VsiInstanceName = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCProfile = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SubnetID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SubnetZone = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SSHKeyID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCRegion = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SetProperty("foo", core.StringPtr("testString"))
				Expect(deployRequestBodyOverrideValuesModel.VsiInstanceName).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyOverrideValuesModel.VPCProfile).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyOverrideValuesModel.SubnetID).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyOverrideValuesModel.VPCID).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyOverrideValuesModel.SubnetZone).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyOverrideValuesModel.SSHKeyID).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyOverrideValuesModel.VPCRegion).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyOverrideValuesModel.GetProperties()).ToNot(BeEmpty())
				Expect(deployRequestBodyOverrideValuesModel.GetProperty("foo")).To(Equal(core.StringPtr("testString")))

				deployRequestBodyOverrideValuesModel.SetProperties(nil)
				Expect(deployRequestBodyOverrideValuesModel.GetProperties()).To(BeEmpty())

				deployRequestBodyOverrideValuesModelExpectedMap := make(map[string]interface{})
				deployRequestBodyOverrideValuesModelExpectedMap["foo"] = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SetProperties(deployRequestBodyOverrideValuesModelExpectedMap)
				deployRequestBodyOverrideValuesModelActualMap := deployRequestBodyOverrideValuesModel.GetProperties()
				Expect(deployRequestBodyOverrideValuesModelActualMap).To(Equal(deployRequestBodyOverrideValuesModelExpectedMap))

				// Construct an instance of the DeployRequestBodyEnvironmentVariablesItem model
				deployRequestBodyEnvironmentVariablesItemModel := new(catalogmanagementv1.DeployRequestBodyEnvironmentVariablesItem)
				Expect(deployRequestBodyEnvironmentVariablesItemModel).ToNot(BeNil())
				deployRequestBodyEnvironmentVariablesItemModel.Name = core.StringPtr("testString")
				deployRequestBodyEnvironmentVariablesItemModel.Value = core.StringPtr("testString")
				deployRequestBodyEnvironmentVariablesItemModel.Secure = core.BoolPtr(true)
				Expect(deployRequestBodyEnvironmentVariablesItemModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyEnvironmentVariablesItemModel.Value).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyEnvironmentVariablesItemModel.Secure).To(Equal(core.BoolPtr(true)))

				// Construct an instance of the DeployRequestBodySchematics model
				deployRequestBodySchematicsModel := new(catalogmanagementv1.DeployRequestBodySchematics)
				Expect(deployRequestBodySchematicsModel).ToNot(BeNil())
				deployRequestBodySchematicsModel.Name = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Description = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Tags = []string{"testString"}
				deployRequestBodySchematicsModel.ResourceGroupID = core.StringPtr("testString")
				deployRequestBodySchematicsModel.TerraformVersion = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Region = core.StringPtr("testString")
				Expect(deployRequestBodySchematicsModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodySchematicsModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodySchematicsModel.Tags).To(Equal([]string{"testString"}))
				Expect(deployRequestBodySchematicsModel.ResourceGroupID).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodySchematicsModel.TerraformVersion).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodySchematicsModel.Region).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the PreinstallVersionOptions model
				versionLocID := "testString"
				xAuthRefreshToken := "testString"
				preinstallVersionOptionsModel := catalogManagementService.NewPreinstallVersionOptions(versionLocID, xAuthRefreshToken)
				preinstallVersionOptionsModel.SetVersionLocID("testString")
				preinstallVersionOptionsModel.SetXAuthRefreshToken("testString")
				preinstallVersionOptionsModel.SetClusterID("testString")
				preinstallVersionOptionsModel.SetRegion("testString")
				preinstallVersionOptionsModel.SetNamespace("testString")
				preinstallVersionOptionsModel.SetOverrideValues(deployRequestBodyOverrideValuesModel)
				preinstallVersionOptionsModel.SetEnvironmentVariables([]catalogmanagementv1.DeployRequestBodyEnvironmentVariablesItem{*deployRequestBodyEnvironmentVariablesItemModel})
				preinstallVersionOptionsModel.SetEntitlementApikey("testString")
				preinstallVersionOptionsModel.SetSchematics(deployRequestBodySchematicsModel)
				preinstallVersionOptionsModel.SetScript("testString")
				preinstallVersionOptionsModel.SetScriptID("testString")
				preinstallVersionOptionsModel.SetVersionLocatorID("testString")
				preinstallVersionOptionsModel.SetVcenterID("testString")
				preinstallVersionOptionsModel.SetVcenterLocation("testString")
				preinstallVersionOptionsModel.SetVcenterUser("testString")
				preinstallVersionOptionsModel.SetVcenterPassword("testString")
				preinstallVersionOptionsModel.SetVcenterDatastore("testString")
				preinstallVersionOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(preinstallVersionOptionsModel).ToNot(BeNil())
				Expect(preinstallVersionOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(preinstallVersionOptionsModel.XAuthRefreshToken).To(Equal(core.StringPtr("testString")))
				Expect(preinstallVersionOptionsModel.ClusterID).To(Equal(core.StringPtr("testString")))
				Expect(preinstallVersionOptionsModel.Region).To(Equal(core.StringPtr("testString")))
				Expect(preinstallVersionOptionsModel.Namespace).To(Equal(core.StringPtr("testString")))
				Expect(preinstallVersionOptionsModel.OverrideValues).To(Equal(deployRequestBodyOverrideValuesModel))
				Expect(preinstallVersionOptionsModel.EnvironmentVariables).To(Equal([]catalogmanagementv1.DeployRequestBodyEnvironmentVariablesItem{*deployRequestBodyEnvironmentVariablesItemModel}))
				Expect(preinstallVersionOptionsModel.EntitlementApikey).To(Equal(core.StringPtr("testString")))
				Expect(preinstallVersionOptionsModel.Schematics).To(Equal(deployRequestBodySchematicsModel))
				Expect(preinstallVersionOptionsModel.Script).To(Equal(core.StringPtr("testString")))
				Expect(preinstallVersionOptionsModel.ScriptID).To(Equal(core.StringPtr("testString")))
				Expect(preinstallVersionOptionsModel.VersionLocatorID).To(Equal(core.StringPtr("testString")))
				Expect(preinstallVersionOptionsModel.VcenterID).To(Equal(core.StringPtr("testString")))
				Expect(preinstallVersionOptionsModel.VcenterLocation).To(Equal(core.StringPtr("testString")))
				Expect(preinstallVersionOptionsModel.VcenterUser).To(Equal(core.StringPtr("testString")))
				Expect(preinstallVersionOptionsModel.VcenterPassword).To(Equal(core.StringPtr("testString")))
				Expect(preinstallVersionOptionsModel.VcenterDatastore).To(Equal(core.StringPtr("testString")))
				Expect(preinstallVersionOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewPublicPublishObjectOptions successfully`, func() {
				// Construct an instance of the PublicPublishObjectOptions model
				catalogIdentifier := "testString"
				objectIdentifier := "testString"
				publicPublishObjectOptionsModel := catalogManagementService.NewPublicPublishObjectOptions(catalogIdentifier, objectIdentifier)
				publicPublishObjectOptionsModel.SetCatalogIdentifier("testString")
				publicPublishObjectOptionsModel.SetObjectIdentifier("testString")
				publicPublishObjectOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(publicPublishObjectOptionsModel).ToNot(BeNil())
				Expect(publicPublishObjectOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(publicPublishObjectOptionsModel.ObjectIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(publicPublishObjectOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewPublicPublishVersionOptions successfully`, func() {
				// Construct an instance of the PublicPublishVersionOptions model
				versionLocID := "testString"
				publicPublishVersionOptionsModel := catalogManagementService.NewPublicPublishVersionOptions(versionLocID)
				publicPublishVersionOptionsModel.SetVersionLocID("testString")
				publicPublishVersionOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(publicPublishVersionOptionsModel).ToNot(BeNil())
				Expect(publicPublishVersionOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(publicPublishVersionOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewPutOfferingInstanceOptions successfully`, func() {
				// Construct an instance of the OfferingInstanceLastOperation model
				offeringInstanceLastOperationModel := new(catalogmanagementv1.OfferingInstanceLastOperation)
				Expect(offeringInstanceLastOperationModel).ToNot(BeNil())
				offeringInstanceLastOperationModel.Operation = core.StringPtr("testString")
				offeringInstanceLastOperationModel.State = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Message = core.StringPtr("testString")
				offeringInstanceLastOperationModel.TransactionID = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				offeringInstanceLastOperationModel.Code = core.StringPtr("testString")
				Expect(offeringInstanceLastOperationModel.Operation).To(Equal(core.StringPtr("testString")))
				Expect(offeringInstanceLastOperationModel.State).To(Equal(core.StringPtr("testString")))
				Expect(offeringInstanceLastOperationModel.Message).To(Equal(core.StringPtr("testString")))
				Expect(offeringInstanceLastOperationModel.TransactionID).To(Equal(core.StringPtr("testString")))
				Expect(offeringInstanceLastOperationModel.Updated).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(offeringInstanceLastOperationModel.Code).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the PutOfferingInstanceOptions model
				instanceIdentifier := "testString"
				xAuthRefreshToken := "testString"
				putOfferingInstanceOptionsModel := catalogManagementService.NewPutOfferingInstanceOptions(instanceIdentifier, xAuthRefreshToken)
				putOfferingInstanceOptionsModel.SetInstanceIdentifier("testString")
				putOfferingInstanceOptionsModel.SetXAuthRefreshToken("testString")
				putOfferingInstanceOptionsModel.SetID("testString")
				putOfferingInstanceOptionsModel.SetRev("testString")
				putOfferingInstanceOptionsModel.SetURL("testString")
				putOfferingInstanceOptionsModel.SetCRN("testString")
				putOfferingInstanceOptionsModel.SetLabel("testString")
				putOfferingInstanceOptionsModel.SetCatalogID("testString")
				putOfferingInstanceOptionsModel.SetOfferingID("testString")
				putOfferingInstanceOptionsModel.SetKindFormat("testString")
				putOfferingInstanceOptionsModel.SetVersion("testString")
				putOfferingInstanceOptionsModel.SetVersionID("testString")
				putOfferingInstanceOptionsModel.SetClusterID("testString")
				putOfferingInstanceOptionsModel.SetClusterRegion("testString")
				putOfferingInstanceOptionsModel.SetClusterNamespaces([]string{"testString"})
				putOfferingInstanceOptionsModel.SetClusterAllNamespaces(true)
				putOfferingInstanceOptionsModel.SetSchematicsWorkspaceID("testString")
				putOfferingInstanceOptionsModel.SetInstallPlan("testString")
				putOfferingInstanceOptionsModel.SetChannel("testString")
				putOfferingInstanceOptionsModel.SetCreated(CreateMockDateTime("2019-01-01T12:00:00.000Z"))
				putOfferingInstanceOptionsModel.SetUpdated(CreateMockDateTime("2019-01-01T12:00:00.000Z"))
				putOfferingInstanceOptionsModel.SetMetadata(make(map[string]interface{}))
				putOfferingInstanceOptionsModel.SetResourceGroupID("testString")
				putOfferingInstanceOptionsModel.SetLocation("testString")
				putOfferingInstanceOptionsModel.SetDisabled(true)
				putOfferingInstanceOptionsModel.SetAccount("testString")
				putOfferingInstanceOptionsModel.SetLastOperation(offeringInstanceLastOperationModel)
				putOfferingInstanceOptionsModel.SetKindTarget("testString")
				putOfferingInstanceOptionsModel.SetSha("testString")
				putOfferingInstanceOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(putOfferingInstanceOptionsModel).ToNot(BeNil())
				Expect(putOfferingInstanceOptionsModel.InstanceIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.XAuthRefreshToken).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.Rev).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.URL).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.CRN).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.KindFormat).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.Version).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.VersionID).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.ClusterID).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.ClusterRegion).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.ClusterNamespaces).To(Equal([]string{"testString"}))
				Expect(putOfferingInstanceOptionsModel.ClusterAllNamespaces).To(Equal(core.BoolPtr(true)))
				Expect(putOfferingInstanceOptionsModel.SchematicsWorkspaceID).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.InstallPlan).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.Channel).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.Created).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(putOfferingInstanceOptionsModel.Updated).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(putOfferingInstanceOptionsModel.Metadata).To(Equal(make(map[string]interface{})))
				Expect(putOfferingInstanceOptionsModel.ResourceGroupID).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.Location).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.Disabled).To(Equal(core.BoolPtr(true)))
				Expect(putOfferingInstanceOptionsModel.Account).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.LastOperation).To(Equal(offeringInstanceLastOperationModel))
				Expect(putOfferingInstanceOptionsModel.KindTarget).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.Sha).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewReloadOfferingOptions successfully`, func() {
				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				Expect(flavorModel).ToNot(BeNil())
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = make(map[string]string)
				flavorModel.Index = core.Int64Ptr(int64(38))
				Expect(flavorModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(flavorModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(flavorModel.LabelI18n).To(Equal(make(map[string]string)))
				Expect(flavorModel.Index).To(Equal(core.Int64Ptr(int64(38))))

				// Construct an instance of the ReloadOfferingOptions model
				catalogIdentifier := "testString"
				offeringID := "testString"
				targetVersion := "testString"
				reloadOfferingOptionsModel := catalogManagementService.NewReloadOfferingOptions(catalogIdentifier, offeringID, targetVersion)
				reloadOfferingOptionsModel.SetCatalogIdentifier("testString")
				reloadOfferingOptionsModel.SetOfferingID("testString")
				reloadOfferingOptionsModel.SetTargetVersion("testString")
				reloadOfferingOptionsModel.SetTags([]string{"testString"})
				reloadOfferingOptionsModel.SetContent(*CreateMockByteArray("This is a mock byte array value."))
				reloadOfferingOptionsModel.SetTargetKinds([]string{"testString"})
				reloadOfferingOptionsModel.SetFormatKind("testString")
				reloadOfferingOptionsModel.SetFlavor(flavorModel)
				reloadOfferingOptionsModel.SetWorkingDirectory("testString")
				reloadOfferingOptionsModel.SetZipurl("testString")
				reloadOfferingOptionsModel.SetRepoType("testString")
				reloadOfferingOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(reloadOfferingOptionsModel).ToNot(BeNil())
				Expect(reloadOfferingOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(reloadOfferingOptionsModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(reloadOfferingOptionsModel.TargetVersion).To(Equal(core.StringPtr("testString")))
				Expect(reloadOfferingOptionsModel.Tags).To(Equal([]string{"testString"}))
				Expect(reloadOfferingOptionsModel.Content).To(Equal(CreateMockByteArray("This is a mock byte array value.")))
				Expect(reloadOfferingOptionsModel.TargetKinds).To(Equal([]string{"testString"}))
				Expect(reloadOfferingOptionsModel.FormatKind).To(Equal(core.StringPtr("testString")))
				Expect(reloadOfferingOptionsModel.Flavor).To(Equal(flavorModel))
				Expect(reloadOfferingOptionsModel.WorkingDirectory).To(Equal(core.StringPtr("testString")))
				Expect(reloadOfferingOptionsModel.Zipurl).To(Equal(core.StringPtr("testString")))
				Expect(reloadOfferingOptionsModel.RepoType).To(Equal(core.StringPtr("testString")))
				Expect(reloadOfferingOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewReplaceCatalogOptions successfully`, func() {
				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				Expect(featureModel).ToNot(BeNil())
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = make(map[string]string)
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = make(map[string]string)
				Expect(featureModel.Title).To(Equal(core.StringPtr("testString")))
				Expect(featureModel.TitleI18n).To(Equal(make(map[string]string)))
				Expect(featureModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(featureModel.DescriptionI18n).To(Equal(make(map[string]string)))

				// Construct an instance of the FilterTerms model
				filterTermsModel := new(catalogmanagementv1.FilterTerms)
				Expect(filterTermsModel).ToNot(BeNil())
				filterTermsModel.FilterTerms = []string{"testString"}
				Expect(filterTermsModel.FilterTerms).To(Equal([]string{"testString"}))

				// Construct an instance of the CategoryFilter model
				categoryFilterModel := new(catalogmanagementv1.CategoryFilter)
				Expect(categoryFilterModel).ToNot(BeNil())
				categoryFilterModel.Include = core.BoolPtr(true)
				categoryFilterModel.Filter = filterTermsModel
				Expect(categoryFilterModel.Include).To(Equal(core.BoolPtr(true)))
				Expect(categoryFilterModel.Filter).To(Equal(filterTermsModel))

				// Construct an instance of the IDFilter model
				idFilterModel := new(catalogmanagementv1.IDFilter)
				Expect(idFilterModel).ToNot(BeNil())
				idFilterModel.Include = filterTermsModel
				idFilterModel.Exclude = filterTermsModel
				Expect(idFilterModel.Include).To(Equal(filterTermsModel))
				Expect(idFilterModel.Exclude).To(Equal(filterTermsModel))

				// Construct an instance of the Filters model
				filtersModel := new(catalogmanagementv1.Filters)
				Expect(filtersModel).ToNot(BeNil())
				filtersModel.IncludeAll = core.BoolPtr(true)
				filtersModel.CategoryFilters = make(map[string]catalogmanagementv1.CategoryFilter)
				filtersModel.IDFilters = idFilterModel
				filtersModel.CategoryFilters["foo"] = *categoryFilterModel
				Expect(filtersModel.IncludeAll).To(Equal(core.BoolPtr(true)))
				Expect(filtersModel.IDFilters).To(Equal(idFilterModel))
				Expect(filtersModel.CategoryFilters["foo"]).To(Equal(*categoryFilterModel))

				// Construct an instance of the SyndicationCluster model
				syndicationClusterModel := new(catalogmanagementv1.SyndicationCluster)
				Expect(syndicationClusterModel).ToNot(BeNil())
				syndicationClusterModel.Region = core.StringPtr("testString")
				syndicationClusterModel.ID = core.StringPtr("testString")
				syndicationClusterModel.Name = core.StringPtr("testString")
				syndicationClusterModel.ResourceGroupName = core.StringPtr("testString")
				syndicationClusterModel.Type = core.StringPtr("testString")
				syndicationClusterModel.Namespaces = []string{"testString"}
				syndicationClusterModel.AllNamespaces = core.BoolPtr(true)
				Expect(syndicationClusterModel.Region).To(Equal(core.StringPtr("testString")))
				Expect(syndicationClusterModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(syndicationClusterModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(syndicationClusterModel.ResourceGroupName).To(Equal(core.StringPtr("testString")))
				Expect(syndicationClusterModel.Type).To(Equal(core.StringPtr("testString")))
				Expect(syndicationClusterModel.Namespaces).To(Equal([]string{"testString"}))
				Expect(syndicationClusterModel.AllNamespaces).To(Equal(core.BoolPtr(true)))

				// Construct an instance of the SyndicationHistory model
				syndicationHistoryModel := new(catalogmanagementv1.SyndicationHistory)
				Expect(syndicationHistoryModel).ToNot(BeNil())
				syndicationHistoryModel.Namespaces = []string{"testString"}
				syndicationHistoryModel.Clusters = []catalogmanagementv1.SyndicationCluster{*syndicationClusterModel}
				syndicationHistoryModel.LastRun = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				Expect(syndicationHistoryModel.Namespaces).To(Equal([]string{"testString"}))
				Expect(syndicationHistoryModel.Clusters).To(Equal([]catalogmanagementv1.SyndicationCluster{*syndicationClusterModel}))
				Expect(syndicationHistoryModel.LastRun).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))

				// Construct an instance of the SyndicationAuthorization model
				syndicationAuthorizationModel := new(catalogmanagementv1.SyndicationAuthorization)
				Expect(syndicationAuthorizationModel).ToNot(BeNil())
				syndicationAuthorizationModel.Token = core.StringPtr("testString")
				syndicationAuthorizationModel.LastRun = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				Expect(syndicationAuthorizationModel.Token).To(Equal(core.StringPtr("testString")))
				Expect(syndicationAuthorizationModel.LastRun).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))

				// Construct an instance of the SyndicationResource model
				syndicationResourceModel := new(catalogmanagementv1.SyndicationResource)
				Expect(syndicationResourceModel).ToNot(BeNil())
				syndicationResourceModel.RemoveRelatedComponents = core.BoolPtr(true)
				syndicationResourceModel.Clusters = []catalogmanagementv1.SyndicationCluster{*syndicationClusterModel}
				syndicationResourceModel.History = syndicationHistoryModel
				syndicationResourceModel.Authorization = syndicationAuthorizationModel
				Expect(syndicationResourceModel.RemoveRelatedComponents).To(Equal(core.BoolPtr(true)))
				Expect(syndicationResourceModel.Clusters).To(Equal([]catalogmanagementv1.SyndicationCluster{*syndicationClusterModel}))
				Expect(syndicationResourceModel.History).To(Equal(syndicationHistoryModel))
				Expect(syndicationResourceModel.Authorization).To(Equal(syndicationAuthorizationModel))

				// Construct an instance of the ReplaceCatalogOptions model
				catalogIdentifier := "testString"
				replaceCatalogOptionsModel := catalogManagementService.NewReplaceCatalogOptions(catalogIdentifier)
				replaceCatalogOptionsModel.SetCatalogIdentifier("testString")
				replaceCatalogOptionsModel.SetID("testString")
				replaceCatalogOptionsModel.SetRev("testString")
				replaceCatalogOptionsModel.SetLabel("testString")
				replaceCatalogOptionsModel.SetLabelI18n(make(map[string]string))
				replaceCatalogOptionsModel.SetShortDescription("testString")
				replaceCatalogOptionsModel.SetShortDescriptionI18n(make(map[string]string))
				replaceCatalogOptionsModel.SetCatalogIconURL("testString")
				replaceCatalogOptionsModel.SetTags([]string{"testString"})
				replaceCatalogOptionsModel.SetFeatures([]catalogmanagementv1.Feature{*featureModel})
				replaceCatalogOptionsModel.SetDisabled(true)
				replaceCatalogOptionsModel.SetResourceGroupID("testString")
				replaceCatalogOptionsModel.SetOwningAccount("testString")
				replaceCatalogOptionsModel.SetCatalogFilters(filtersModel)
				replaceCatalogOptionsModel.SetSyndicationSettings(syndicationResourceModel)
				replaceCatalogOptionsModel.SetKind("testString")
				replaceCatalogOptionsModel.SetMetadata(make(map[string]interface{}))
				replaceCatalogOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(replaceCatalogOptionsModel).ToNot(BeNil())
				Expect(replaceCatalogOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(replaceCatalogOptionsModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(replaceCatalogOptionsModel.Rev).To(Equal(core.StringPtr("testString")))
				Expect(replaceCatalogOptionsModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(replaceCatalogOptionsModel.LabelI18n).To(Equal(make(map[string]string)))
				Expect(replaceCatalogOptionsModel.ShortDescription).To(Equal(core.StringPtr("testString")))
				Expect(replaceCatalogOptionsModel.ShortDescriptionI18n).To(Equal(make(map[string]string)))
				Expect(replaceCatalogOptionsModel.CatalogIconURL).To(Equal(core.StringPtr("testString")))
				Expect(replaceCatalogOptionsModel.Tags).To(Equal([]string{"testString"}))
				Expect(replaceCatalogOptionsModel.Features).To(Equal([]catalogmanagementv1.Feature{*featureModel}))
				Expect(replaceCatalogOptionsModel.Disabled).To(Equal(core.BoolPtr(true)))
				Expect(replaceCatalogOptionsModel.ResourceGroupID).To(Equal(core.StringPtr("testString")))
				Expect(replaceCatalogOptionsModel.OwningAccount).To(Equal(core.StringPtr("testString")))
				Expect(replaceCatalogOptionsModel.CatalogFilters).To(Equal(filtersModel))
				Expect(replaceCatalogOptionsModel.SyndicationSettings).To(Equal(syndicationResourceModel))
				Expect(replaceCatalogOptionsModel.Kind).To(Equal(core.StringPtr("testString")))
				Expect(replaceCatalogOptionsModel.Metadata).To(Equal(make(map[string]interface{})))
				Expect(replaceCatalogOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewReplaceObjectOptions successfully`, func() {
				// Construct an instance of the PublishObject model
				publishObjectModel := new(catalogmanagementv1.PublishObject)
				Expect(publishObjectModel).ToNot(BeNil())
				publishObjectModel.PermitIBMPublicPublish = core.BoolPtr(true)
				publishObjectModel.IBMApproved = core.BoolPtr(true)
				publishObjectModel.PublicApproved = core.BoolPtr(true)
				publishObjectModel.PortalApprovalRecord = core.StringPtr("testString")
				publishObjectModel.PortalURL = core.StringPtr("testString")
				Expect(publishObjectModel.PermitIBMPublicPublish).To(Equal(core.BoolPtr(true)))
				Expect(publishObjectModel.IBMApproved).To(Equal(core.BoolPtr(true)))
				Expect(publishObjectModel.PublicApproved).To(Equal(core.BoolPtr(true)))
				Expect(publishObjectModel.PortalApprovalRecord).To(Equal(core.StringPtr("testString")))
				Expect(publishObjectModel.PortalURL).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				Expect(stateModel).ToNot(BeNil())
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")
				Expect(stateModel.Current).To(Equal(core.StringPtr("testString")))
				Expect(stateModel.CurrentEntered).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(stateModel.Pending).To(Equal(core.StringPtr("testString")))
				Expect(stateModel.PendingRequested).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(stateModel.Previous).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the ReplaceObjectOptions model
				catalogIdentifier := "testString"
				objectIdentifier := "testString"
				replaceObjectOptionsModel := catalogManagementService.NewReplaceObjectOptions(catalogIdentifier, objectIdentifier)
				replaceObjectOptionsModel.SetCatalogIdentifier("testString")
				replaceObjectOptionsModel.SetObjectIdentifier("testString")
				replaceObjectOptionsModel.SetID("testString")
				replaceObjectOptionsModel.SetName("testString")
				replaceObjectOptionsModel.SetRev("testString")
				replaceObjectOptionsModel.SetCRN("testString")
				replaceObjectOptionsModel.SetURL("testString")
				replaceObjectOptionsModel.SetParentID("testString")
				replaceObjectOptionsModel.SetLabelI18n(make(map[string]string))
				replaceObjectOptionsModel.SetLabel("testString")
				replaceObjectOptionsModel.SetTags([]string{"testString"})
				replaceObjectOptionsModel.SetCreated(CreateMockDateTime("2019-01-01T12:00:00.000Z"))
				replaceObjectOptionsModel.SetUpdated(CreateMockDateTime("2019-01-01T12:00:00.000Z"))
				replaceObjectOptionsModel.SetShortDescription("testString")
				replaceObjectOptionsModel.SetShortDescriptionI18n(make(map[string]string))
				replaceObjectOptionsModel.SetKind("testString")
				replaceObjectOptionsModel.SetPublish(publishObjectModel)
				replaceObjectOptionsModel.SetState(stateModel)
				replaceObjectOptionsModel.SetCatalogID("testString")
				replaceObjectOptionsModel.SetCatalogName("testString")
				replaceObjectOptionsModel.SetData(make(map[string]interface{}))
				replaceObjectOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(replaceObjectOptionsModel).ToNot(BeNil())
				Expect(replaceObjectOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(replaceObjectOptionsModel.ObjectIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(replaceObjectOptionsModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(replaceObjectOptionsModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(replaceObjectOptionsModel.Rev).To(Equal(core.StringPtr("testString")))
				Expect(replaceObjectOptionsModel.CRN).To(Equal(core.StringPtr("testString")))
				Expect(replaceObjectOptionsModel.URL).To(Equal(core.StringPtr("testString")))
				Expect(replaceObjectOptionsModel.ParentID).To(Equal(core.StringPtr("testString")))
				Expect(replaceObjectOptionsModel.LabelI18n).To(Equal(make(map[string]string)))
				Expect(replaceObjectOptionsModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(replaceObjectOptionsModel.Tags).To(Equal([]string{"testString"}))
				Expect(replaceObjectOptionsModel.Created).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(replaceObjectOptionsModel.Updated).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(replaceObjectOptionsModel.ShortDescription).To(Equal(core.StringPtr("testString")))
				Expect(replaceObjectOptionsModel.ShortDescriptionI18n).To(Equal(make(map[string]string)))
				Expect(replaceObjectOptionsModel.Kind).To(Equal(core.StringPtr("testString")))
				Expect(replaceObjectOptionsModel.Publish).To(Equal(publishObjectModel))
				Expect(replaceObjectOptionsModel.State).To(Equal(stateModel))
				Expect(replaceObjectOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(replaceObjectOptionsModel.CatalogName).To(Equal(core.StringPtr("testString")))
				Expect(replaceObjectOptionsModel.Data).To(Equal(make(map[string]interface{})))
				Expect(replaceObjectOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewReplaceOfferingOptions successfully`, func() {
				// Construct an instance of the Rating model
				ratingModel := new(catalogmanagementv1.Rating)
				Expect(ratingModel).ToNot(BeNil())
				ratingModel.OneStarCount = core.Int64Ptr(int64(38))
				ratingModel.TwoStarCount = core.Int64Ptr(int64(38))
				ratingModel.ThreeStarCount = core.Int64Ptr(int64(38))
				ratingModel.FourStarCount = core.Int64Ptr(int64(38))
				Expect(ratingModel.OneStarCount).To(Equal(core.Int64Ptr(int64(38))))
				Expect(ratingModel.TwoStarCount).To(Equal(core.Int64Ptr(int64(38))))
				Expect(ratingModel.ThreeStarCount).To(Equal(core.Int64Ptr(int64(38))))
				Expect(ratingModel.FourStarCount).To(Equal(core.Int64Ptr(int64(38))))

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				Expect(featureModel).ToNot(BeNil())
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = make(map[string]string)
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = make(map[string]string)
				Expect(featureModel.Title).To(Equal(core.StringPtr("testString")))
				Expect(featureModel.TitleI18n).To(Equal(make(map[string]string)))
				Expect(featureModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(featureModel.DescriptionI18n).To(Equal(make(map[string]string)))

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				Expect(flavorModel).ToNot(BeNil())
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = make(map[string]string)
				flavorModel.Index = core.Int64Ptr(int64(38))
				Expect(flavorModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(flavorModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(flavorModel.LabelI18n).To(Equal(make(map[string]string)))
				Expect(flavorModel.Index).To(Equal(core.Int64Ptr(int64(38))))

				// Construct an instance of the RenderTypeAssociationsParametersItem model
				renderTypeAssociationsParametersItemModel := new(catalogmanagementv1.RenderTypeAssociationsParametersItem)
				Expect(renderTypeAssociationsParametersItemModel).ToNot(BeNil())
				renderTypeAssociationsParametersItemModel.Name = core.StringPtr("testString")
				renderTypeAssociationsParametersItemModel.OptionsRefresh = core.BoolPtr(true)
				Expect(renderTypeAssociationsParametersItemModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(renderTypeAssociationsParametersItemModel.OptionsRefresh).To(Equal(core.BoolPtr(true)))

				// Construct an instance of the RenderTypeAssociations model
				renderTypeAssociationsModel := new(catalogmanagementv1.RenderTypeAssociations)
				Expect(renderTypeAssociationsModel).ToNot(BeNil())
				renderTypeAssociationsModel.Parameters = []catalogmanagementv1.RenderTypeAssociationsParametersItem{*renderTypeAssociationsParametersItemModel}
				Expect(renderTypeAssociationsModel.Parameters).To(Equal([]catalogmanagementv1.RenderTypeAssociationsParametersItem{*renderTypeAssociationsParametersItemModel}))

				// Construct an instance of the RenderType model
				renderTypeModel := new(catalogmanagementv1.RenderType)
				Expect(renderTypeModel).ToNot(BeNil())
				renderTypeModel.Type = core.StringPtr("testString")
				renderTypeModel.Grouping = core.StringPtr("testString")
				renderTypeModel.OriginalGrouping = core.StringPtr("testString")
				renderTypeModel.GroupingIndex = core.Int64Ptr(int64(38))
				renderTypeModel.ConfigConstraints = map[string]interface{}{"anyKey": "anyValue"}
				renderTypeModel.Associations = renderTypeAssociationsModel
				Expect(renderTypeModel.Type).To(Equal(core.StringPtr("testString")))
				Expect(renderTypeModel.Grouping).To(Equal(core.StringPtr("testString")))
				Expect(renderTypeModel.OriginalGrouping).To(Equal(core.StringPtr("testString")))
				Expect(renderTypeModel.GroupingIndex).To(Equal(core.Int64Ptr(int64(38))))
				Expect(renderTypeModel.ConfigConstraints).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(renderTypeModel.Associations).To(Equal(renderTypeAssociationsModel))

				// Construct an instance of the Configuration model
				configurationModel := new(catalogmanagementv1.Configuration)
				Expect(configurationModel).ToNot(BeNil())
				configurationModel.Key = core.StringPtr("testString")
				configurationModel.Type = core.StringPtr("testString")
				configurationModel.DefaultValue = core.StringPtr("testString")
				configurationModel.DisplayName = core.StringPtr("testString")
				configurationModel.ValueConstraint = core.StringPtr("testString")
				configurationModel.Description = core.StringPtr("testString")
				configurationModel.Required = core.BoolPtr(true)
				configurationModel.Options = []interface{}{"testString"}
				configurationModel.Hidden = core.BoolPtr(true)
				configurationModel.CustomConfig = renderTypeModel
				configurationModel.TypeMetadata = core.StringPtr("testString")
				Expect(configurationModel.Key).To(Equal(core.StringPtr("testString")))
				Expect(configurationModel.Type).To(Equal(core.StringPtr("testString")))
				Expect(configurationModel.DefaultValue).To(Equal(core.StringPtr("testString")))
				Expect(configurationModel.DisplayName).To(Equal(core.StringPtr("testString")))
				Expect(configurationModel.ValueConstraint).To(Equal(core.StringPtr("testString")))
				Expect(configurationModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(configurationModel.Required).To(Equal(core.BoolPtr(true)))
				Expect(configurationModel.Options).To(Equal([]interface{}{"testString"}))
				Expect(configurationModel.Hidden).To(Equal(core.BoolPtr(true)))
				Expect(configurationModel.CustomConfig).To(Equal(renderTypeModel))
				Expect(configurationModel.TypeMetadata).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the Output model
				outputModel := new(catalogmanagementv1.Output)
				Expect(outputModel).ToNot(BeNil())
				outputModel.Key = core.StringPtr("testString")
				outputModel.Description = core.StringPtr("testString")
				Expect(outputModel.Key).To(Equal(core.StringPtr("testString")))
				Expect(outputModel.Description).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the IamResource model
				iamResourceModel := new(catalogmanagementv1.IamResource)
				Expect(iamResourceModel).ToNot(BeNil())
				iamResourceModel.Name = core.StringPtr("testString")
				iamResourceModel.Description = core.StringPtr("testString")
				iamResourceModel.RoleCrns = []string{"testString"}
				Expect(iamResourceModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(iamResourceModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(iamResourceModel.RoleCrns).To(Equal([]string{"testString"}))

				// Construct an instance of the IamPermission model
				iamPermissionModel := new(catalogmanagementv1.IamPermission)
				Expect(iamPermissionModel).ToNot(BeNil())
				iamPermissionModel.ServiceName = core.StringPtr("testString")
				iamPermissionModel.RoleCrns = []string{"testString"}
				iamPermissionModel.Resources = []catalogmanagementv1.IamResource{*iamResourceModel}
				Expect(iamPermissionModel.ServiceName).To(Equal(core.StringPtr("testString")))
				Expect(iamPermissionModel.RoleCrns).To(Equal([]string{"testString"}))
				Expect(iamPermissionModel.Resources).To(Equal([]catalogmanagementv1.IamResource{*iamResourceModel}))

				// Construct an instance of the Validation model
				validationModel := new(catalogmanagementv1.Validation)
				Expect(validationModel).ToNot(BeNil())
				validationModel.Validated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.Requested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.State = core.StringPtr("testString")
				validationModel.LastOperation = core.StringPtr("testString")
				validationModel.Target = make(map[string]interface{})
				validationModel.Message = core.StringPtr("testString")
				Expect(validationModel.Validated).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(validationModel.Requested).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(validationModel.State).To(Equal(core.StringPtr("testString")))
				Expect(validationModel.LastOperation).To(Equal(core.StringPtr("testString")))
				Expect(validationModel.Target).To(Equal(make(map[string]interface{})))
				Expect(validationModel.Message).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the Resource model
				resourceModel := new(catalogmanagementv1.Resource)
				Expect(resourceModel).ToNot(BeNil())
				resourceModel.Type = core.StringPtr("mem")
				resourceModel.Value = core.StringPtr("testString")
				Expect(resourceModel.Type).To(Equal(core.StringPtr("mem")))
				Expect(resourceModel.Value).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the Script model
				scriptModel := new(catalogmanagementv1.Script)
				Expect(scriptModel).ToNot(BeNil())
				scriptModel.Instructions = core.StringPtr("testString")
				scriptModel.InstructionsI18n = make(map[string]string)
				scriptModel.Script = core.StringPtr("testString")
				scriptModel.ScriptPermission = core.StringPtr("testString")
				scriptModel.DeleteScript = core.StringPtr("testString")
				scriptModel.Scope = core.StringPtr("testString")
				Expect(scriptModel.Instructions).To(Equal(core.StringPtr("testString")))
				Expect(scriptModel.InstructionsI18n).To(Equal(make(map[string]string)))
				Expect(scriptModel.Script).To(Equal(core.StringPtr("testString")))
				Expect(scriptModel.ScriptPermission).To(Equal(core.StringPtr("testString")))
				Expect(scriptModel.DeleteScript).To(Equal(core.StringPtr("testString")))
				Expect(scriptModel.Scope).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the VersionEntitlement model
				versionEntitlementModel := new(catalogmanagementv1.VersionEntitlement)
				Expect(versionEntitlementModel).ToNot(BeNil())
				versionEntitlementModel.ProviderName = core.StringPtr("testString")
				versionEntitlementModel.ProviderID = core.StringPtr("testString")
				versionEntitlementModel.ProductID = core.StringPtr("testString")
				versionEntitlementModel.PartNumbers = []string{"testString"}
				versionEntitlementModel.ImageRepoName = core.StringPtr("testString")
				Expect(versionEntitlementModel.ProviderName).To(Equal(core.StringPtr("testString")))
				Expect(versionEntitlementModel.ProviderID).To(Equal(core.StringPtr("testString")))
				Expect(versionEntitlementModel.ProductID).To(Equal(core.StringPtr("testString")))
				Expect(versionEntitlementModel.PartNumbers).To(Equal([]string{"testString"}))
				Expect(versionEntitlementModel.ImageRepoName).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the License model
				licenseModel := new(catalogmanagementv1.License)
				Expect(licenseModel).ToNot(BeNil())
				licenseModel.ID = core.StringPtr("testString")
				licenseModel.Name = core.StringPtr("testString")
				licenseModel.Type = core.StringPtr("testString")
				licenseModel.URL = core.StringPtr("testString")
				licenseModel.Description = core.StringPtr("testString")
				Expect(licenseModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(licenseModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(licenseModel.Type).To(Equal(core.StringPtr("testString")))
				Expect(licenseModel.URL).To(Equal(core.StringPtr("testString")))
				Expect(licenseModel.Description).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				Expect(stateModel).ToNot(BeNil())
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")
				Expect(stateModel.Current).To(Equal(core.StringPtr("testString")))
				Expect(stateModel.CurrentEntered).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(stateModel.Pending).To(Equal(core.StringPtr("testString")))
				Expect(stateModel.PendingRequested).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(stateModel.Previous).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the DeprecatePending model
				deprecatePendingModel := new(catalogmanagementv1.DeprecatePending)
				Expect(deprecatePendingModel).ToNot(BeNil())
				deprecatePendingModel.DeprecateDate = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				deprecatePendingModel.DeprecateState = core.StringPtr("testString")
				deprecatePendingModel.Description = core.StringPtr("testString")
				Expect(deprecatePendingModel.DeprecateDate).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(deprecatePendingModel.DeprecateState).To(Equal(core.StringPtr("testString")))
				Expect(deprecatePendingModel.Description).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the URLProxy model
				urlProxyModel := new(catalogmanagementv1.URLProxy)
				Expect(urlProxyModel).ToNot(BeNil())
				urlProxyModel.URL = core.StringPtr("testString")
				urlProxyModel.Sha = core.StringPtr("testString")
				Expect(urlProxyModel.URL).To(Equal(core.StringPtr("testString")))
				Expect(urlProxyModel.Sha).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the MediaItem model
				mediaItemModel := new(catalogmanagementv1.MediaItem)
				Expect(mediaItemModel).ToNot(BeNil())
				mediaItemModel.URL = core.StringPtr("testString")
				mediaItemModel.APIURL = core.StringPtr("testString")
				mediaItemModel.URLProxy = urlProxyModel
				mediaItemModel.Caption = core.StringPtr("testString")
				mediaItemModel.CaptionI18n = make(map[string]string)
				mediaItemModel.Type = core.StringPtr("testString")
				mediaItemModel.ThumbnailURL = core.StringPtr("testString")
				Expect(mediaItemModel.URL).To(Equal(core.StringPtr("testString")))
				Expect(mediaItemModel.APIURL).To(Equal(core.StringPtr("testString")))
				Expect(mediaItemModel.URLProxy).To(Equal(urlProxyModel))
				Expect(mediaItemModel.Caption).To(Equal(core.StringPtr("testString")))
				Expect(mediaItemModel.CaptionI18n).To(Equal(make(map[string]string)))
				Expect(mediaItemModel.Type).To(Equal(core.StringPtr("testString")))
				Expect(mediaItemModel.ThumbnailURL).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the ArchitectureDiagram model
				architectureDiagramModel := new(catalogmanagementv1.ArchitectureDiagram)
				Expect(architectureDiagramModel).ToNot(BeNil())
				architectureDiagramModel.Diagram = mediaItemModel
				architectureDiagramModel.Description = core.StringPtr("testString")
				architectureDiagramModel.DescriptionI18n = make(map[string]string)
				Expect(architectureDiagramModel.Diagram).To(Equal(mediaItemModel))
				Expect(architectureDiagramModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(architectureDiagramModel.DescriptionI18n).To(Equal(make(map[string]string)))

				// Construct an instance of the CostComponent model
				costComponentModel := new(catalogmanagementv1.CostComponent)
				Expect(costComponentModel).ToNot(BeNil())
				costComponentModel.Name = core.StringPtr("testString")
				costComponentModel.Unit = core.StringPtr("testString")
				costComponentModel.HourlyQuantity = core.StringPtr("testString")
				costComponentModel.MonthlyQuantity = core.StringPtr("testString")
				costComponentModel.Price = core.StringPtr("testString")
				costComponentModel.HourlyCost = core.StringPtr("testString")
				costComponentModel.MonthlyCost = core.StringPtr("testString")
				Expect(costComponentModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(costComponentModel.Unit).To(Equal(core.StringPtr("testString")))
				Expect(costComponentModel.HourlyQuantity).To(Equal(core.StringPtr("testString")))
				Expect(costComponentModel.MonthlyQuantity).To(Equal(core.StringPtr("testString")))
				Expect(costComponentModel.Price).To(Equal(core.StringPtr("testString")))
				Expect(costComponentModel.HourlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costComponentModel.MonthlyCost).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the CostResource model
				costResourceModel := new(catalogmanagementv1.CostResource)
				Expect(costResourceModel).ToNot(BeNil())
				costResourceModel.Name = core.StringPtr("testString")
				costResourceModel.Metadata = make(map[string]interface{})
				costResourceModel.HourlyCost = core.StringPtr("testString")
				costResourceModel.MonthlyCost = core.StringPtr("testString")
				costResourceModel.CostComponents = []catalogmanagementv1.CostComponent{*costComponentModel}
				Expect(costResourceModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(costResourceModel.Metadata).To(Equal(make(map[string]interface{})))
				Expect(costResourceModel.HourlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costResourceModel.MonthlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costResourceModel.CostComponents).To(Equal([]catalogmanagementv1.CostComponent{*costComponentModel}))

				// Construct an instance of the CostBreakdown model
				costBreakdownModel := new(catalogmanagementv1.CostBreakdown)
				Expect(costBreakdownModel).ToNot(BeNil())
				costBreakdownModel.TotalHourlyCost = core.StringPtr("testString")
				costBreakdownModel.TotalMonthlyCOst = core.StringPtr("testString")
				costBreakdownModel.Resources = []catalogmanagementv1.CostResource{*costResourceModel}
				Expect(costBreakdownModel.TotalHourlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costBreakdownModel.TotalMonthlyCOst).To(Equal(core.StringPtr("testString")))
				Expect(costBreakdownModel.Resources).To(Equal([]catalogmanagementv1.CostResource{*costResourceModel}))

				// Construct an instance of the CostSummary model
				costSummaryModel := new(catalogmanagementv1.CostSummary)
				Expect(costSummaryModel).ToNot(BeNil())
				costSummaryModel.TotalDetectedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalSupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUnsupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUsageBasedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalNoPriceResources = core.Int64Ptr(int64(38))
				costSummaryModel.UnsupportedResourceCounts = make(map[string]int64)
				costSummaryModel.NoPriceResourceCounts = make(map[string]int64)
				Expect(costSummaryModel.TotalDetectedResources).To(Equal(core.Int64Ptr(int64(38))))
				Expect(costSummaryModel.TotalSupportedResources).To(Equal(core.Int64Ptr(int64(38))))
				Expect(costSummaryModel.TotalUnsupportedResources).To(Equal(core.Int64Ptr(int64(38))))
				Expect(costSummaryModel.TotalUsageBasedResources).To(Equal(core.Int64Ptr(int64(38))))
				Expect(costSummaryModel.TotalNoPriceResources).To(Equal(core.Int64Ptr(int64(38))))
				Expect(costSummaryModel.UnsupportedResourceCounts).To(Equal(make(map[string]int64)))
				Expect(costSummaryModel.NoPriceResourceCounts).To(Equal(make(map[string]int64)))

				// Construct an instance of the Project model
				projectModel := new(catalogmanagementv1.Project)
				Expect(projectModel).ToNot(BeNil())
				projectModel.Name = core.StringPtr("testString")
				projectModel.Metadata = make(map[string]interface{})
				projectModel.PastBreakdown = costBreakdownModel
				projectModel.Breakdown = costBreakdownModel
				projectModel.Diff = costBreakdownModel
				projectModel.Summary = costSummaryModel
				Expect(projectModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(projectModel.Metadata).To(Equal(make(map[string]interface{})))
				Expect(projectModel.PastBreakdown).To(Equal(costBreakdownModel))
				Expect(projectModel.Breakdown).To(Equal(costBreakdownModel))
				Expect(projectModel.Diff).To(Equal(costBreakdownModel))
				Expect(projectModel.Summary).To(Equal(costSummaryModel))

				// Construct an instance of the CostEstimate model
				costEstimateModel := new(catalogmanagementv1.CostEstimate)
				Expect(costEstimateModel).ToNot(BeNil())
				costEstimateModel.Version = core.StringPtr("testString")
				costEstimateModel.Currency = core.StringPtr("testString")
				costEstimateModel.Projects = []catalogmanagementv1.Project{*projectModel}
				costEstimateModel.Summary = costSummaryModel
				costEstimateModel.TotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.TotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.TimeGenerated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				Expect(costEstimateModel.Version).To(Equal(core.StringPtr("testString")))
				Expect(costEstimateModel.Currency).To(Equal(core.StringPtr("testString")))
				Expect(costEstimateModel.Projects).To(Equal([]catalogmanagementv1.Project{*projectModel}))
				Expect(costEstimateModel.Summary).To(Equal(costSummaryModel))
				Expect(costEstimateModel.TotalHourlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costEstimateModel.TotalMonthlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costEstimateModel.PastTotalHourlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costEstimateModel.PastTotalMonthlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costEstimateModel.DiffTotalHourlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costEstimateModel.DiffTotalMonthlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costEstimateModel.TimeGenerated).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))

				// Construct an instance of the Dependency model
				dependencyModel := new(catalogmanagementv1.Dependency)
				Expect(dependencyModel).ToNot(BeNil())
				dependencyModel.CatalogID = core.StringPtr("testString")
				dependencyModel.ID = core.StringPtr("testString")
				dependencyModel.Name = core.StringPtr("testString")
				dependencyModel.Version = core.StringPtr("testString")
				dependencyModel.Flavors = []string{"testString"}
				Expect(dependencyModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(dependencyModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(dependencyModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(dependencyModel.Version).To(Equal(core.StringPtr("testString")))
				Expect(dependencyModel.Flavors).To(Equal([]string{"testString"}))

				// Construct an instance of the SolutionInfo model
				solutionInfoModel := new(catalogmanagementv1.SolutionInfo)
				Expect(solutionInfoModel).ToNot(BeNil())
				solutionInfoModel.ArchitectureDiagrams = []catalogmanagementv1.ArchitectureDiagram{*architectureDiagramModel}
				solutionInfoModel.Features = []catalogmanagementv1.Feature{*featureModel}
				solutionInfoModel.CostEstimate = costEstimateModel
				solutionInfoModel.Dependencies = []catalogmanagementv1.Dependency{*dependencyModel}
				Expect(solutionInfoModel.ArchitectureDiagrams).To(Equal([]catalogmanagementv1.ArchitectureDiagram{*architectureDiagramModel}))
				Expect(solutionInfoModel.Features).To(Equal([]catalogmanagementv1.Feature{*featureModel}))
				Expect(solutionInfoModel.CostEstimate).To(Equal(costEstimateModel))
				Expect(solutionInfoModel.Dependencies).To(Equal([]catalogmanagementv1.Dependency{*dependencyModel}))

				// Construct an instance of the Version model
				versionModel := new(catalogmanagementv1.Version)
				Expect(versionModel).ToNot(BeNil())
				versionModel.ID = core.StringPtr("testString")
				versionModel.Rev = core.StringPtr("testString")
				versionModel.CRN = core.StringPtr("testString")
				versionModel.Version = core.StringPtr("testString")
				versionModel.Flavor = flavorModel
				versionModel.Sha = core.StringPtr("testString")
				versionModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.OfferingID = core.StringPtr("testString")
				versionModel.CatalogID = core.StringPtr("testString")
				versionModel.KindID = core.StringPtr("testString")
				versionModel.Tags = []string{"testString"}
				versionModel.RepoURL = core.StringPtr("testString")
				versionModel.SourceURL = core.StringPtr("testString")
				versionModel.TgzURL = core.StringPtr("testString")
				versionModel.Configuration = []catalogmanagementv1.Configuration{*configurationModel}
				versionModel.Outputs = []catalogmanagementv1.Output{*outputModel}
				versionModel.IamPermissions = []catalogmanagementv1.IamPermission{*iamPermissionModel}
				versionModel.Metadata = make(map[string]interface{})
				versionModel.Validation = validationModel
				versionModel.RequiredResources = []catalogmanagementv1.Resource{*resourceModel}
				versionModel.SingleInstance = core.BoolPtr(true)
				versionModel.Install = scriptModel
				versionModel.PreInstall = []catalogmanagementv1.Script{*scriptModel}
				versionModel.Entitlement = versionEntitlementModel
				versionModel.Licenses = []catalogmanagementv1.License{*licenseModel}
				versionModel.ImageManifestURL = core.StringPtr("testString")
				versionModel.Deprecated = core.BoolPtr(true)
				versionModel.PackageVersion = core.StringPtr("testString")
				versionModel.State = stateModel
				versionModel.VersionLocator = core.StringPtr("testString")
				versionModel.LongDescription = core.StringPtr("testString")
				versionModel.LongDescriptionI18n = make(map[string]string)
				versionModel.WhitelistedAccounts = []string{"testString"}
				versionModel.ImagePullKeyName = core.StringPtr("testString")
				versionModel.DeprecatePending = deprecatePendingModel
				versionModel.SolutionInfo = solutionInfoModel
				versionModel.IsConsumable = core.BoolPtr(true)
				Expect(versionModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.Rev).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.CRN).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.Version).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.Flavor).To(Equal(flavorModel))
				Expect(versionModel.Sha).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.Created).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(versionModel.Updated).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(versionModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.KindID).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.Tags).To(Equal([]string{"testString"}))
				Expect(versionModel.RepoURL).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.SourceURL).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.TgzURL).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.Configuration).To(Equal([]catalogmanagementv1.Configuration{*configurationModel}))
				Expect(versionModel.Outputs).To(Equal([]catalogmanagementv1.Output{*outputModel}))
				Expect(versionModel.IamPermissions).To(Equal([]catalogmanagementv1.IamPermission{*iamPermissionModel}))
				Expect(versionModel.Metadata).To(Equal(make(map[string]interface{})))
				Expect(versionModel.Validation).To(Equal(validationModel))
				Expect(versionModel.RequiredResources).To(Equal([]catalogmanagementv1.Resource{*resourceModel}))
				Expect(versionModel.SingleInstance).To(Equal(core.BoolPtr(true)))
				Expect(versionModel.Install).To(Equal(scriptModel))
				Expect(versionModel.PreInstall).To(Equal([]catalogmanagementv1.Script{*scriptModel}))
				Expect(versionModel.Entitlement).To(Equal(versionEntitlementModel))
				Expect(versionModel.Licenses).To(Equal([]catalogmanagementv1.License{*licenseModel}))
				Expect(versionModel.ImageManifestURL).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.Deprecated).To(Equal(core.BoolPtr(true)))
				Expect(versionModel.PackageVersion).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.State).To(Equal(stateModel))
				Expect(versionModel.VersionLocator).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.LongDescription).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.LongDescriptionI18n).To(Equal(make(map[string]string)))
				Expect(versionModel.WhitelistedAccounts).To(Equal([]string{"testString"}))
				Expect(versionModel.ImagePullKeyName).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.DeprecatePending).To(Equal(deprecatePendingModel))
				Expect(versionModel.SolutionInfo).To(Equal(solutionInfoModel))
				Expect(versionModel.IsConsumable).To(Equal(core.BoolPtr(true)))

				// Construct an instance of the Deployment model
				deploymentModel := new(catalogmanagementv1.Deployment)
				Expect(deploymentModel).ToNot(BeNil())
				deploymentModel.ID = core.StringPtr("testString")
				deploymentModel.Label = core.StringPtr("testString")
				deploymentModel.Name = core.StringPtr("testString")
				deploymentModel.ShortDescription = core.StringPtr("testString")
				deploymentModel.LongDescription = core.StringPtr("testString")
				deploymentModel.Metadata = make(map[string]interface{})
				deploymentModel.Tags = []string{"testString"}
				deploymentModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				deploymentModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				Expect(deploymentModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(deploymentModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(deploymentModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(deploymentModel.ShortDescription).To(Equal(core.StringPtr("testString")))
				Expect(deploymentModel.LongDescription).To(Equal(core.StringPtr("testString")))
				Expect(deploymentModel.Metadata).To(Equal(make(map[string]interface{})))
				Expect(deploymentModel.Tags).To(Equal([]string{"testString"}))
				Expect(deploymentModel.Created).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(deploymentModel.Updated).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))

				// Construct an instance of the Plan model
				planModel := new(catalogmanagementv1.Plan)
				Expect(planModel).ToNot(BeNil())
				planModel.ID = core.StringPtr("testString")
				planModel.Label = core.StringPtr("testString")
				planModel.Name = core.StringPtr("testString")
				planModel.ShortDescription = core.StringPtr("testString")
				planModel.LongDescription = core.StringPtr("testString")
				planModel.Metadata = make(map[string]interface{})
				planModel.Tags = []string{"testString"}
				planModel.AdditionalFeatures = []catalogmanagementv1.Feature{*featureModel}
				planModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.Deployments = []catalogmanagementv1.Deployment{*deploymentModel}
				Expect(planModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(planModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(planModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(planModel.ShortDescription).To(Equal(core.StringPtr("testString")))
				Expect(planModel.LongDescription).To(Equal(core.StringPtr("testString")))
				Expect(planModel.Metadata).To(Equal(make(map[string]interface{})))
				Expect(planModel.Tags).To(Equal([]string{"testString"}))
				Expect(planModel.AdditionalFeatures).To(Equal([]catalogmanagementv1.Feature{*featureModel}))
				Expect(planModel.Created).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(planModel.Updated).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(planModel.Deployments).To(Equal([]catalogmanagementv1.Deployment{*deploymentModel}))

				// Construct an instance of the Kind model
				kindModel := new(catalogmanagementv1.Kind)
				Expect(kindModel).ToNot(BeNil())
				kindModel.ID = core.StringPtr("testString")
				kindModel.FormatKind = core.StringPtr("testString")
				kindModel.InstallKind = core.StringPtr("testString")
				kindModel.TargetKind = core.StringPtr("testString")
				kindModel.Metadata = make(map[string]interface{})
				kindModel.Tags = []string{"testString"}
				kindModel.AdditionalFeatures = []catalogmanagementv1.Feature{*featureModel}
				kindModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Versions = []catalogmanagementv1.Version{*versionModel}
				kindModel.Plans = []catalogmanagementv1.Plan{*planModel}
				Expect(kindModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(kindModel.FormatKind).To(Equal(core.StringPtr("testString")))
				Expect(kindModel.InstallKind).To(Equal(core.StringPtr("testString")))
				Expect(kindModel.TargetKind).To(Equal(core.StringPtr("testString")))
				Expect(kindModel.Metadata).To(Equal(make(map[string]interface{})))
				Expect(kindModel.Tags).To(Equal([]string{"testString"}))
				Expect(kindModel.AdditionalFeatures).To(Equal([]catalogmanagementv1.Feature{*featureModel}))
				Expect(kindModel.Created).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(kindModel.Updated).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(kindModel.Versions).To(Equal([]catalogmanagementv1.Version{*versionModel}))
				Expect(kindModel.Plans).To(Equal([]catalogmanagementv1.Plan{*planModel}))

				// Construct an instance of the ProviderInfo model
				providerInfoModel := new(catalogmanagementv1.ProviderInfo)
				Expect(providerInfoModel).ToNot(BeNil())
				providerInfoModel.ID = core.StringPtr("testString")
				providerInfoModel.Name = core.StringPtr("testString")
				Expect(providerInfoModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(providerInfoModel.Name).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the RepoInfo model
				repoInfoModel := new(catalogmanagementv1.RepoInfo)
				Expect(repoInfoModel).ToNot(BeNil())
				repoInfoModel.Token = core.StringPtr("testString")
				repoInfoModel.Type = core.StringPtr("testString")
				Expect(repoInfoModel.Token).To(Equal(core.StringPtr("testString")))
				Expect(repoInfoModel.Type).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the ImagePullKey model
				imagePullKeyModel := new(catalogmanagementv1.ImagePullKey)
				Expect(imagePullKeyModel).ToNot(BeNil())
				imagePullKeyModel.Name = core.StringPtr("testString")
				imagePullKeyModel.Value = core.StringPtr("testString")
				imagePullKeyModel.Description = core.StringPtr("testString")
				Expect(imagePullKeyModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(imagePullKeyModel.Value).To(Equal(core.StringPtr("testString")))
				Expect(imagePullKeyModel.Description).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the SupportWaitTime model
				supportWaitTimeModel := new(catalogmanagementv1.SupportWaitTime)
				Expect(supportWaitTimeModel).ToNot(BeNil())
				supportWaitTimeModel.Value = core.Int64Ptr(int64(38))
				supportWaitTimeModel.Type = core.StringPtr("testString")
				Expect(supportWaitTimeModel.Value).To(Equal(core.Int64Ptr(int64(38))))
				Expect(supportWaitTimeModel.Type).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the SupportTime model
				supportTimeModel := new(catalogmanagementv1.SupportTime)
				Expect(supportTimeModel).ToNot(BeNil())
				supportTimeModel.Day = core.Int64Ptr(int64(38))
				supportTimeModel.StartTime = core.StringPtr("testString")
				supportTimeModel.EndTime = core.StringPtr("testString")
				Expect(supportTimeModel.Day).To(Equal(core.Int64Ptr(int64(38))))
				Expect(supportTimeModel.StartTime).To(Equal(core.StringPtr("testString")))
				Expect(supportTimeModel.EndTime).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the SupportAvailability model
				supportAvailabilityModel := new(catalogmanagementv1.SupportAvailability)
				Expect(supportAvailabilityModel).ToNot(BeNil())
				supportAvailabilityModel.Times = []catalogmanagementv1.SupportTime{*supportTimeModel}
				supportAvailabilityModel.Timezone = core.StringPtr("testString")
				supportAvailabilityModel.AlwaysAvailable = core.BoolPtr(true)
				Expect(supportAvailabilityModel.Times).To(Equal([]catalogmanagementv1.SupportTime{*supportTimeModel}))
				Expect(supportAvailabilityModel.Timezone).To(Equal(core.StringPtr("testString")))
				Expect(supportAvailabilityModel.AlwaysAvailable).To(Equal(core.BoolPtr(true)))

				// Construct an instance of the SupportDetail model
				supportDetailModel := new(catalogmanagementv1.SupportDetail)
				Expect(supportDetailModel).ToNot(BeNil())
				supportDetailModel.Type = core.StringPtr("testString")
				supportDetailModel.Contact = core.StringPtr("testString")
				supportDetailModel.ResponseWaitTime = supportWaitTimeModel
				supportDetailModel.Availability = supportAvailabilityModel
				Expect(supportDetailModel.Type).To(Equal(core.StringPtr("testString")))
				Expect(supportDetailModel.Contact).To(Equal(core.StringPtr("testString")))
				Expect(supportDetailModel.ResponseWaitTime).To(Equal(supportWaitTimeModel))
				Expect(supportDetailModel.Availability).To(Equal(supportAvailabilityModel))

				// Construct an instance of the SupportEscalation model
				supportEscalationModel := new(catalogmanagementv1.SupportEscalation)
				Expect(supportEscalationModel).ToNot(BeNil())
				supportEscalationModel.EscalationWaitTime = supportWaitTimeModel
				supportEscalationModel.ResponseWaitTime = supportWaitTimeModel
				supportEscalationModel.Contact = core.StringPtr("testString")
				Expect(supportEscalationModel.EscalationWaitTime).To(Equal(supportWaitTimeModel))
				Expect(supportEscalationModel.ResponseWaitTime).To(Equal(supportWaitTimeModel))
				Expect(supportEscalationModel.Contact).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the Support model
				supportModel := new(catalogmanagementv1.Support)
				Expect(supportModel).ToNot(BeNil())
				supportModel.URL = core.StringPtr("testString")
				supportModel.Process = core.StringPtr("testString")
				supportModel.ProcessI18n = make(map[string]string)
				supportModel.Locations = []string{"testString"}
				supportModel.SupportDetails = []catalogmanagementv1.SupportDetail{*supportDetailModel}
				supportModel.SupportEscalation = supportEscalationModel
				supportModel.SupportType = core.StringPtr("testString")
				Expect(supportModel.URL).To(Equal(core.StringPtr("testString")))
				Expect(supportModel.Process).To(Equal(core.StringPtr("testString")))
				Expect(supportModel.ProcessI18n).To(Equal(make(map[string]string)))
				Expect(supportModel.Locations).To(Equal([]string{"testString"}))
				Expect(supportModel.SupportDetails).To(Equal([]catalogmanagementv1.SupportDetail{*supportDetailModel}))
				Expect(supportModel.SupportEscalation).To(Equal(supportEscalationModel))
				Expect(supportModel.SupportType).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the LearnMoreLinks model
				learnMoreLinksModel := new(catalogmanagementv1.LearnMoreLinks)
				Expect(learnMoreLinksModel).ToNot(BeNil())
				learnMoreLinksModel.FirstParty = core.StringPtr("testString")
				learnMoreLinksModel.ThirdParty = core.StringPtr("testString")
				Expect(learnMoreLinksModel.FirstParty).To(Equal(core.StringPtr("testString")))
				Expect(learnMoreLinksModel.ThirdParty).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the Constraint model
				constraintModel := new(catalogmanagementv1.Constraint)
				Expect(constraintModel).ToNot(BeNil())
				constraintModel.Type = core.StringPtr("testString")
				constraintModel.Rule = core.StringPtr("testString")
				Expect(constraintModel.Type).To(Equal(core.StringPtr("testString")))
				Expect(constraintModel.Rule).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the Badge model
				badgeModel := new(catalogmanagementv1.Badge)
				Expect(badgeModel).ToNot(BeNil())
				badgeModel.ID = core.StringPtr("testString")
				badgeModel.Label = core.StringPtr("testString")
				badgeModel.LabelI18n = make(map[string]string)
				badgeModel.Description = core.StringPtr("testString")
				badgeModel.DescriptionI18n = make(map[string]string)
				badgeModel.Icon = core.StringPtr("testString")
				badgeModel.Authority = core.StringPtr("testString")
				badgeModel.Tag = core.StringPtr("testString")
				badgeModel.LearnMoreLinks = learnMoreLinksModel
				badgeModel.Constraints = []catalogmanagementv1.Constraint{*constraintModel}
				Expect(badgeModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(badgeModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(badgeModel.LabelI18n).To(Equal(make(map[string]string)))
				Expect(badgeModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(badgeModel.DescriptionI18n).To(Equal(make(map[string]string)))
				Expect(badgeModel.Icon).To(Equal(core.StringPtr("testString")))
				Expect(badgeModel.Authority).To(Equal(core.StringPtr("testString")))
				Expect(badgeModel.Tag).To(Equal(core.StringPtr("testString")))
				Expect(badgeModel.LearnMoreLinks).To(Equal(learnMoreLinksModel))
				Expect(badgeModel.Constraints).To(Equal([]catalogmanagementv1.Constraint{*constraintModel}))

				// Construct an instance of the ReplaceOfferingOptions model
				catalogIdentifier := "testString"
				offeringID := "testString"
				replaceOfferingOptionsModel := catalogManagementService.NewReplaceOfferingOptions(catalogIdentifier, offeringID)
				replaceOfferingOptionsModel.SetCatalogIdentifier("testString")
				replaceOfferingOptionsModel.SetOfferingID("testString")
				replaceOfferingOptionsModel.SetID("testString")
				replaceOfferingOptionsModel.SetRev("testString")
				replaceOfferingOptionsModel.SetURL("testString")
				replaceOfferingOptionsModel.SetCRN("testString")
				replaceOfferingOptionsModel.SetLabel("testString")
				replaceOfferingOptionsModel.SetLabelI18n(make(map[string]string))
				replaceOfferingOptionsModel.SetName("testString")
				replaceOfferingOptionsModel.SetOfferingIconURL("testString")
				replaceOfferingOptionsModel.SetOfferingDocsURL("testString")
				replaceOfferingOptionsModel.SetOfferingSupportURL("testString")
				replaceOfferingOptionsModel.SetTags([]string{"testString"})
				replaceOfferingOptionsModel.SetKeywords([]string{"testString"})
				replaceOfferingOptionsModel.SetRating(ratingModel)
				replaceOfferingOptionsModel.SetCreated(CreateMockDateTime("2019-01-01T12:00:00.000Z"))
				replaceOfferingOptionsModel.SetUpdated(CreateMockDateTime("2019-01-01T12:00:00.000Z"))
				replaceOfferingOptionsModel.SetShortDescription("testString")
				replaceOfferingOptionsModel.SetShortDescriptionI18n(make(map[string]string))
				replaceOfferingOptionsModel.SetLongDescription("testString")
				replaceOfferingOptionsModel.SetLongDescriptionI18n(make(map[string]string))
				replaceOfferingOptionsModel.SetFeatures([]catalogmanagementv1.Feature{*featureModel})
				replaceOfferingOptionsModel.SetKinds([]catalogmanagementv1.Kind{*kindModel})
				replaceOfferingOptionsModel.SetPcManaged(true)
				replaceOfferingOptionsModel.SetPublishApproved(true)
				replaceOfferingOptionsModel.SetShareWithAll(true)
				replaceOfferingOptionsModel.SetShareWithIBM(true)
				replaceOfferingOptionsModel.SetShareEnabled(true)
				replaceOfferingOptionsModel.SetPermitRequestIBMPublicPublish(true)
				replaceOfferingOptionsModel.SetIBMPublishApproved(true)
				replaceOfferingOptionsModel.SetPublicPublishApproved(true)
				replaceOfferingOptionsModel.SetPublicOriginalCRN("testString")
				replaceOfferingOptionsModel.SetPublishPublicCRN("testString")
				replaceOfferingOptionsModel.SetPortalApprovalRecord("testString")
				replaceOfferingOptionsModel.SetPortalUIURL("testString")
				replaceOfferingOptionsModel.SetCatalogID("testString")
				replaceOfferingOptionsModel.SetCatalogName("testString")
				replaceOfferingOptionsModel.SetMetadata(make(map[string]interface{}))
				replaceOfferingOptionsModel.SetDisclaimer("testString")
				replaceOfferingOptionsModel.SetHidden(true)
				replaceOfferingOptionsModel.SetProvider("testString")
				replaceOfferingOptionsModel.SetProviderInfo(providerInfoModel)
				replaceOfferingOptionsModel.SetRepoInfo(repoInfoModel)
				replaceOfferingOptionsModel.SetImagePullKeys([]catalogmanagementv1.ImagePullKey{*imagePullKeyModel})
				replaceOfferingOptionsModel.SetSupport(supportModel)
				replaceOfferingOptionsModel.SetMedia([]catalogmanagementv1.MediaItem{*mediaItemModel})
				replaceOfferingOptionsModel.SetDeprecatePending(deprecatePendingModel)
				replaceOfferingOptionsModel.SetProductKind("testString")
				replaceOfferingOptionsModel.SetBadges([]catalogmanagementv1.Badge{*badgeModel})
				replaceOfferingOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(replaceOfferingOptionsModel).ToNot(BeNil())
				Expect(replaceOfferingOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(replaceOfferingOptionsModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(replaceOfferingOptionsModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(replaceOfferingOptionsModel.Rev).To(Equal(core.StringPtr("testString")))
				Expect(replaceOfferingOptionsModel.URL).To(Equal(core.StringPtr("testString")))
				Expect(replaceOfferingOptionsModel.CRN).To(Equal(core.StringPtr("testString")))
				Expect(replaceOfferingOptionsModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(replaceOfferingOptionsModel.LabelI18n).To(Equal(make(map[string]string)))
				Expect(replaceOfferingOptionsModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(replaceOfferingOptionsModel.OfferingIconURL).To(Equal(core.StringPtr("testString")))
				Expect(replaceOfferingOptionsModel.OfferingDocsURL).To(Equal(core.StringPtr("testString")))
				Expect(replaceOfferingOptionsModel.OfferingSupportURL).To(Equal(core.StringPtr("testString")))
				Expect(replaceOfferingOptionsModel.Tags).To(Equal([]string{"testString"}))
				Expect(replaceOfferingOptionsModel.Keywords).To(Equal([]string{"testString"}))
				Expect(replaceOfferingOptionsModel.Rating).To(Equal(ratingModel))
				Expect(replaceOfferingOptionsModel.Created).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(replaceOfferingOptionsModel.Updated).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(replaceOfferingOptionsModel.ShortDescription).To(Equal(core.StringPtr("testString")))
				Expect(replaceOfferingOptionsModel.ShortDescriptionI18n).To(Equal(make(map[string]string)))
				Expect(replaceOfferingOptionsModel.LongDescription).To(Equal(core.StringPtr("testString")))
				Expect(replaceOfferingOptionsModel.LongDescriptionI18n).To(Equal(make(map[string]string)))
				Expect(replaceOfferingOptionsModel.Features).To(Equal([]catalogmanagementv1.Feature{*featureModel}))
				Expect(replaceOfferingOptionsModel.Kinds).To(Equal([]catalogmanagementv1.Kind{*kindModel}))
				Expect(replaceOfferingOptionsModel.PcManaged).To(Equal(core.BoolPtr(true)))
				Expect(replaceOfferingOptionsModel.PublishApproved).To(Equal(core.BoolPtr(true)))
				Expect(replaceOfferingOptionsModel.ShareWithAll).To(Equal(core.BoolPtr(true)))
				Expect(replaceOfferingOptionsModel.ShareWithIBM).To(Equal(core.BoolPtr(true)))
				Expect(replaceOfferingOptionsModel.ShareEnabled).To(Equal(core.BoolPtr(true)))
				Expect(replaceOfferingOptionsModel.PermitRequestIBMPublicPublish).To(Equal(core.BoolPtr(true)))
				Expect(replaceOfferingOptionsModel.IBMPublishApproved).To(Equal(core.BoolPtr(true)))
				Expect(replaceOfferingOptionsModel.PublicPublishApproved).To(Equal(core.BoolPtr(true)))
				Expect(replaceOfferingOptionsModel.PublicOriginalCRN).To(Equal(core.StringPtr("testString")))
				Expect(replaceOfferingOptionsModel.PublishPublicCRN).To(Equal(core.StringPtr("testString")))
				Expect(replaceOfferingOptionsModel.PortalApprovalRecord).To(Equal(core.StringPtr("testString")))
				Expect(replaceOfferingOptionsModel.PortalUIURL).To(Equal(core.StringPtr("testString")))
				Expect(replaceOfferingOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(replaceOfferingOptionsModel.CatalogName).To(Equal(core.StringPtr("testString")))
				Expect(replaceOfferingOptionsModel.Metadata).To(Equal(make(map[string]interface{})))
				Expect(replaceOfferingOptionsModel.Disclaimer).To(Equal(core.StringPtr("testString")))
				Expect(replaceOfferingOptionsModel.Hidden).To(Equal(core.BoolPtr(true)))
				Expect(replaceOfferingOptionsModel.Provider).To(Equal(core.StringPtr("testString")))
				Expect(replaceOfferingOptionsModel.ProviderInfo).To(Equal(providerInfoModel))
				Expect(replaceOfferingOptionsModel.RepoInfo).To(Equal(repoInfoModel))
				Expect(replaceOfferingOptionsModel.ImagePullKeys).To(Equal([]catalogmanagementv1.ImagePullKey{*imagePullKeyModel}))
				Expect(replaceOfferingOptionsModel.Support).To(Equal(supportModel))
				Expect(replaceOfferingOptionsModel.Media).To(Equal([]catalogmanagementv1.MediaItem{*mediaItemModel}))
				Expect(replaceOfferingOptionsModel.DeprecatePending).To(Equal(deprecatePendingModel))
				Expect(replaceOfferingOptionsModel.ProductKind).To(Equal(core.StringPtr("testString")))
				Expect(replaceOfferingOptionsModel.Badges).To(Equal([]catalogmanagementv1.Badge{*badgeModel}))
				Expect(replaceOfferingOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewReplaceOperatorsOptions successfully`, func() {
				// Construct an instance of the ReplaceOperatorsOptions model
				xAuthRefreshToken := "testString"
				replaceOperatorsOptionsModel := catalogManagementService.NewReplaceOperatorsOptions(xAuthRefreshToken)
				replaceOperatorsOptionsModel.SetXAuthRefreshToken("testString")
				replaceOperatorsOptionsModel.SetClusterID("testString")
				replaceOperatorsOptionsModel.SetRegion("testString")
				replaceOperatorsOptionsModel.SetNamespaces([]string{"testString"})
				replaceOperatorsOptionsModel.SetAllNamespaces(true)
				replaceOperatorsOptionsModel.SetVersionLocatorID("testString")
				replaceOperatorsOptionsModel.SetChannel("testString")
				replaceOperatorsOptionsModel.SetInstallPlan("testString")
				replaceOperatorsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(replaceOperatorsOptionsModel).ToNot(BeNil())
				Expect(replaceOperatorsOptionsModel.XAuthRefreshToken).To(Equal(core.StringPtr("testString")))
				Expect(replaceOperatorsOptionsModel.ClusterID).To(Equal(core.StringPtr("testString")))
				Expect(replaceOperatorsOptionsModel.Region).To(Equal(core.StringPtr("testString")))
				Expect(replaceOperatorsOptionsModel.Namespaces).To(Equal([]string{"testString"}))
				Expect(replaceOperatorsOptionsModel.AllNamespaces).To(Equal(core.BoolPtr(true)))
				Expect(replaceOperatorsOptionsModel.VersionLocatorID).To(Equal(core.StringPtr("testString")))
				Expect(replaceOperatorsOptionsModel.Channel).To(Equal(core.StringPtr("testString")))
				Expect(replaceOperatorsOptionsModel.InstallPlan).To(Equal(core.StringPtr("testString")))
				Expect(replaceOperatorsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewSearchObjectsOptions successfully`, func() {
				// Construct an instance of the SearchObjectsOptions model
				query := "testString"
				searchObjectsOptionsModel := catalogManagementService.NewSearchObjectsOptions(query)
				searchObjectsOptionsModel.SetQuery("testString")
				searchObjectsOptionsModel.SetKind("vpe")
				searchObjectsOptionsModel.SetLimit(int64(1000))
				searchObjectsOptionsModel.SetOffset(int64(38))
				searchObjectsOptionsModel.SetCollapse(true)
				searchObjectsOptionsModel.SetDigest(true)
				searchObjectsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(searchObjectsOptionsModel).ToNot(BeNil())
				Expect(searchObjectsOptionsModel.Query).To(Equal(core.StringPtr("testString")))
				Expect(searchObjectsOptionsModel.Kind).To(Equal(core.StringPtr("vpe")))
				Expect(searchObjectsOptionsModel.Limit).To(Equal(core.Int64Ptr(int64(1000))))
				Expect(searchObjectsOptionsModel.Offset).To(Equal(core.Int64Ptr(int64(38))))
				Expect(searchObjectsOptionsModel.Collapse).To(Equal(core.BoolPtr(true)))
				Expect(searchObjectsOptionsModel.Digest).To(Equal(core.BoolPtr(true)))
				Expect(searchObjectsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewSetDeprecateVersionOptions successfully`, func() {
				// Construct an instance of the SetDeprecateVersionOptions model
				versionLocID := "testString"
				setting := "true"
				setDeprecateVersionOptionsModel := catalogManagementService.NewSetDeprecateVersionOptions(versionLocID, setting)
				setDeprecateVersionOptionsModel.SetVersionLocID("testString")
				setDeprecateVersionOptionsModel.SetSetting("true")
				setDeprecateVersionOptionsModel.SetDescription("testString")
				setDeprecateVersionOptionsModel.SetDaysUntilDeprecate(int64(38))
				setDeprecateVersionOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(setDeprecateVersionOptionsModel).ToNot(BeNil())
				Expect(setDeprecateVersionOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(setDeprecateVersionOptionsModel.Setting).To(Equal(core.StringPtr("true")))
				Expect(setDeprecateVersionOptionsModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(setDeprecateVersionOptionsModel.DaysUntilDeprecate).To(Equal(core.Int64Ptr(int64(38))))
				Expect(setDeprecateVersionOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewSetOfferingPublishOptions successfully`, func() {
				// Construct an instance of the SetOfferingPublishOptions model
				catalogIdentifier := "testString"
				offeringID := "testString"
				approvalType := "pc_managed"
				approved := "true"
				setOfferingPublishOptionsModel := catalogManagementService.NewSetOfferingPublishOptions(catalogIdentifier, offeringID, approvalType, approved)
				setOfferingPublishOptionsModel.SetCatalogIdentifier("testString")
				setOfferingPublishOptionsModel.SetOfferingID("testString")
				setOfferingPublishOptionsModel.SetApprovalType("pc_managed")
				setOfferingPublishOptionsModel.SetApproved("true")
				setOfferingPublishOptionsModel.SetPortalRecord("testString")
				setOfferingPublishOptionsModel.SetPortalURL("testString")
				setOfferingPublishOptionsModel.SetXApproverToken("testString")
				setOfferingPublishOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(setOfferingPublishOptionsModel).ToNot(BeNil())
				Expect(setOfferingPublishOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(setOfferingPublishOptionsModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(setOfferingPublishOptionsModel.ApprovalType).To(Equal(core.StringPtr("pc_managed")))
				Expect(setOfferingPublishOptionsModel.Approved).To(Equal(core.StringPtr("true")))
				Expect(setOfferingPublishOptionsModel.PortalRecord).To(Equal(core.StringPtr("testString")))
				Expect(setOfferingPublishOptionsModel.PortalURL).To(Equal(core.StringPtr("testString")))
				Expect(setOfferingPublishOptionsModel.XApproverToken).To(Equal(core.StringPtr("testString")))
				Expect(setOfferingPublishOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewShareObjectOptions successfully`, func() {
				// Construct an instance of the ShareObjectOptions model
				catalogIdentifier := "testString"
				objectIdentifier := "testString"
				shareObjectOptionsModel := catalogManagementService.NewShareObjectOptions(catalogIdentifier, objectIdentifier)
				shareObjectOptionsModel.SetCatalogIdentifier("testString")
				shareObjectOptionsModel.SetObjectIdentifier("testString")
				shareObjectOptionsModel.SetIBM(true)
				shareObjectOptionsModel.SetPublic(true)
				shareObjectOptionsModel.SetEnabled(true)
				shareObjectOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(shareObjectOptionsModel).ToNot(BeNil())
				Expect(shareObjectOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(shareObjectOptionsModel.ObjectIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(shareObjectOptionsModel.IBM).To(Equal(core.BoolPtr(true)))
				Expect(shareObjectOptionsModel.Public).To(Equal(core.BoolPtr(true)))
				Expect(shareObjectOptionsModel.Enabled).To(Equal(core.BoolPtr(true)))
				Expect(shareObjectOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewShareOfferingOptions successfully`, func() {
				// Construct an instance of the ShareOfferingOptions model
				catalogIdentifier := "testString"
				offeringID := "testString"
				shareOfferingOptionsModel := catalogManagementService.NewShareOfferingOptions(catalogIdentifier, offeringID)
				shareOfferingOptionsModel.SetCatalogIdentifier("testString")
				shareOfferingOptionsModel.SetOfferingID("testString")
				shareOfferingOptionsModel.SetIBM(true)
				shareOfferingOptionsModel.SetPublic(true)
				shareOfferingOptionsModel.SetEnabled(true)
				shareOfferingOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(shareOfferingOptionsModel).ToNot(BeNil())
				Expect(shareOfferingOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(shareOfferingOptionsModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(shareOfferingOptionsModel.IBM).To(Equal(core.BoolPtr(true)))
				Expect(shareOfferingOptionsModel.Public).To(Equal(core.BoolPtr(true)))
				Expect(shareOfferingOptionsModel.Enabled).To(Equal(core.BoolPtr(true)))
				Expect(shareOfferingOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewSharedPublishObjectOptions successfully`, func() {
				// Construct an instance of the SharedPublishObjectOptions model
				catalogIdentifier := "testString"
				objectIdentifier := "testString"
				sharedPublishObjectOptionsModel := catalogManagementService.NewSharedPublishObjectOptions(catalogIdentifier, objectIdentifier)
				sharedPublishObjectOptionsModel.SetCatalogIdentifier("testString")
				sharedPublishObjectOptionsModel.SetObjectIdentifier("testString")
				sharedPublishObjectOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(sharedPublishObjectOptionsModel).ToNot(BeNil())
				Expect(sharedPublishObjectOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(sharedPublishObjectOptionsModel.ObjectIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(sharedPublishObjectOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewSuspendVersionOptions successfully`, func() {
				// Construct an instance of the SuspendVersionOptions model
				versionLocID := "testString"
				suspendVersionOptionsModel := catalogManagementService.NewSuspendVersionOptions(versionLocID)
				suspendVersionOptionsModel.SetVersionLocID("testString")
				suspendVersionOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(suspendVersionOptionsModel).ToNot(BeNil())
				Expect(suspendVersionOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(suspendVersionOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewUpdateCatalogAccountOptions successfully`, func() {
				// Construct an instance of the FilterTerms model
				filterTermsModel := new(catalogmanagementv1.FilterTerms)
				Expect(filterTermsModel).ToNot(BeNil())
				filterTermsModel.FilterTerms = []string{"testString"}
				Expect(filterTermsModel.FilterTerms).To(Equal([]string{"testString"}))

				// Construct an instance of the CategoryFilter model
				categoryFilterModel := new(catalogmanagementv1.CategoryFilter)
				Expect(categoryFilterModel).ToNot(BeNil())
				categoryFilterModel.Include = core.BoolPtr(true)
				categoryFilterModel.Filter = filterTermsModel
				Expect(categoryFilterModel.Include).To(Equal(core.BoolPtr(true)))
				Expect(categoryFilterModel.Filter).To(Equal(filterTermsModel))

				// Construct an instance of the IDFilter model
				idFilterModel := new(catalogmanagementv1.IDFilter)
				Expect(idFilterModel).ToNot(BeNil())
				idFilterModel.Include = filterTermsModel
				idFilterModel.Exclude = filterTermsModel
				Expect(idFilterModel.Include).To(Equal(filterTermsModel))
				Expect(idFilterModel.Exclude).To(Equal(filterTermsModel))

				// Construct an instance of the Filters model
				filtersModel := new(catalogmanagementv1.Filters)
				Expect(filtersModel).ToNot(BeNil())
				filtersModel.IncludeAll = core.BoolPtr(true)
				filtersModel.CategoryFilters = make(map[string]catalogmanagementv1.CategoryFilter)
				filtersModel.IDFilters = idFilterModel
				filtersModel.CategoryFilters["foo"] = *categoryFilterModel
				Expect(filtersModel.IncludeAll).To(Equal(core.BoolPtr(true)))
				Expect(filtersModel.IDFilters).To(Equal(idFilterModel))
				Expect(filtersModel.CategoryFilters["foo"]).To(Equal(*categoryFilterModel))

				// Construct an instance of the UpdateCatalogAccountOptions model
				updateCatalogAccountOptionsModel := catalogManagementService.NewUpdateCatalogAccountOptions()
				updateCatalogAccountOptionsModel.SetID("testString")
				updateCatalogAccountOptionsModel.SetRev("testString")
				updateCatalogAccountOptionsModel.SetHideIBMCloudCatalog(true)
				updateCatalogAccountOptionsModel.SetAccountFilters(filtersModel)
				updateCatalogAccountOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(updateCatalogAccountOptionsModel).ToNot(BeNil())
				Expect(updateCatalogAccountOptionsModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(updateCatalogAccountOptionsModel.Rev).To(Equal(core.StringPtr("testString")))
				Expect(updateCatalogAccountOptionsModel.HideIBMCloudCatalog).To(Equal(core.BoolPtr(true)))
				Expect(updateCatalogAccountOptionsModel.AccountFilters).To(Equal(filtersModel))
				Expect(updateCatalogAccountOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewUpdateOfferingOptions successfully`, func() {
				// Construct an instance of the JSONPatchOperation model
				jsonPatchOperationModel := new(catalogmanagementv1.JSONPatchOperation)
				Expect(jsonPatchOperationModel).ToNot(BeNil())
				jsonPatchOperationModel.Op = core.StringPtr("add")
				jsonPatchOperationModel.Path = core.StringPtr("testString")
				jsonPatchOperationModel.Value = core.StringPtr("testString")
				jsonPatchOperationModel.From = core.StringPtr("testString")
				Expect(jsonPatchOperationModel.Op).To(Equal(core.StringPtr("add")))
				Expect(jsonPatchOperationModel.Path).To(Equal(core.StringPtr("testString")))
				Expect(jsonPatchOperationModel.Value).To(Equal(core.StringPtr("testString")))
				Expect(jsonPatchOperationModel.From).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the UpdateOfferingOptions model
				catalogIdentifier := "testString"
				offeringID := "testString"
				ifMatch := "testString"
				updateOfferingOptionsModel := catalogManagementService.NewUpdateOfferingOptions(catalogIdentifier, offeringID, ifMatch)
				updateOfferingOptionsModel.SetCatalogIdentifier("testString")
				updateOfferingOptionsModel.SetOfferingID("testString")
				updateOfferingOptionsModel.SetIfMatch("testString")
				updateOfferingOptionsModel.SetUpdates([]catalogmanagementv1.JSONPatchOperation{*jsonPatchOperationModel})
				updateOfferingOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(updateOfferingOptionsModel).ToNot(BeNil())
				Expect(updateOfferingOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(updateOfferingOptionsModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(updateOfferingOptionsModel.IfMatch).To(Equal(core.StringPtr("testString")))
				Expect(updateOfferingOptionsModel.Updates).To(Equal([]catalogmanagementv1.JSONPatchOperation{*jsonPatchOperationModel}))
				Expect(updateOfferingOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewValidateInstallOptions successfully`, func() {
				// Construct an instance of the DeployRequestBodyOverrideValues model
				deployRequestBodyOverrideValuesModel := new(catalogmanagementv1.DeployRequestBodyOverrideValues)
				Expect(deployRequestBodyOverrideValuesModel).ToNot(BeNil())
				deployRequestBodyOverrideValuesModel.VsiInstanceName = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCProfile = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SubnetID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SubnetZone = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SSHKeyID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCRegion = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SetProperty("foo", core.StringPtr("testString"))
				Expect(deployRequestBodyOverrideValuesModel.VsiInstanceName).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyOverrideValuesModel.VPCProfile).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyOverrideValuesModel.SubnetID).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyOverrideValuesModel.VPCID).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyOverrideValuesModel.SubnetZone).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyOverrideValuesModel.SSHKeyID).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyOverrideValuesModel.VPCRegion).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyOverrideValuesModel.GetProperties()).ToNot(BeEmpty())
				Expect(deployRequestBodyOverrideValuesModel.GetProperty("foo")).To(Equal(core.StringPtr("testString")))

				deployRequestBodyOverrideValuesModel.SetProperties(nil)
				Expect(deployRequestBodyOverrideValuesModel.GetProperties()).To(BeEmpty())

				deployRequestBodyOverrideValuesModelExpectedMap := make(map[string]interface{})
				deployRequestBodyOverrideValuesModelExpectedMap["foo"] = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SetProperties(deployRequestBodyOverrideValuesModelExpectedMap)
				deployRequestBodyOverrideValuesModelActualMap := deployRequestBodyOverrideValuesModel.GetProperties()
				Expect(deployRequestBodyOverrideValuesModelActualMap).To(Equal(deployRequestBodyOverrideValuesModelExpectedMap))

				// Construct an instance of the DeployRequestBodyEnvironmentVariablesItem model
				deployRequestBodyEnvironmentVariablesItemModel := new(catalogmanagementv1.DeployRequestBodyEnvironmentVariablesItem)
				Expect(deployRequestBodyEnvironmentVariablesItemModel).ToNot(BeNil())
				deployRequestBodyEnvironmentVariablesItemModel.Name = core.StringPtr("testString")
				deployRequestBodyEnvironmentVariablesItemModel.Value = core.StringPtr("testString")
				deployRequestBodyEnvironmentVariablesItemModel.Secure = core.BoolPtr(true)
				Expect(deployRequestBodyEnvironmentVariablesItemModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyEnvironmentVariablesItemModel.Value).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyEnvironmentVariablesItemModel.Secure).To(Equal(core.BoolPtr(true)))

				// Construct an instance of the DeployRequestBodySchematics model
				deployRequestBodySchematicsModel := new(catalogmanagementv1.DeployRequestBodySchematics)
				Expect(deployRequestBodySchematicsModel).ToNot(BeNil())
				deployRequestBodySchematicsModel.Name = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Description = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Tags = []string{"testString"}
				deployRequestBodySchematicsModel.ResourceGroupID = core.StringPtr("testString")
				deployRequestBodySchematicsModel.TerraformVersion = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Region = core.StringPtr("testString")
				Expect(deployRequestBodySchematicsModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodySchematicsModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodySchematicsModel.Tags).To(Equal([]string{"testString"}))
				Expect(deployRequestBodySchematicsModel.ResourceGroupID).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodySchematicsModel.TerraformVersion).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodySchematicsModel.Region).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the ValidateInstallOptions model
				versionLocID := "testString"
				xAuthRefreshToken := "testString"
				validateInstallOptionsModel := catalogManagementService.NewValidateInstallOptions(versionLocID, xAuthRefreshToken)
				validateInstallOptionsModel.SetVersionLocID("testString")
				validateInstallOptionsModel.SetXAuthRefreshToken("testString")
				validateInstallOptionsModel.SetClusterID("testString")
				validateInstallOptionsModel.SetRegion("testString")
				validateInstallOptionsModel.SetNamespace("testString")
				validateInstallOptionsModel.SetOverrideValues(deployRequestBodyOverrideValuesModel)
				validateInstallOptionsModel.SetEnvironmentVariables([]catalogmanagementv1.DeployRequestBodyEnvironmentVariablesItem{*deployRequestBodyEnvironmentVariablesItemModel})
				validateInstallOptionsModel.SetEntitlementApikey("testString")
				validateInstallOptionsModel.SetSchematics(deployRequestBodySchematicsModel)
				validateInstallOptionsModel.SetScript("testString")
				validateInstallOptionsModel.SetScriptID("testString")
				validateInstallOptionsModel.SetVersionLocatorID("testString")
				validateInstallOptionsModel.SetVcenterID("testString")
				validateInstallOptionsModel.SetVcenterLocation("testString")
				validateInstallOptionsModel.SetVcenterUser("testString")
				validateInstallOptionsModel.SetVcenterPassword("testString")
				validateInstallOptionsModel.SetVcenterDatastore("testString")
				validateInstallOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(validateInstallOptionsModel).ToNot(BeNil())
				Expect(validateInstallOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(validateInstallOptionsModel.XAuthRefreshToken).To(Equal(core.StringPtr("testString")))
				Expect(validateInstallOptionsModel.ClusterID).To(Equal(core.StringPtr("testString")))
				Expect(validateInstallOptionsModel.Region).To(Equal(core.StringPtr("testString")))
				Expect(validateInstallOptionsModel.Namespace).To(Equal(core.StringPtr("testString")))
				Expect(validateInstallOptionsModel.OverrideValues).To(Equal(deployRequestBodyOverrideValuesModel))
				Expect(validateInstallOptionsModel.EnvironmentVariables).To(Equal([]catalogmanagementv1.DeployRequestBodyEnvironmentVariablesItem{*deployRequestBodyEnvironmentVariablesItemModel}))
				Expect(validateInstallOptionsModel.EntitlementApikey).To(Equal(core.StringPtr("testString")))
				Expect(validateInstallOptionsModel.Schematics).To(Equal(deployRequestBodySchematicsModel))
				Expect(validateInstallOptionsModel.Script).To(Equal(core.StringPtr("testString")))
				Expect(validateInstallOptionsModel.ScriptID).To(Equal(core.StringPtr("testString")))
				Expect(validateInstallOptionsModel.VersionLocatorID).To(Equal(core.StringPtr("testString")))
				Expect(validateInstallOptionsModel.VcenterID).To(Equal(core.StringPtr("testString")))
				Expect(validateInstallOptionsModel.VcenterLocation).To(Equal(core.StringPtr("testString")))
				Expect(validateInstallOptionsModel.VcenterUser).To(Equal(core.StringPtr("testString")))
				Expect(validateInstallOptionsModel.VcenterPassword).To(Equal(core.StringPtr("testString")))
				Expect(validateInstallOptionsModel.VcenterDatastore).To(Equal(core.StringPtr("testString")))
				Expect(validateInstallOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
		})
	})
	Describe(`Utility function tests`, func() {
		It(`Invoke CreateMockByteArray() successfully`, func() {
			mockByteArray := CreateMockByteArray("This is a test")
			Expect(mockByteArray).ToNot(BeNil())
		})
		It(`Invoke CreateMockUUID() successfully`, func() {
			mockUUID := CreateMockUUID("9fab83da-98cb-4f18-a7ba-b6f0435c9673")
			Expect(mockUUID).ToNot(BeNil())
		})
		It(`Invoke CreateMockReader() successfully`, func() {
			mockReader := CreateMockReader("This is a test.")
			Expect(mockReader).ToNot(BeNil())
		})
		It(`Invoke CreateMockDate() successfully`, func() {
			mockDate := CreateMockDate("2019-01-01")
			Expect(mockDate).ToNot(BeNil())
		})
		It(`Invoke CreateMockDateTime() successfully`, func() {
			mockDateTime := CreateMockDateTime("2019-01-01T12:00:00.000Z")
			Expect(mockDateTime).ToNot(BeNil())
		})
	})
})

//
// Utility functions used by the generated test code
//

func CreateMockByteArray(mockData string) *[]byte {
	ba := make([]byte, 0)
	ba = append(ba, mockData...)
	return &ba
}

func CreateMockUUID(mockData string) *strfmt.UUID {
	uuid := strfmt.UUID(mockData)
	return &uuid
}

func CreateMockReader(mockData string) io.ReadCloser {
	return io.NopCloser(bytes.NewReader([]byte(mockData)))
}

func CreateMockDate(mockData string) *strfmt.Date {
	d, err := core.ParseDate(mockData)
	if err != nil {
		return nil
	}
	return &d
}

func CreateMockDateTime(mockData string) *strfmt.DateTime {
	d, err := core.ParseDateTime(mockData)
	if err != nil {
		return nil
	}
	return &d
}

func SetTestEnvironment(testEnvironment map[string]string) {
	for key, value := range testEnvironment {
		os.Setenv(key, value)
	}
}

func ClearTestEnvironment(testEnvironment map[string]string) {
	for key := range testEnvironment {
		os.Unsetenv(key)
	}
}
