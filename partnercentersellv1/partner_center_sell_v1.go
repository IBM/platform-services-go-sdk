/**
 * (C) Copyright IBM Corp. 2022.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * IBM OpenAPI SDK Code Generator Version: 3.54.1-1d9808a7-20220817-143039
 */

// Package partnercentersellv1 : Operations and models for the PartnerCenterSellV1 service
package partnercentersellv1

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"reflect"
	"time"

	"github.com/IBM/go-sdk-core/v5/core"
	common "github.com/IBM/platform-services-go-sdk/common"
	"github.com/go-openapi/strfmt"
)

// PartnerCenterSellV1 : No description provided (generated by Openapi Generator
// https://github.com/openapitools/openapi-generator)
//
// API Version: 1.1.2
type PartnerCenterSellV1 struct {
	Service *core.BaseService
}

// DefaultServiceURL is the default URL to make service requests to.
const DefaultServiceURL = "https://product-lifecycle.api.cloud.ibm.com/openapi/v1"

// DefaultServiceName is the default key used to find external configuration information.
const DefaultServiceName = "partner_center_sell"

// PartnerCenterSellV1Options : Service options
type PartnerCenterSellV1Options struct {
	ServiceName   string
	URL           string
	Authenticator core.Authenticator
}

// NewPartnerCenterSellV1UsingExternalConfig : constructs an instance of PartnerCenterSellV1 with passed in options and external configuration.
func NewPartnerCenterSellV1UsingExternalConfig(options *PartnerCenterSellV1Options) (partnerCenterSell *PartnerCenterSellV1, err error) {
	if options.ServiceName == "" {
		options.ServiceName = DefaultServiceName
	}

	if options.Authenticator == nil {
		options.Authenticator, err = core.GetAuthenticatorFromEnvironment(options.ServiceName)
		if err != nil {
			return
		}
	}

	partnerCenterSell, err = NewPartnerCenterSellV1(options)
	if err != nil {
		return
	}

	err = partnerCenterSell.Service.ConfigureService(options.ServiceName)
	if err != nil {
		return
	}

	if options.URL != "" {
		err = partnerCenterSell.Service.SetServiceURL(options.URL)
	}
	return
}

// NewPartnerCenterSellV1 : constructs an instance of PartnerCenterSellV1 with passed in options.
func NewPartnerCenterSellV1(options *PartnerCenterSellV1Options) (service *PartnerCenterSellV1, err error) {
	serviceOptions := &core.ServiceOptions{
		URL:           DefaultServiceURL,
		Authenticator: options.Authenticator,
	}

	baseService, err := core.NewBaseService(serviceOptions)
	if err != nil {
		return
	}

	if options.URL != "" {
		err = baseService.SetServiceURL(options.URL)
		if err != nil {
			return
		}
	}

	service = &PartnerCenterSellV1{
		Service: baseService,
	}

	return
}

// GetServiceURLForRegion returns the service URL to be used for the specified region
func GetServiceURLForRegion(region string) (string, error) {
	return "", fmt.Errorf("service does not support regional URLs")
}

// Clone makes a copy of "partnerCenterSell" suitable for processing requests.
func (partnerCenterSell *PartnerCenterSellV1) Clone() *PartnerCenterSellV1 {
	if core.IsNil(partnerCenterSell) {
		return nil
	}
	clone := *partnerCenterSell
	clone.Service = partnerCenterSell.Service.Clone()
	return &clone
}

// SetServiceURL sets the service URL
func (partnerCenterSell *PartnerCenterSellV1) SetServiceURL(url string) error {
	return partnerCenterSell.Service.SetServiceURL(url)
}

// GetServiceURL returns the service URL
func (partnerCenterSell *PartnerCenterSellV1) GetServiceURL() string {
	return partnerCenterSell.Service.GetServiceURL()
}

// SetDefaultHeaders sets HTTP headers to be sent in every request
func (partnerCenterSell *PartnerCenterSellV1) SetDefaultHeaders(headers http.Header) {
	partnerCenterSell.Service.SetDefaultHeaders(headers)
}

// SetEnableGzipCompression sets the service's EnableGzipCompression field
func (partnerCenterSell *PartnerCenterSellV1) SetEnableGzipCompression(enableGzip bool) {
	partnerCenterSell.Service.SetEnableGzipCompression(enableGzip)
}

// GetEnableGzipCompression returns the service's EnableGzipCompression field
func (partnerCenterSell *PartnerCenterSellV1) GetEnableGzipCompression() bool {
	return partnerCenterSell.Service.GetEnableGzipCompression()
}

// EnableRetries enables automatic retries for requests invoked for this service instance.
// If either parameter is specified as 0, then a default value is used instead.
func (partnerCenterSell *PartnerCenterSellV1) EnableRetries(maxRetries int, maxRetryInterval time.Duration) {
	partnerCenterSell.Service.EnableRetries(maxRetries, maxRetryInterval)
}

// DisableRetries disables automatic retries for requests invoked for this service instance.
func (partnerCenterSell *PartnerCenterSellV1) DisableRetries() {
	partnerCenterSell.Service.DisableRetries()
}

// ListProducts : List products
// List all available products that are onboarded to Partner Center Sell.
func (partnerCenterSell *PartnerCenterSellV1) ListProducts(listProductsOptions *ListProductsOptions) (result *ListProductsResponse, response *core.DetailedResponse, err error) {
	return partnerCenterSell.ListProductsWithContext(context.Background(), listProductsOptions)
}

// ListProductsWithContext is an alternate form of the ListProducts method which supports a Context parameter
func (partnerCenterSell *PartnerCenterSellV1) ListProductsWithContext(ctx context.Context, listProductsOptions *ListProductsOptions) (result *ListProductsResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listProductsOptions, "listProductsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = partnerCenterSell.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(partnerCenterSell.Service.Options.URL, `/products`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listProductsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("partner_center_sell", "V1", "ListProducts")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = partnerCenterSell.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalListProductsResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateProduct : Create product
// Start to onboard a new product to Partner Center Sell.
func (partnerCenterSell *PartnerCenterSellV1) CreateProduct(createProductOptions *CreateProductOptions) (result *ProductDetails, response *core.DetailedResponse, err error) {
	return partnerCenterSell.CreateProductWithContext(context.Background(), createProductOptions)
}

// CreateProductWithContext is an alternate form of the CreateProduct method which supports a Context parameter
func (partnerCenterSell *PartnerCenterSellV1) CreateProductWithContext(ctx context.Context, createProductOptions *CreateProductOptions) (result *ProductDetails, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createProductOptions, "createProductOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createProductOptions, "createProductOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = partnerCenterSell.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(partnerCenterSell.Service.Options.URL, `/products`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createProductOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("partner_center_sell", "V1", "CreateProduct")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if createProductOptions.ProductName != nil {
		body["productName"] = createProductOptions.ProductName
	}
	if createProductOptions.TaxAssessment != nil {
		body["taxAssessment"] = createProductOptions.TaxAssessment
	}
	if createProductOptions.ProductType != nil {
		body["productType"] = createProductOptions.ProductType
	}
	if createProductOptions.MaterialAgreement != nil {
		body["materialAgreement"] = createProductOptions.MaterialAgreement
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = partnerCenterSell.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalProductDetails)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetProduct : Get product details
// Retrieve available details of a product. Details include contact information, product type, and private catalog ID.
func (partnerCenterSell *PartnerCenterSellV1) GetProduct(getProductOptions *GetProductOptions) (result *ProductDetails, response *core.DetailedResponse, err error) {
	return partnerCenterSell.GetProductWithContext(context.Background(), getProductOptions)
}

// GetProductWithContext is an alternate form of the GetProduct method which supports a Context parameter
func (partnerCenterSell *PartnerCenterSellV1) GetProductWithContext(ctx context.Context, getProductOptions *GetProductOptions) (result *ProductDetails, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getProductOptions, "getProductOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getProductOptions, "getProductOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"productId": fmt.Sprint(*getProductOptions.ProductID),
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = partnerCenterSell.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(partnerCenterSell.Service.Options.URL, `/products/{productId}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getProductOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("partner_center_sell", "V1", "GetProduct")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = partnerCenterSell.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalProductDetails)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateProduct : Update product details
// Update a product's name, tax assessment, and material agreement.
func (partnerCenterSell *PartnerCenterSellV1) UpdateProduct(updateProductOptions *UpdateProductOptions) (result *ProductDetails, response *core.DetailedResponse, err error) {
	return partnerCenterSell.UpdateProductWithContext(context.Background(), updateProductOptions)
}

// UpdateProductWithContext is an alternate form of the UpdateProduct method which supports a Context parameter
func (partnerCenterSell *PartnerCenterSellV1) UpdateProductWithContext(ctx context.Context, updateProductOptions *UpdateProductOptions) (result *ProductDetails, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateProductOptions, "updateProductOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateProductOptions, "updateProductOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"productId": fmt.Sprint(*updateProductOptions.ProductID),
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = partnerCenterSell.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(partnerCenterSell.Service.Options.URL, `/products/{productId}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateProductOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("partner_center_sell", "V1", "UpdateProduct")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if updateProductOptions.MaterialAgreement != nil {
		body["materialAgreement"] = updateProductOptions.MaterialAgreement
	}
	if updateProductOptions.ProductName != nil {
		body["productName"] = updateProductOptions.ProductName
	}
	if updateProductOptions.TaxAssessment != nil {
		body["taxAssessment"] = updateProductOptions.TaxAssessment
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = partnerCenterSell.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalProductDetails)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteProduct : Delete a draft product
// Delete a product that is not published to the IBM Cloud catalog or shared with other accounts. To remove a published
// or shared product from your account, you must first deprecate the product.
func (partnerCenterSell *PartnerCenterSellV1) DeleteProduct(deleteProductOptions *DeleteProductOptions) (result *bool, response *core.DetailedResponse, err error) {
	return partnerCenterSell.DeleteProductWithContext(context.Background(), deleteProductOptions)
}

// DeleteProductWithContext is an alternate form of the DeleteProduct method which supports a Context parameter
func (partnerCenterSell *PartnerCenterSellV1) DeleteProductWithContext(ctx context.Context, deleteProductOptions *DeleteProductOptions) (result *bool, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteProductOptions, "deleteProductOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteProductOptions, "deleteProductOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"productId": fmt.Sprint(*deleteProductOptions.ProductID),
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = partnerCenterSell.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(partnerCenterSell.Service.Options.URL, `/products/{productId}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteProductOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("partner_center_sell", "V1", "DeleteProduct")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = partnerCenterSell.Service.Request(request, &result)

	return
}

// PublishProduct : Publish an approved product
// To publish a product to the IBM Cloud catalog, you must submit for approval. After you receive approval, you can
// publish to the catalog.
func (partnerCenterSell *PartnerCenterSellV1) PublishProduct(publishProductOptions *PublishProductOptions) (result *ProductDetails, response *core.DetailedResponse, err error) {
	return partnerCenterSell.PublishProductWithContext(context.Background(), publishProductOptions)
}

// PublishProductWithContext is an alternate form of the PublishProduct method which supports a Context parameter
func (partnerCenterSell *PartnerCenterSellV1) PublishProductWithContext(ctx context.Context, publishProductOptions *PublishProductOptions) (result *ProductDetails, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(publishProductOptions, "publishProductOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(publishProductOptions, "publishProductOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"productId": fmt.Sprint(*publishProductOptions.ProductID),
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = partnerCenterSell.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(partnerCenterSell.Service.Options.URL, `/products/{productId}/publish`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range publishProductOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("partner_center_sell", "V1", "PublishProduct")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = partnerCenterSell.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalProductDetails)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// SuspendProduct : Suspend a published product
// You can remove a product from the IBM Cloud catalog without permanently deleting or deprecating it for up to 7 days.
// You might want to suspend a product if you discover a bug or vulnerability that must be investigated and fixed.
func (partnerCenterSell *PartnerCenterSellV1) SuspendProduct(suspendProductOptions *SuspendProductOptions) (result *ProductDetails, response *core.DetailedResponse, err error) {
	return partnerCenterSell.SuspendProductWithContext(context.Background(), suspendProductOptions)
}

// SuspendProductWithContext is an alternate form of the SuspendProduct method which supports a Context parameter
func (partnerCenterSell *PartnerCenterSellV1) SuspendProductWithContext(ctx context.Context, suspendProductOptions *SuspendProductOptions) (result *ProductDetails, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(suspendProductOptions, "suspendProductOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(suspendProductOptions, "suspendProductOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"productId": fmt.Sprint(*suspendProductOptions.ProductID),
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = partnerCenterSell.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(partnerCenterSell.Service.Options.URL, `/products/{productId}/suspend`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range suspendProductOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("partner_center_sell", "V1", "SuspendProduct")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if suspendProductOptions.Reason != nil {
		body["reason"] = suspendProductOptions.Reason
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = partnerCenterSell.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalProductDetails)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeprecateProduct : Deprecate a published product
// If you need to permanently delete your product or a version from the IBM Cloud catalog, deprecate it first. Your
// product remains available for use during a 90-day deprecation period, and is removed after 90 days.
func (partnerCenterSell *PartnerCenterSellV1) DeprecateProduct(deprecateProductOptions *DeprecateProductOptions) (result *ProductDetails, response *core.DetailedResponse, err error) {
	return partnerCenterSell.DeprecateProductWithContext(context.Background(), deprecateProductOptions)
}

// DeprecateProductWithContext is an alternate form of the DeprecateProduct method which supports a Context parameter
func (partnerCenterSell *PartnerCenterSellV1) DeprecateProductWithContext(ctx context.Context, deprecateProductOptions *DeprecateProductOptions) (result *ProductDetails, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deprecateProductOptions, "deprecateProductOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deprecateProductOptions, "deprecateProductOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"productId": fmt.Sprint(*deprecateProductOptions.ProductID),
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = partnerCenterSell.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(partnerCenterSell.Service.Options.URL, `/products/{productId}/deprecate`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deprecateProductOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("partner_center_sell", "V1", "DeprecateProduct")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if deprecateProductOptions.Reason != nil {
		body["reason"] = deprecateProductOptions.Reason
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = partnerCenterSell.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalProductDetails)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// RestoreProduct : Restore a deprecated product
// If your product is deprecated, you have 90 days to restore it to keep it in the catalog.
func (partnerCenterSell *PartnerCenterSellV1) RestoreProduct(restoreProductOptions *RestoreProductOptions) (result *ProductDetails, response *core.DetailedResponse, err error) {
	return partnerCenterSell.RestoreProductWithContext(context.Background(), restoreProductOptions)
}

// RestoreProductWithContext is an alternate form of the RestoreProduct method which supports a Context parameter
func (partnerCenterSell *PartnerCenterSellV1) RestoreProductWithContext(ctx context.Context, restoreProductOptions *RestoreProductOptions) (result *ProductDetails, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(restoreProductOptions, "restoreProductOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(restoreProductOptions, "restoreProductOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"productId": fmt.Sprint(*restoreProductOptions.ProductID),
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = partnerCenterSell.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(partnerCenterSell.Service.Options.URL, `/products/{productId}/restore`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range restoreProductOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("partner_center_sell", "V1", "RestoreProduct")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if restoreProductOptions.Reason != nil {
		body["reason"] = restoreProductOptions.Reason
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = partnerCenterSell.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalProductDetails)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListBadges : List badges
// List all available badges a product can be validated against.
func (partnerCenterSell *PartnerCenterSellV1) ListBadges(listBadgesOptions *ListBadgesOptions) (result *CloudBadge, response *core.DetailedResponse, err error) {
	return partnerCenterSell.ListBadgesWithContext(context.Background(), listBadgesOptions)
}

// ListBadgesWithContext is an alternate form of the ListBadges method which supports a Context parameter
func (partnerCenterSell *PartnerCenterSellV1) ListBadgesWithContext(ctx context.Context, listBadgesOptions *ListBadgesOptions) (result *CloudBadge, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listBadgesOptions, "listBadgesOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = partnerCenterSell.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(partnerCenterSell.Service.Options.URL, `/products/badges`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listBadgesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("partner_center_sell", "V1", "ListBadges")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = partnerCenterSell.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalCloudBadge)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetBadge : Get badge
// Get a badge by id.
func (partnerCenterSell *PartnerCenterSellV1) GetBadge(getBadgeOptions *GetBadgeOptions) (result *CloudBadge, response *core.DetailedResponse, err error) {
	return partnerCenterSell.GetBadgeWithContext(context.Background(), getBadgeOptions)
}

// GetBadgeWithContext is an alternate form of the GetBadge method which supports a Context parameter
func (partnerCenterSell *PartnerCenterSellV1) GetBadgeWithContext(ctx context.Context, getBadgeOptions *GetBadgeOptions) (result *CloudBadge, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getBadgeOptions, "getBadgeOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getBadgeOptions, "getBadgeOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"badgeId": fmt.Sprint(*getBadgeOptions.BadgeID),
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = partnerCenterSell.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(partnerCenterSell.Service.Options.URL, `/products/badges/{badgeId}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getBadgeOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("partner_center_sell", "V1", "GetBadge")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = partnerCenterSell.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalCloudBadge)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetCatalog : View a product's catalog data
// View the catalog entry details and other data that is stored for your product.
func (partnerCenterSell *PartnerCenterSellV1) GetCatalog(getCatalogOptions *GetCatalogOptions) (result *CatalogListingDetails, response *core.DetailedResponse, err error) {
	return partnerCenterSell.GetCatalogWithContext(context.Background(), getCatalogOptions)
}

// GetCatalogWithContext is an alternate form of the GetCatalog method which supports a Context parameter
func (partnerCenterSell *PartnerCenterSellV1) GetCatalogWithContext(ctx context.Context, getCatalogOptions *GetCatalogOptions) (result *CatalogListingDetails, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getCatalogOptions, "getCatalogOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getCatalogOptions, "getCatalogOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"productId": fmt.Sprint(*getCatalogOptions.ProductID),
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = partnerCenterSell.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(partnerCenterSell.Service.Options.URL, `/products/{productId}/catalog`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getCatalogOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("partner_center_sell", "V1", "GetCatalog")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = partnerCenterSell.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalCatalogListingDetails)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateCatalog : Update a product's catalog data
// Update the catalog entry details and other data that is stored for your product.
func (partnerCenterSell *PartnerCenterSellV1) UpdateCatalog(updateCatalogOptions *UpdateCatalogOptions) (result *CatalogListingDetails, response *core.DetailedResponse, err error) {
	return partnerCenterSell.UpdateCatalogWithContext(context.Background(), updateCatalogOptions)
}

// UpdateCatalogWithContext is an alternate form of the UpdateCatalog method which supports a Context parameter
func (partnerCenterSell *PartnerCenterSellV1) UpdateCatalogWithContext(ctx context.Context, updateCatalogOptions *UpdateCatalogOptions) (result *CatalogListingDetails, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateCatalogOptions, "updateCatalogOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateCatalogOptions, "updateCatalogOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"productId": fmt.Sprint(*updateCatalogOptions.ProductID),
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = partnerCenterSell.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(partnerCenterSell.Service.Options.URL, `/products/{productId}/catalog`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateCatalogOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("partner_center_sell", "V1", "UpdateCatalog")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if updateCatalogOptions.CatalogID != nil {
		body["catalogId"] = updateCatalogOptions.CatalogID
	}
	if updateCatalogOptions.Description != nil {
		body["description"] = updateCatalogOptions.Description
	}
	if updateCatalogOptions.IconURL != nil {
		body["iconUrl"] = updateCatalogOptions.IconURL
	}
	if updateCatalogOptions.Keywords != nil {
		body["keywords"] = updateCatalogOptions.Keywords
	}
	if updateCatalogOptions.PricingModel != nil {
		body["pricingModel"] = updateCatalogOptions.PricingModel
	}
	if updateCatalogOptions.Category != nil {
		body["category"] = updateCatalogOptions.Category
	}
	if updateCatalogOptions.ProviderType != nil {
		body["providerType"] = updateCatalogOptions.ProviderType
	}
	if updateCatalogOptions.Label != nil {
		body["label"] = updateCatalogOptions.Label
	}
	if updateCatalogOptions.Name != nil {
		body["name"] = updateCatalogOptions.Name
	}
	if updateCatalogOptions.Provider != nil {
		body["provider"] = updateCatalogOptions.Provider
	}
	if updateCatalogOptions.Tags != nil {
		body["tags"] = updateCatalogOptions.Tags
	}
	if updateCatalogOptions.DocumentationURL != nil {
		body["documentationUrl"] = updateCatalogOptions.DocumentationURL
	}
	if updateCatalogOptions.Highlights != nil {
		body["highlights"] = updateCatalogOptions.Highlights
	}
	if updateCatalogOptions.LongDescription != nil {
		body["longDescription"] = updateCatalogOptions.LongDescription
	}
	if updateCatalogOptions.Media != nil {
		body["media"] = updateCatalogOptions.Media
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = partnerCenterSell.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalCatalogListingDetails)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// RequestCatalogApproval : Request a catalog listing approval
// If a catalog listing was not approved for publishing during the initial product approval process, you can request
// approval again.
func (partnerCenterSell *PartnerCenterSellV1) RequestCatalogApproval(requestCatalogApprovalOptions *RequestCatalogApprovalOptions) (result *Resource, response *core.DetailedResponse, err error) {
	return partnerCenterSell.RequestCatalogApprovalWithContext(context.Background(), requestCatalogApprovalOptions)
}

// RequestCatalogApprovalWithContext is an alternate form of the RequestCatalogApproval method which supports a Context parameter
func (partnerCenterSell *PartnerCenterSellV1) RequestCatalogApprovalWithContext(ctx context.Context, requestCatalogApprovalOptions *RequestCatalogApprovalOptions) (result *Resource, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(requestCatalogApprovalOptions, "requestCatalogApprovalOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(requestCatalogApprovalOptions, "requestCatalogApprovalOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"productId": fmt.Sprint(*requestCatalogApprovalOptions.ProductID),
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = partnerCenterSell.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(partnerCenterSell.Service.Options.URL, `/products/{productId}/catalog/approvals`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range requestCatalogApprovalOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("partner_center_sell", "V1", "RequestCatalogApproval")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = partnerCenterSell.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalResource)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListPlans : List pricing plans that are connected to a product
// List pricing plans that are connected to a product.
func (partnerCenterSell *PartnerCenterSellV1) ListPlans(listPlansOptions *ListPlansOptions) (result *ListPlansResponse, response *core.DetailedResponse, err error) {
	return partnerCenterSell.ListPlansWithContext(context.Background(), listPlansOptions)
}

// ListPlansWithContext is an alternate form of the ListPlans method which supports a Context parameter
func (partnerCenterSell *PartnerCenterSellV1) ListPlansWithContext(ctx context.Context, listPlansOptions *ListPlansOptions) (result *ListPlansResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listPlansOptions, "listPlansOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listPlansOptions, "listPlansOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"productId": fmt.Sprint(*listPlansOptions.ProductID),
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = partnerCenterSell.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(partnerCenterSell.Service.Options.URL, `/products/{productId}/plans`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listPlansOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("partner_center_sell", "V1", "ListPlans")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = partnerCenterSell.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalListPlansResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreatePlan : Create a pricing plan
// Define how you want to charge users for your product. If you aren't sure how you want charge users, you can start by
// using a free plan.
func (partnerCenterSell *PartnerCenterSellV1) CreatePlan(createPlanOptions *CreatePlanOptions) (result *CreatePlanResponse, response *core.DetailedResponse, err error) {
	return partnerCenterSell.CreatePlanWithContext(context.Background(), createPlanOptions)
}

// CreatePlanWithContext is an alternate form of the CreatePlan method which supports a Context parameter
func (partnerCenterSell *PartnerCenterSellV1) CreatePlanWithContext(ctx context.Context, createPlanOptions *CreatePlanOptions) (result *CreatePlanResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createPlanOptions, "createPlanOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createPlanOptions, "createPlanOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"productId": fmt.Sprint(*createPlanOptions.ProductID),
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = partnerCenterSell.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(partnerCenterSell.Service.Options.URL, `/products/{productId}/plans`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createPlanOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("partner_center_sell", "V1", "CreatePlan")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if createPlanOptions.Description != nil {
		body["description"] = createPlanOptions.Description
	}
	if createPlanOptions.Label != nil {
		body["label"] = createPlanOptions.Label
	}
	if createPlanOptions.Type != nil {
		body["type"] = createPlanOptions.Type
	}
	if createPlanOptions.URL != nil {
		body["url"] = createPlanOptions.URL
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = partnerCenterSell.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalCreatePlanResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetPlan : Get pricing plan by ID
// Use the pricing plan ID to retrieve its details.
func (partnerCenterSell *PartnerCenterSellV1) GetPlan(getPlanOptions *GetPlanOptions) (result *License, response *core.DetailedResponse, err error) {
	return partnerCenterSell.GetPlanWithContext(context.Background(), getPlanOptions)
}

// GetPlanWithContext is an alternate form of the GetPlan method which supports a Context parameter
func (partnerCenterSell *PartnerCenterSellV1) GetPlanWithContext(ctx context.Context, getPlanOptions *GetPlanOptions) (result *License, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getPlanOptions, "getPlanOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getPlanOptions, "getPlanOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"productId": fmt.Sprint(*getPlanOptions.ProductID),
		"pricingPlanId": *getPlanOptions.PricingPlanID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = partnerCenterSell.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(partnerCenterSell.Service.Options.URL, `/products/{productId}/plans/{pricingPlanId}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getPlanOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("partner_center_sell", "V1", "GetPlan")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = partnerCenterSell.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLicense)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdatePlan : Update a pricing plan
// If you need to change details of a pricing plan, such as the name, description, URL, or type, you can update the
// pricing plan. After your changes are submitted for a published product, the changes are displayed in the catalog.
func (partnerCenterSell *PartnerCenterSellV1) UpdatePlan(updatePlanOptions *UpdatePlanOptions) (result *CreatePlanResponse, response *core.DetailedResponse, err error) {
	return partnerCenterSell.UpdatePlanWithContext(context.Background(), updatePlanOptions)
}

// UpdatePlanWithContext is an alternate form of the UpdatePlan method which supports a Context parameter
func (partnerCenterSell *PartnerCenterSellV1) UpdatePlanWithContext(ctx context.Context, updatePlanOptions *UpdatePlanOptions) (result *CreatePlanResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updatePlanOptions, "updatePlanOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updatePlanOptions, "updatePlanOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"productId": fmt.Sprint(*updatePlanOptions.ProductID),
		"pricingPlanId": *updatePlanOptions.PricingPlanID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = partnerCenterSell.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(partnerCenterSell.Service.Options.URL, `/products/{productId}/plans/{pricingPlanId}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updatePlanOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("partner_center_sell", "V1", "UpdatePlan")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if updatePlanOptions.Description != nil {
		body["description"] = updatePlanOptions.Description
	}
	if updatePlanOptions.Label != nil {
		body["label"] = updatePlanOptions.Label
	}
	if updatePlanOptions.Type != nil {
		body["type"] = updatePlanOptions.Type
	}
	if updatePlanOptions.URL != nil {
		body["url"] = updatePlanOptions.URL
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = partnerCenterSell.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalCreatePlanResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeletePlan : Delete a pricing plan
// If you need to remove a pricing plan for a product, you can delete it.
func (partnerCenterSell *PartnerCenterSellV1) DeletePlan(deletePlanOptions *DeletePlanOptions) (result *CreatePlanResponse, response *core.DetailedResponse, err error) {
	return partnerCenterSell.DeletePlanWithContext(context.Background(), deletePlanOptions)
}

// DeletePlanWithContext is an alternate form of the DeletePlan method which supports a Context parameter
func (partnerCenterSell *PartnerCenterSellV1) DeletePlanWithContext(ctx context.Context, deletePlanOptions *DeletePlanOptions) (result *CreatePlanResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deletePlanOptions, "deletePlanOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deletePlanOptions, "deletePlanOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"productId": fmt.Sprint(*deletePlanOptions.ProductID),
		"pricingPlanId": *deletePlanOptions.PricingPlanID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = partnerCenterSell.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(partnerCenterSell.Service.Options.URL, `/products/{productId}/plans/{pricingPlanId}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deletePlanOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("partner_center_sell", "V1", "DeletePlan")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = partnerCenterSell.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalCreatePlanResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetSupport : Get product support details
// View the product support details, including the contacts and the escalation process.
func (partnerCenterSell *PartnerCenterSellV1) GetSupport(getSupportOptions *GetSupportOptions) (result *Support, response *core.DetailedResponse, err error) {
	return partnerCenterSell.GetSupportWithContext(context.Background(), getSupportOptions)
}

// GetSupportWithContext is an alternate form of the GetSupport method which supports a Context parameter
func (partnerCenterSell *PartnerCenterSellV1) GetSupportWithContext(ctx context.Context, getSupportOptions *GetSupportOptions) (result *Support, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSupportOptions, "getSupportOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSupportOptions, "getSupportOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"productId": fmt.Sprint(*getSupportOptions.ProductID),
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = partnerCenterSell.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(partnerCenterSell.Service.Options.URL, `/products/{productId}/support`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSupportOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("partner_center_sell", "V1", "GetSupport")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = partnerCenterSell.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSupport)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateSupport : Update product support details
// Update the product support details, including the contacts and the escalation process.
func (partnerCenterSell *PartnerCenterSellV1) UpdateSupport(updateSupportOptions *UpdateSupportOptions) (result *Support, response *core.DetailedResponse, err error) {
	return partnerCenterSell.UpdateSupportWithContext(context.Background(), updateSupportOptions)
}

// UpdateSupportWithContext is an alternate form of the UpdateSupport method which supports a Context parameter
func (partnerCenterSell *PartnerCenterSellV1) UpdateSupportWithContext(ctx context.Context, updateSupportOptions *UpdateSupportOptions) (result *Support, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateSupportOptions, "updateSupportOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateSupportOptions, "updateSupportOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"productId": fmt.Sprint(*updateSupportOptions.ProductID),
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = partnerCenterSell.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(partnerCenterSell.Service.Options.URL, `/products/{productId}/support`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateSupportOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("partner_center_sell", "V1", "UpdateSupport")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if updateSupportOptions.EscalationContacts != nil {
		body["escalationContacts"] = updateSupportOptions.EscalationContacts
	}
	if updateSupportOptions.Locations != nil {
		body["locations"] = updateSupportOptions.Locations
	}
	if updateSupportOptions.SupportDetails != nil {
		body["support_details"] = updateSupportOptions.SupportDetails
	}
	if updateSupportOptions.SupportEscalation != nil {
		body["support_escalation"] = updateSupportOptions.SupportEscalation
	}
	if updateSupportOptions.SupportType != nil {
		body["support_type"] = updateSupportOptions.SupportType
	}
	if updateSupportOptions.URL != nil {
		body["url"] = updateSupportOptions.URL
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = partnerCenterSell.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSupport)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListSupportChangeRequests : List all change requests related to a given product
// List all change requests related to a given product.
func (partnerCenterSell *PartnerCenterSellV1) ListSupportChangeRequests(listSupportChangeRequestsOptions *ListSupportChangeRequestsOptions) (result *ListSupportChangeRequestsResponse, response *core.DetailedResponse, err error) {
	return partnerCenterSell.ListSupportChangeRequestsWithContext(context.Background(), listSupportChangeRequestsOptions)
}

// ListSupportChangeRequestsWithContext is an alternate form of the ListSupportChangeRequests method which supports a Context parameter
func (partnerCenterSell *PartnerCenterSellV1) ListSupportChangeRequestsWithContext(ctx context.Context, listSupportChangeRequestsOptions *ListSupportChangeRequestsOptions) (result *ListSupportChangeRequestsResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listSupportChangeRequestsOptions, "listSupportChangeRequestsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listSupportChangeRequestsOptions, "listSupportChangeRequestsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"productId": fmt.Sprint(*listSupportChangeRequestsOptions.ProductID),
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = partnerCenterSell.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(partnerCenterSell.Service.Options.URL, `/products/{productId}/support/changes`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listSupportChangeRequestsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("partner_center_sell", "V1", "ListSupportChangeRequests")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = partnerCenterSell.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalListSupportChangeRequestsResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateSupportChangeRequest : Update support data of an already approved or published product
// To update the support data of an already approved or published product, your changes will be required to be reviewed
// and approved. To do updates on a published product, you have to open a change request, add your changes to it, then
// request a review for your changes. Once the changes are approved, you can merge these updates to your published
// product.
func (partnerCenterSell *PartnerCenterSellV1) CreateSupportChangeRequest(createSupportChangeRequestOptions *CreateSupportChangeRequestOptions) (result *ProductDetails, response *core.DetailedResponse, err error) {
	return partnerCenterSell.CreateSupportChangeRequestWithContext(context.Background(), createSupportChangeRequestOptions)
}

// CreateSupportChangeRequestWithContext is an alternate form of the CreateSupportChangeRequest method which supports a Context parameter
func (partnerCenterSell *PartnerCenterSellV1) CreateSupportChangeRequestWithContext(ctx context.Context, createSupportChangeRequestOptions *CreateSupportChangeRequestOptions) (result *ProductDetails, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createSupportChangeRequestOptions, "createSupportChangeRequestOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createSupportChangeRequestOptions, "createSupportChangeRequestOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"productId": fmt.Sprint(*createSupportChangeRequestOptions.ProductID),
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = partnerCenterSell.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(partnerCenterSell.Service.Options.URL, `/products/{productId}/support/changes`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createSupportChangeRequestOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("partner_center_sell", "V1", "CreateSupportChangeRequest")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if createSupportChangeRequestOptions.Change != nil {
		body["change"] = createSupportChangeRequestOptions.Change
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = partnerCenterSell.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalProductDetails)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetSupportChangeRequest : Get a change request related to a given product by id
// Get a change request related to a given product by id.
func (partnerCenterSell *PartnerCenterSellV1) GetSupportChangeRequest(getSupportChangeRequestOptions *GetSupportChangeRequestOptions) (result *ChangeRequest, response *core.DetailedResponse, err error) {
	return partnerCenterSell.GetSupportChangeRequestWithContext(context.Background(), getSupportChangeRequestOptions)
}

// GetSupportChangeRequestWithContext is an alternate form of the GetSupportChangeRequest method which supports a Context parameter
func (partnerCenterSell *PartnerCenterSellV1) GetSupportChangeRequestWithContext(ctx context.Context, getSupportChangeRequestOptions *GetSupportChangeRequestOptions) (result *ChangeRequest, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSupportChangeRequestOptions, "getSupportChangeRequestOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSupportChangeRequestOptions, "getSupportChangeRequestOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"productId": fmt.Sprint(*getSupportChangeRequestOptions.ProductID),
		"changeRequestId": *getSupportChangeRequestOptions.ChangeRequestID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = partnerCenterSell.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(partnerCenterSell.Service.Options.URL, `/products/{productId}/support/changes/{changeRequestId}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSupportChangeRequestOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("partner_center_sell", "V1", "GetSupportChangeRequest")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = partnerCenterSell.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalChangeRequest)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateSupportChangeRequest : Update an already created change request
// Update a change request that was created earlier.
func (partnerCenterSell *PartnerCenterSellV1) UpdateSupportChangeRequest(updateSupportChangeRequestOptions *UpdateSupportChangeRequestOptions) (result *ProductDetails, response *core.DetailedResponse, err error) {
	return partnerCenterSell.UpdateSupportChangeRequestWithContext(context.Background(), updateSupportChangeRequestOptions)
}

// UpdateSupportChangeRequestWithContext is an alternate form of the UpdateSupportChangeRequest method which supports a Context parameter
func (partnerCenterSell *PartnerCenterSellV1) UpdateSupportChangeRequestWithContext(ctx context.Context, updateSupportChangeRequestOptions *UpdateSupportChangeRequestOptions) (result *ProductDetails, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateSupportChangeRequestOptions, "updateSupportChangeRequestOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateSupportChangeRequestOptions, "updateSupportChangeRequestOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"productId": fmt.Sprint(*updateSupportChangeRequestOptions.ProductID),
		"changeRequestId": *updateSupportChangeRequestOptions.ChangeRequestID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = partnerCenterSell.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(partnerCenterSell.Service.Options.URL, `/products/{productId}/support/changes/{changeRequestId}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateSupportChangeRequestOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("partner_center_sell", "V1", "UpdateSupportChangeRequest")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if updateSupportChangeRequestOptions.Change != nil {
		body["change"] = updateSupportChangeRequestOptions.Change
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = partnerCenterSell.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalProductDetails)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListSupportChangeRequestReviews : List review events related to a change request
// List review events related to a change request.
func (partnerCenterSell *PartnerCenterSellV1) ListSupportChangeRequestReviews(listSupportChangeRequestReviewsOptions *ListSupportChangeRequestReviewsOptions) (result *Resource, response *core.DetailedResponse, err error) {
	return partnerCenterSell.ListSupportChangeRequestReviewsWithContext(context.Background(), listSupportChangeRequestReviewsOptions)
}

// ListSupportChangeRequestReviewsWithContext is an alternate form of the ListSupportChangeRequestReviews method which supports a Context parameter
func (partnerCenterSell *PartnerCenterSellV1) ListSupportChangeRequestReviewsWithContext(ctx context.Context, listSupportChangeRequestReviewsOptions *ListSupportChangeRequestReviewsOptions) (result *Resource, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listSupportChangeRequestReviewsOptions, "listSupportChangeRequestReviewsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listSupportChangeRequestReviewsOptions, "listSupportChangeRequestReviewsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"productId": fmt.Sprint(*listSupportChangeRequestReviewsOptions.ProductID),
		"changeRequestId": *listSupportChangeRequestReviewsOptions.ChangeRequestID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = partnerCenterSell.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(partnerCenterSell.Service.Options.URL, `/products/{productId}/support/changes/{changeRequestId}/reviews`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listSupportChangeRequestReviewsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("partner_center_sell", "V1", "ListSupportChangeRequestReviews")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = partnerCenterSell.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalResource)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// RequestSupportChangeRequestReview : Update an already created change request
// Update a change request that was created earlier.
func (partnerCenterSell *PartnerCenterSellV1) RequestSupportChangeRequestReview(requestSupportChangeRequestReviewOptions *RequestSupportChangeRequestReviewOptions) (result *Resource, response *core.DetailedResponse, err error) {
	return partnerCenterSell.RequestSupportChangeRequestReviewWithContext(context.Background(), requestSupportChangeRequestReviewOptions)
}

// RequestSupportChangeRequestReviewWithContext is an alternate form of the RequestSupportChangeRequestReview method which supports a Context parameter
func (partnerCenterSell *PartnerCenterSellV1) RequestSupportChangeRequestReviewWithContext(ctx context.Context, requestSupportChangeRequestReviewOptions *RequestSupportChangeRequestReviewOptions) (result *Resource, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(requestSupportChangeRequestReviewOptions, "requestSupportChangeRequestReviewOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(requestSupportChangeRequestReviewOptions, "requestSupportChangeRequestReviewOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"productId": fmt.Sprint(*requestSupportChangeRequestReviewOptions.ProductID),
		"changeRequestId": *requestSupportChangeRequestReviewOptions.ChangeRequestID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = partnerCenterSell.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(partnerCenterSell.Service.Options.URL, `/products/{productId}/support/changes/{changeRequestId}/reviews`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range requestSupportChangeRequestReviewOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("partner_center_sell", "V1", "RequestSupportChangeRequestReview")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = partnerCenterSell.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalResource)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// MergeSupportChangeRequest : Merge the approved changeset to the published product
// Merge the approved change request back to the published product to make the changes available publicly.
func (partnerCenterSell *PartnerCenterSellV1) MergeSupportChangeRequest(mergeSupportChangeRequestOptions *MergeSupportChangeRequestOptions) (result *ProductDetails, response *core.DetailedResponse, err error) {
	return partnerCenterSell.MergeSupportChangeRequestWithContext(context.Background(), mergeSupportChangeRequestOptions)
}

// MergeSupportChangeRequestWithContext is an alternate form of the MergeSupportChangeRequest method which supports a Context parameter
func (partnerCenterSell *PartnerCenterSellV1) MergeSupportChangeRequestWithContext(ctx context.Context, mergeSupportChangeRequestOptions *MergeSupportChangeRequestOptions) (result *ProductDetails, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(mergeSupportChangeRequestOptions, "mergeSupportChangeRequestOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(mergeSupportChangeRequestOptions, "mergeSupportChangeRequestOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"productId": fmt.Sprint(*mergeSupportChangeRequestOptions.ProductID),
		"changeRequestId": *mergeSupportChangeRequestOptions.ChangeRequestID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = partnerCenterSell.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(partnerCenterSell.Service.Options.URL, `/products/{productId}/support/changes/{changeRequestId}/merge`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range mergeSupportChangeRequestOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("partner_center_sell", "V1", "MergeSupportChangeRequest")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = partnerCenterSell.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalProductDetails)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// RequestSupportApproval : Request approval of support information
// If the support information for your product is not approved, you can use this method to request approval of your
// product's support information again.
func (partnerCenterSell *PartnerCenterSellV1) RequestSupportApproval(requestSupportApprovalOptions *RequestSupportApprovalOptions) (result *Resource, response *core.DetailedResponse, err error) {
	return partnerCenterSell.RequestSupportApprovalWithContext(context.Background(), requestSupportApprovalOptions)
}

// RequestSupportApprovalWithContext is an alternate form of the RequestSupportApproval method which supports a Context parameter
func (partnerCenterSell *PartnerCenterSellV1) RequestSupportApprovalWithContext(ctx context.Context, requestSupportApprovalOptions *RequestSupportApprovalOptions) (result *Resource, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(requestSupportApprovalOptions, "requestSupportApprovalOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(requestSupportApprovalOptions, "requestSupportApprovalOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"productId": fmt.Sprint(*requestSupportApprovalOptions.ProductID),
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = partnerCenterSell.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(partnerCenterSell.Service.Options.URL, `/products/{productId}/support/approvals`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range requestSupportApprovalOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("partner_center_sell", "V1", "RequestSupportApproval")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = partnerCenterSell.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalResource)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// RequestProductApproval : Request approval to publish
// After you complete the requirements for onboarding a product, you can request approval to publish to the IBM Cloud
// catalog.
func (partnerCenterSell *PartnerCenterSellV1) RequestProductApproval(requestProductApprovalOptions *RequestProductApprovalOptions) (result *Resource, response *core.DetailedResponse, err error) {
	return partnerCenterSell.RequestProductApprovalWithContext(context.Background(), requestProductApprovalOptions)
}

// RequestProductApprovalWithContext is an alternate form of the RequestProductApproval method which supports a Context parameter
func (partnerCenterSell *PartnerCenterSellV1) RequestProductApprovalWithContext(ctx context.Context, requestProductApprovalOptions *RequestProductApprovalOptions) (result *Resource, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(requestProductApprovalOptions, "requestProductApprovalOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(requestProductApprovalOptions, "requestProductApprovalOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"productId": fmt.Sprint(*requestProductApprovalOptions.ProductID),
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = partnerCenterSell.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(partnerCenterSell.Service.Options.URL, `/products/{productId}/approvals`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range requestProductApprovalOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("partner_center_sell", "V1", "RequestProductApproval")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = partnerCenterSell.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalResource)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListProductApprovals : List approvals
// By using the product ID, you can get the current state and history of all approvals. Approvals are required to
// publish your product to the catalog.
func (partnerCenterSell *PartnerCenterSellV1) ListProductApprovals(listProductApprovalsOptions *ListProductApprovalsOptions) (result *ListProductApprovalsResponse, response *core.DetailedResponse, err error) {
	return partnerCenterSell.ListProductApprovalsWithContext(context.Background(), listProductApprovalsOptions)
}

// ListProductApprovalsWithContext is an alternate form of the ListProductApprovals method which supports a Context parameter
func (partnerCenterSell *PartnerCenterSellV1) ListProductApprovalsWithContext(ctx context.Context, listProductApprovalsOptions *ListProductApprovalsOptions) (result *ListProductApprovalsResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listProductApprovalsOptions, "listProductApprovalsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listProductApprovalsOptions, "listProductApprovalsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"productId": fmt.Sprint(*listProductApprovalsOptions.ProductID),
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = partnerCenterSell.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(partnerCenterSell.Service.Options.URL, `/products/{productId}/approvals`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listProductApprovalsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("partner_center_sell", "V1", "ListProductApprovals")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = partnerCenterSell.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalListProductApprovalsResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CatalogListingDetails : CatalogListingDetails struct
type CatalogListingDetails struct {
	// The unique ID for the account in which the product is being onboarded.
	AccountID *string `json:"accountId,omitempty"`

	// The ID of the private catalog where your products are created.
	CatalogID *string `json:"catalogId" validate:"required"`

	// The deprecation process of the product is in the pending state.
	DeprecatePending *DeprecatePending `json:"deprecatePending,omitempty"`

	// The description of the product.
	Description *string `json:"description,omitempty"`

	// The link to the warranted product documentation.
	DocumentationURL *string `json:"documentationUrl,omitempty"`

	// The product can be edited.
	Editable *bool `json:"editable,omitempty"`

	// The attributes of the product that differentiate it in the market.
	Highlights []HighlightSection `json:"highlights,omitempty"`

	// The URL for your company or product logo.
	IconURL *string `json:"iconUrl,omitempty"`

	// The ID that uniquely identifies the product in Partner Center. This ID can be found on the Dashboard tab in Partner
	// Center.
	ID *string `json:"id" validate:"required"`

	// The key search terms that are associated with your product.
	Keywords []string `json:"keywords,omitempty"`

	// The name of the product.
	Label *string `json:"label,omitempty"`

	// Translated strings for the name of the product.
	LabelI18n interface{} `json:"label_i18n,omitempty"`

	// The description about the details of the product. You can use markdown syntax to provide this description.
	LongDescription *string `json:"longDescription,omitempty"`

	// Translated strings for describing the details of the product. You can use markdown syntax to provide this
	// description.
	LongDescriptionI18n interface{} `json:"long_description_i18n,omitempty"`

	// The images or videos that show off the product.
	Media []MediaSection `json:"media,omitempty"`

	// The name of the product.
	Name *string `json:"name,omitempty"`

	// The product was created in Partner Center.
	PcManaged *bool `json:"pcManaged,omitempty"`

	// The name of your company.
	Provider *string `json:"provider,omitempty"`

	// The product is published to an access list. An access list is a list of accounts that your product is potentially
	// shared with.
	PublishedToAccessList *bool `json:"publishedToAccessList,omitempty"`

	// The product is available to all IBMers.
	PublishedToIBM *bool `json:"publishedToIBM,omitempty"`

	// The product is published to the IBM Cloud catalog.
	PublishedToPublic *bool `json:"publishedToPublic,omitempty"`

	// Translated strings for the description of the product.
	ShortDescriptionI18n interface{} `json:"short_description_i18n,omitempty"`

	// The keywords and phrases that are associated with your product.
	Tags []string `json:"tags,omitempty"`

	// The version details of a product.
	Versions []CatalogListingVersion `json:"versions,omitempty"`
}

// UnmarshalCatalogListingDetails unmarshals an instance of CatalogListingDetails from the specified map of raw messages.
func UnmarshalCatalogListingDetails(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CatalogListingDetails)
	err = core.UnmarshalPrimitive(m, "accountId", &obj.AccountID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "catalogId", &obj.CatalogID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deprecatePending", &obj.DeprecatePending, UnmarshalDeprecatePending)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "documentationUrl", &obj.DocumentationURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "editable", &obj.Editable)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "highlights", &obj.Highlights, UnmarshalHighlightSection)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "iconUrl", &obj.IconURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "keywords", &obj.Keywords)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "label", &obj.Label)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "label_i18n", &obj.LabelI18n)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "longDescription", &obj.LongDescription)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "long_description_i18n", &obj.LongDescriptionI18n)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "media", &obj.Media, UnmarshalMediaSection)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pcManaged", &obj.PcManaged)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "provider", &obj.Provider)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "publishedToAccessList", &obj.PublishedToAccessList)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "publishedToIBM", &obj.PublishedToIBM)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "publishedToPublic", &obj.PublishedToPublic)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "short_description_i18n", &obj.ShortDescriptionI18n)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "tags", &obj.Tags)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "versions", &obj.Versions, UnmarshalCatalogListingVersion)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CatalogListingVersion : The version details of a product.
type CatalogListingVersion struct {
	// The deprecation process of the product is in the pending state.
	DeprecatePending *DeprecatePending `json:"deprecatePending,omitempty"`

	// The version ID of the product. This ID can be found by using the Catalog management API.
	ID *string `json:"id" validate:"required"`

	// The content kind.
	KindFormat *string `json:"kindFormat,omitempty"`

	// The unique ID of kind.
	KindID *string `json:"kindId,omitempty"`

	// Target kinds.
	KindTarget *string `json:"kindTarget,omitempty"`

	// The version of the package.
	PackageVersion *string `json:"packageVersion,omitempty"`

	// The state of the version of your product.
	State *string `json:"state,omitempty"`

	// The time when the state of the version changed.
	StateChangeTime *string `json:"stateChangeTime,omitempty"`

	// The validation status of the version of your product.
	ValidatedState *string `json:"validatedState,omitempty"`

	// The version number of the current version.
	Version *string `json:"version,omitempty"`

	// A dot notation value that uses the format `catalogID.versionID`.
	VersionLocator *string `json:"versionLocator,omitempty"`

	// The list of allowlisted accounts that have access to the version of your product.
	AllowlistedAccounts []string `json:"allowlistedAccounts,omitempty"`
}

// Constants associated with the CatalogListingVersion.KindTarget property.
// Target kinds.
const (
	CatalogListingVersion_KindTarget_Iks = "iks"
	CatalogListingVersion_KindTarget_PowerIaas = "power-iaas"
	CatalogListingVersion_KindTarget_Roks = "roks"
	CatalogListingVersion_KindTarget_Terraform = "terraform"
	CatalogListingVersion_KindTarget_Vcenter = "vcenter"
)

// UnmarshalCatalogListingVersion unmarshals an instance of CatalogListingVersion from the specified map of raw messages.
func UnmarshalCatalogListingVersion(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CatalogListingVersion)
	err = core.UnmarshalModel(m, "deprecatePending", &obj.DeprecatePending, UnmarshalDeprecatePending)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "kindFormat", &obj.KindFormat)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "kindId", &obj.KindID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "kindTarget", &obj.KindTarget)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "packageVersion", &obj.PackageVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "state", &obj.State)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "stateChangeTime", &obj.StateChangeTime)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "validatedState", &obj.ValidatedState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "version", &obj.Version)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "versionLocator", &obj.VersionLocator)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "allowlistedAccounts", &obj.AllowlistedAccounts)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ChangeRequest : A change request that was opened to change the support properties of a published product.
type ChangeRequest struct {
	// A unique id that identifies the change request.
	ID *string `json:"id,omitempty"`

	// The time when the change request was created in standard ISO 8601 format.
	CreatedAt *string `json:"createdAt,omitempty"`

	// The user ID of the user who initiated this change request.
	Initiator *string `json:"initiator,omitempty"`

	// The time when the change request was merged back to the published product in standard ISO 8601 format.
	Merged *string `json:"merged,omitempty"`

	// Provide details about how customers can get help when they are using your product.
	Change *Support `json:"change,omitempty"`
}

// UnmarshalChangeRequest unmarshals an instance of ChangeRequest from the specified map of raw messages.
func UnmarshalChangeRequest(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ChangeRequest)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "createdAt", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "initiator", &obj.Initiator)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "merged", &obj.Merged)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "change", &obj.Change, UnmarshalSupport)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CloudBadge : CloudBadge struct
type CloudBadge struct {
	// The ID of the badge.
	ID *string `json:"id" validate:"required"`

	// The name of the badge.
	Label *string `json:"label,omitempty"`

	// The description of the badge.
	Description *string `json:"description,omitempty"`

	LearnMoreLinks *CloudBadgeLearnMoreLinks `json:"learnMoreLinks,omitempty"`

	// An url to get started with the validation against this certification.
	GetStartedLink *string `json:"getStartedLink,omitempty"`

	// Deprecated, will be removed.
	Tag *string `json:"tag,omitempty"`
}

// UnmarshalCloudBadge unmarshals an instance of CloudBadge from the specified map of raw messages.
func UnmarshalCloudBadge(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CloudBadge)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "label", &obj.Label)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "learnMoreLinks", &obj.LearnMoreLinks, UnmarshalCloudBadgeLearnMoreLinks)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "getStartedLink", &obj.GetStartedLink)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "tag", &obj.Tag)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CloudBadgeLearnMoreLinks : CloudBadgeLearnMoreLinks struct
type CloudBadgeLearnMoreLinks struct {
	// An url where first party (IBMer) vendors can learn more about this badge.
	FirstParty *string `json:"firstParty,omitempty"`

	// An url where third party (non-IBMer) vendors can learn more about this badge.
	ThirdParty *string `json:"thirdParty,omitempty"`
}

// UnmarshalCloudBadgeLearnMoreLinks unmarshals an instance of CloudBadgeLearnMoreLinks from the specified map of raw messages.
func UnmarshalCloudBadgeLearnMoreLinks(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CloudBadgeLearnMoreLinks)
	err = core.UnmarshalPrimitive(m, "firstParty", &obj.FirstParty)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "thirdParty", &obj.ThirdParty)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CreatePlanOptions : The CreatePlan options.
type CreatePlanOptions struct {
	// The unique ID of the product. This ID can be obtained by calling the list products method and also can be found in
	// Partner Center.
	ProductID *strfmt.UUID `json:"productId" validate:"required"`

	// The description of the pricing model.
	Description *string `json:"description" validate:"required"`

	// The name of the pricing plan.
	Label *string `json:"label" validate:"required"`

	// The type of the pricing plan.
	Type *string `json:"type" validate:"required"`

	// The URL to where your customers can purchase the license that is required to use your product.
	URL *string `json:"url" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreatePlanOptions.Type property.
// The type of the pricing plan.
const (
	CreatePlanOptions_Type_Byol = "byol"
)

// NewCreatePlanOptions : Instantiate CreatePlanOptions
func (*PartnerCenterSellV1) NewCreatePlanOptions(productID *strfmt.UUID, description string, label string, typeVar string, url string) *CreatePlanOptions {
	return &CreatePlanOptions{
		ProductID: productID,
		Description: core.StringPtr(description),
		Label: core.StringPtr(label),
		Type: core.StringPtr(typeVar),
		URL: core.StringPtr(url),
	}
}

// SetProductID : Allow user to set ProductID
func (_options *CreatePlanOptions) SetProductID(productID *strfmt.UUID) *CreatePlanOptions {
	_options.ProductID = productID
	return _options
}

// SetDescription : Allow user to set Description
func (_options *CreatePlanOptions) SetDescription(description string) *CreatePlanOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetLabel : Allow user to set Label
func (_options *CreatePlanOptions) SetLabel(label string) *CreatePlanOptions {
	_options.Label = core.StringPtr(label)
	return _options
}

// SetType : Allow user to set Type
func (_options *CreatePlanOptions) SetType(typeVar string) *CreatePlanOptions {
	_options.Type = core.StringPtr(typeVar)
	return _options
}

// SetURL : Allow user to set URL
func (_options *CreatePlanOptions) SetURL(url string) *CreatePlanOptions {
	_options.URL = core.StringPtr(url)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreatePlanOptions) SetHeaders(param map[string]string) *CreatePlanOptions {
	options.Headers = param
	return options
}

// CreatePlanResponse : CreatePlanResponse struct
type CreatePlanResponse struct {
	Plans []License `json:"plans,omitempty"`
}

// UnmarshalCreatePlanResponse unmarshals an instance of CreatePlanResponse from the specified map of raw messages.
func UnmarshalCreatePlanResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CreatePlanResponse)
	err = core.UnmarshalModel(m, "plans", &obj.Plans, UnmarshalLicense)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CreateProductOptions : The CreateProduct options.
type CreateProductOptions struct {
	// The name of the product that you are onboarding. This name is displayed to users when you publish your product in
	// the catalog.
	ProductName *string `json:"productName" validate:"required"`

	// The tax assessment for your product.
	TaxAssessment *string `json:"taxAssessment" validate:"required"`

	// The type of the product that you want to onboard to IBM Cloud.
	ProductType *string `json:"productType" validate:"required"`

	// The confirmation that your company is authorized to use all materials.
	MaterialAgreement *bool `json:"materialAgreement,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateProductOptions.TaxAssessment property.
// The tax assessment for your product.
const (
	CreateProductOptions_TaxAssessment_Software = "SOFTWARE"
)

// Constants associated with the CreateProductOptions.ProductType property.
// The type of the product that you want to onboard to IBM Cloud.
const (
	CreateProductOptions_ProductType_Module = "MODULE"
	CreateProductOptions_ProductType_Software = "SOFTWARE"
	CreateProductOptions_ProductType_Solution = "SOLUTION"
)

// NewCreateProductOptions : Instantiate CreateProductOptions
func (*PartnerCenterSellV1) NewCreateProductOptions(productName string, taxAssessment string, productType string) *CreateProductOptions {
	return &CreateProductOptions{
		ProductName: core.StringPtr(productName),
		TaxAssessment: core.StringPtr(taxAssessment),
		ProductType: core.StringPtr(productType),
	}
}

// SetProductName : Allow user to set ProductName
func (_options *CreateProductOptions) SetProductName(productName string) *CreateProductOptions {
	_options.ProductName = core.StringPtr(productName)
	return _options
}

// SetTaxAssessment : Allow user to set TaxAssessment
func (_options *CreateProductOptions) SetTaxAssessment(taxAssessment string) *CreateProductOptions {
	_options.TaxAssessment = core.StringPtr(taxAssessment)
	return _options
}

// SetProductType : Allow user to set ProductType
func (_options *CreateProductOptions) SetProductType(productType string) *CreateProductOptions {
	_options.ProductType = core.StringPtr(productType)
	return _options
}

// SetMaterialAgreement : Allow user to set MaterialAgreement
func (_options *CreateProductOptions) SetMaterialAgreement(materialAgreement bool) *CreateProductOptions {
	_options.MaterialAgreement = core.BoolPtr(materialAgreement)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateProductOptions) SetHeaders(param map[string]string) *CreateProductOptions {
	options.Headers = param
	return options
}

// CreateSupportChangeRequestOptions : The CreateSupportChangeRequest options.
type CreateSupportChangeRequestOptions struct {
	// The unique ID of the product. This ID can be obtained by calling the list products method and also can be found in
	// Partner Center.
	ProductID *strfmt.UUID `json:"productId" validate:"required"`

	// Provide details about how customers can get help when they are using your product.
	Change *Support `json:"change" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateSupportChangeRequestOptions : Instantiate CreateSupportChangeRequestOptions
func (*PartnerCenterSellV1) NewCreateSupportChangeRequestOptions(productID *strfmt.UUID, change *Support) *CreateSupportChangeRequestOptions {
	return &CreateSupportChangeRequestOptions{
		ProductID: productID,
		Change: change,
	}
}

// SetProductID : Allow user to set ProductID
func (_options *CreateSupportChangeRequestOptions) SetProductID(productID *strfmt.UUID) *CreateSupportChangeRequestOptions {
	_options.ProductID = productID
	return _options
}

// SetChange : Allow user to set Change
func (_options *CreateSupportChangeRequestOptions) SetChange(change *Support) *CreateSupportChangeRequestOptions {
	_options.Change = change
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateSupportChangeRequestOptions) SetHeaders(param map[string]string) *CreateSupportChangeRequestOptions {
	options.Headers = param
	return options
}

// DeletePlanOptions : The DeletePlan options.
type DeletePlanOptions struct {
	// The unique ID of the product. This ID can be obtained by calling the list products method and also can be found in
	// Partner Center.
	ProductID *strfmt.UUID `json:"productId" validate:"required"`

	// The resource ID of the pricing plan. This ID can be obtained by listing pricing plans.
	PricingPlanID *string `json:"pricingPlanId" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeletePlanOptions : Instantiate DeletePlanOptions
func (*PartnerCenterSellV1) NewDeletePlanOptions(productID *strfmt.UUID, pricingPlanID string) *DeletePlanOptions {
	return &DeletePlanOptions{
		ProductID: productID,
		PricingPlanID: core.StringPtr(pricingPlanID),
	}
}

// SetProductID : Allow user to set ProductID
func (_options *DeletePlanOptions) SetProductID(productID *strfmt.UUID) *DeletePlanOptions {
	_options.ProductID = productID
	return _options
}

// SetPricingPlanID : Allow user to set PricingPlanID
func (_options *DeletePlanOptions) SetPricingPlanID(pricingPlanID string) *DeletePlanOptions {
	_options.PricingPlanID = core.StringPtr(pricingPlanID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeletePlanOptions) SetHeaders(param map[string]string) *DeletePlanOptions {
	options.Headers = param
	return options
}

// DeleteProductOptions : The DeleteProduct options.
type DeleteProductOptions struct {
	// The unique ID of the product. This ID can be obtained by calling the list products method and also can be found in
	// Partner Center.
	ProductID *strfmt.UUID `json:"productId" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteProductOptions : Instantiate DeleteProductOptions
func (*PartnerCenterSellV1) NewDeleteProductOptions(productID *strfmt.UUID) *DeleteProductOptions {
	return &DeleteProductOptions{
		ProductID: productID,
	}
}

// SetProductID : Allow user to set ProductID
func (_options *DeleteProductOptions) SetProductID(productID *strfmt.UUID) *DeleteProductOptions {
	_options.ProductID = productID
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteProductOptions) SetHeaders(param map[string]string) *DeleteProductOptions {
	options.Headers = param
	return options
}

// DeprecatePending : The deprecation process of the product is in the pending state.
type DeprecatePending struct {
	// The time when the product was deprecated in standard ISO 8601 format.
	DeprecateDate *string `json:"deprecateDate,omitempty"`

	// The deprecation state of the product.
	DeprecateState *string `json:"deprecateState,omitempty"`

	// The reason why the product is getting deprecated.
	Description *string `json:"description,omitempty"`
}

// UnmarshalDeprecatePending unmarshals an instance of DeprecatePending from the specified map of raw messages.
func UnmarshalDeprecatePending(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DeprecatePending)
	err = core.UnmarshalPrimitive(m, "deprecateDate", &obj.DeprecateDate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "deprecateState", &obj.DeprecateState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DeprecateProductOptions : The DeprecateProduct options.
type DeprecateProductOptions struct {
	// The unique ID of the product. This ID can be obtained by calling the list products method and also can be found in
	// Partner Center.
	ProductID *strfmt.UUID `json:"productId" validate:"required"`

	// The reason why you want to deprecate your published product.
	Reason *string `json:"reason" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeprecateProductOptions : Instantiate DeprecateProductOptions
func (*PartnerCenterSellV1) NewDeprecateProductOptions(productID *strfmt.UUID, reason string) *DeprecateProductOptions {
	return &DeprecateProductOptions{
		ProductID: productID,
		Reason: core.StringPtr(reason),
	}
}

// SetProductID : Allow user to set ProductID
func (_options *DeprecateProductOptions) SetProductID(productID *strfmt.UUID) *DeprecateProductOptions {
	_options.ProductID = productID
	return _options
}

// SetReason : Allow user to set Reason
func (_options *DeprecateProductOptions) SetReason(reason string) *DeprecateProductOptions {
	_options.Reason = core.StringPtr(reason)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeprecateProductOptions) SetHeaders(param map[string]string) *DeprecateProductOptions {
	options.Headers = param
	return options
}

// Error : Error struct
type Error struct {
	// Describes the error.
	Message *string `json:"message,omitempty"`

	// These details are used to help the support engineer troubleshoot any occurring issues.
	Extensions *ErrorExtensions `json:"extensions,omitempty"`
}

// UnmarshalError unmarshals an instance of Error from the specified map of raw messages.
func UnmarshalError(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Error)
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "extensions", &obj.Extensions, UnmarshalErrorExtensions)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ErrorExtensions : These details are used to help the support engineer troubleshoot any occurring issues.
type ErrorExtensions struct {
	// The code that identifies the error.
	Code *string `json:"code,omitempty"`

	// The programmatic name of the product. This is the unique ID of the product that is used within all IBM services and
	// tools.
	ServiceName *string `json:"serviceName,omitempty"`

	// The occurring error.
	Exception interface{} `json:"exception,omitempty"`

	// The transaction ID. This ID can be used for identifying errors.
	Trid *string `json:"trid,omitempty"`

	// The opreation when the error occurred.
	OperationName *string `json:"operationName,omitempty"`
}

// UnmarshalErrorExtensions unmarshals an instance of ErrorExtensions from the specified map of raw messages.
func UnmarshalErrorExtensions(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ErrorExtensions)
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "serviceName", &obj.ServiceName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "exception", &obj.Exception)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "trid", &obj.Trid)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "operationName", &obj.OperationName)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// EscalationContactsUpdate : The direct contact for IBM Cloud Support leaders to communicate with the support leader of your product. This contact
// information is not displayed on the product detail page in the catalog.
type EscalationContactsUpdate struct {
	// The email address of the support leader.
	Email *string `json:"email,omitempty"`

	// The name of the support leader.
	Name *string `json:"name,omitempty"`
}

// UnmarshalEscalationContactsUpdate unmarshals an instance of EscalationContactsUpdate from the specified map of raw messages.
func UnmarshalEscalationContactsUpdate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EscalationContactsUpdate)
	err = core.UnmarshalPrimitive(m, "email", &obj.Email)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GetBadgeOptions : The GetBadge options.
type GetBadgeOptions struct {
	// The unique ID of the badge. This ID can be obtained by calling the list badges method.
	BadgeID *strfmt.UUID `json:"badgeId" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetBadgeOptions : Instantiate GetBadgeOptions
func (*PartnerCenterSellV1) NewGetBadgeOptions(badgeID *strfmt.UUID) *GetBadgeOptions {
	return &GetBadgeOptions{
		BadgeID: badgeID,
	}
}

// SetBadgeID : Allow user to set BadgeID
func (_options *GetBadgeOptions) SetBadgeID(badgeID *strfmt.UUID) *GetBadgeOptions {
	_options.BadgeID = badgeID
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetBadgeOptions) SetHeaders(param map[string]string) *GetBadgeOptions {
	options.Headers = param
	return options
}

// GetCatalogOptions : The GetCatalog options.
type GetCatalogOptions struct {
	// The unique ID of the product. This ID can be obtained by calling the list products method and also can be found in
	// Partner Center.
	ProductID *strfmt.UUID `json:"productId" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetCatalogOptions : Instantiate GetCatalogOptions
func (*PartnerCenterSellV1) NewGetCatalogOptions(productID *strfmt.UUID) *GetCatalogOptions {
	return &GetCatalogOptions{
		ProductID: productID,
	}
}

// SetProductID : Allow user to set ProductID
func (_options *GetCatalogOptions) SetProductID(productID *strfmt.UUID) *GetCatalogOptions {
	_options.ProductID = productID
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetCatalogOptions) SetHeaders(param map[string]string) *GetCatalogOptions {
	options.Headers = param
	return options
}

// GetPlanOptions : The GetPlan options.
type GetPlanOptions struct {
	// The unique ID of the product. This ID can be obtained by calling the list products method and also can be found in
	// Partner Center.
	ProductID *strfmt.UUID `json:"productId" validate:"required"`

	// The resource ID of the pricing plan. This ID can be obtained by listing pricing plans.
	PricingPlanID *string `json:"pricingPlanId" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetPlanOptions : Instantiate GetPlanOptions
func (*PartnerCenterSellV1) NewGetPlanOptions(productID *strfmt.UUID, pricingPlanID string) *GetPlanOptions {
	return &GetPlanOptions{
		ProductID: productID,
		PricingPlanID: core.StringPtr(pricingPlanID),
	}
}

// SetProductID : Allow user to set ProductID
func (_options *GetPlanOptions) SetProductID(productID *strfmt.UUID) *GetPlanOptions {
	_options.ProductID = productID
	return _options
}

// SetPricingPlanID : Allow user to set PricingPlanID
func (_options *GetPlanOptions) SetPricingPlanID(pricingPlanID string) *GetPlanOptions {
	_options.PricingPlanID = core.StringPtr(pricingPlanID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetPlanOptions) SetHeaders(param map[string]string) *GetPlanOptions {
	options.Headers = param
	return options
}

// GetProductOptions : The GetProduct options.
type GetProductOptions struct {
	// The unique ID of the product. This ID can be obtained by calling the list products method and also can be found in
	// Partner Center.
	ProductID *strfmt.UUID `json:"productId" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetProductOptions : Instantiate GetProductOptions
func (*PartnerCenterSellV1) NewGetProductOptions(productID *strfmt.UUID) *GetProductOptions {
	return &GetProductOptions{
		ProductID: productID,
	}
}

// SetProductID : Allow user to set ProductID
func (_options *GetProductOptions) SetProductID(productID *strfmt.UUID) *GetProductOptions {
	_options.ProductID = productID
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetProductOptions) SetHeaders(param map[string]string) *GetProductOptions {
	options.Headers = param
	return options
}

// GetSupportChangeRequestOptions : The GetSupportChangeRequest options.
type GetSupportChangeRequestOptions struct {
	// The unique ID of the product. This ID can be obtained by calling the list products method and also can be found in
	// Partner Center.
	ProductID *strfmt.UUID `json:"productId" validate:"required"`

	// The resource ID of the change request. This ID can be obtained by getting the offering and finding the current
	// change request on it.
	ChangeRequestID *string `json:"changeRequestId" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSupportChangeRequestOptions : Instantiate GetSupportChangeRequestOptions
func (*PartnerCenterSellV1) NewGetSupportChangeRequestOptions(productID *strfmt.UUID, changeRequestID string) *GetSupportChangeRequestOptions {
	return &GetSupportChangeRequestOptions{
		ProductID: productID,
		ChangeRequestID: core.StringPtr(changeRequestID),
	}
}

// SetProductID : Allow user to set ProductID
func (_options *GetSupportChangeRequestOptions) SetProductID(productID *strfmt.UUID) *GetSupportChangeRequestOptions {
	_options.ProductID = productID
	return _options
}

// SetChangeRequestID : Allow user to set ChangeRequestID
func (_options *GetSupportChangeRequestOptions) SetChangeRequestID(changeRequestID string) *GetSupportChangeRequestOptions {
	_options.ChangeRequestID = core.StringPtr(changeRequestID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetSupportChangeRequestOptions) SetHeaders(param map[string]string) *GetSupportChangeRequestOptions {
	options.Headers = param
	return options
}

// GetSupportOptions : The GetSupport options.
type GetSupportOptions struct {
	// The unique ID of the product. This ID can be obtained by calling the list products method and also can be found in
	// Partner Center.
	ProductID *strfmt.UUID `json:"productId" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSupportOptions : Instantiate GetSupportOptions
func (*PartnerCenterSellV1) NewGetSupportOptions(productID *strfmt.UUID) *GetSupportOptions {
	return &GetSupportOptions{
		ProductID: productID,
	}
}

// SetProductID : Allow user to set ProductID
func (_options *GetSupportOptions) SetProductID(productID *strfmt.UUID) *GetSupportOptions {
	_options.ProductID = productID
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetSupportOptions) SetHeaders(param map[string]string) *GetSupportOptions {
	options.Headers = param
	return options
}

// HighlightSection : The attributes of the product that differentiate it in the market.
type HighlightSection struct {
	// The description about the features of the product.
	Description *string `json:"description,omitempty"`

	// The description about the features of the product in translation.
	DescriptionI18n interface{} `json:"description_i18n,omitempty"`

	// The descriptive title for the feature.
	Title *string `json:"title,omitempty"`

	// The descriptive title for the feature in translation.
	TitleI18n interface{} `json:"title_i18n,omitempty"`
}

// UnmarshalHighlightSection unmarshals an instance of HighlightSection from the specified map of raw messages.
func UnmarshalHighlightSection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(HighlightSection)
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description_i18n", &obj.DescriptionI18n)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "title", &obj.Title)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "title_i18n", &obj.TitleI18n)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// HighlightSectionInput : The attributes of the product that differentiate it in the market.
type HighlightSectionInput struct {
	// The description about the features of the product.
	Description *string `json:"description,omitempty"`

	// The descriptive title for the feature.
	Title *string `json:"title,omitempty"`
}

// UnmarshalHighlightSectionInput unmarshals an instance of HighlightSectionInput from the specified map of raw messages.
func UnmarshalHighlightSectionInput(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(HighlightSectionInput)
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "title", &obj.Title)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// HistoryItem : HistoryItem struct
type HistoryItem struct {
	// The time when you requested approval.
	At *string `json:"at" validate:"required"`

	// The name of the user, who managed the approval request.
	DisplayName *string `json:"displayName,omitempty"`

	// The event that happened during the approval request.
	Event *string `json:"event,omitempty"`

	// The message from IBM Cloud approvers about the state of the approval request.
	Reason *string `json:"reason,omitempty"`

	// The email address of the user.
	Username *string `json:"username,omitempty"`
}

// UnmarshalHistoryItem unmarshals an instance of HistoryItem from the specified map of raw messages.
func UnmarshalHistoryItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(HistoryItem)
	err = core.UnmarshalPrimitive(m, "at", &obj.At)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "displayName", &obj.DisplayName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "event", &obj.Event)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reason", &obj.Reason)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "username", &obj.Username)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// License : The pricing model for your product.
type License struct {
	// The description of the pricing model.
	Description *string `json:"description" validate:"required"`

	// The ID of the pricing plan. This ID can be used for further pricing plan updates.
	ID *string `json:"id" validate:"required"`

	// The name of the pricing plan.
	Label *string `json:"label" validate:"required"`

	// The type of the pricing plan.
	Type *string `json:"type" validate:"required"`

	// The URL to where your customers can purchase the license that is required to use your product.
	URL *string `json:"url" validate:"required"`
}

// Constants associated with the License.Type property.
// The type of the pricing plan.
const (
	License_Type_Byol = "byol"
)

// UnmarshalLicense unmarshals an instance of License from the specified map of raw messages.
func UnmarshalLicense(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(License)
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "label", &obj.Label)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ListBadgesOptions : The ListBadges options.
type ListBadgesOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListBadgesOptions : Instantiate ListBadgesOptions
func (*PartnerCenterSellV1) NewListBadgesOptions() *ListBadgesOptions {
	return &ListBadgesOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *ListBadgesOptions) SetHeaders(param map[string]string) *ListBadgesOptions {
	options.Headers = param
	return options
}

// ListPlansOptions : The ListPlans options.
type ListPlansOptions struct {
	// The unique ID of the product. This ID can be obtained by calling the list products method and also can be found in
	// Partner Center.
	ProductID *strfmt.UUID `json:"productId" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListPlansOptions : Instantiate ListPlansOptions
func (*PartnerCenterSellV1) NewListPlansOptions(productID *strfmt.UUID) *ListPlansOptions {
	return &ListPlansOptions{
		ProductID: productID,
	}
}

// SetProductID : Allow user to set ProductID
func (_options *ListPlansOptions) SetProductID(productID *strfmt.UUID) *ListPlansOptions {
	_options.ProductID = productID
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListPlansOptions) SetHeaders(param map[string]string) *ListPlansOptions {
	options.Headers = param
	return options
}

// ListPlansResponse : ListPlansResponse struct
type ListPlansResponse struct {
	Plans []License `json:"plans,omitempty"`
}

// UnmarshalListPlansResponse unmarshals an instance of ListPlansResponse from the specified map of raw messages.
func UnmarshalListPlansResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ListPlansResponse)
	err = core.UnmarshalModel(m, "plans", &obj.Plans, UnmarshalLicense)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ListProductApprovalsOptions : The ListProductApprovals options.
type ListProductApprovalsOptions struct {
	// The unique ID of the product. This ID can be obtained by calling the list products method and also can be found in
	// Partner Center.
	ProductID *strfmt.UUID `json:"productId" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListProductApprovalsOptions : Instantiate ListProductApprovalsOptions
func (*PartnerCenterSellV1) NewListProductApprovalsOptions(productID *strfmt.UUID) *ListProductApprovalsOptions {
	return &ListProductApprovalsOptions{
		ProductID: productID,
	}
}

// SetProductID : Allow user to set ProductID
func (_options *ListProductApprovalsOptions) SetProductID(productID *strfmt.UUID) *ListProductApprovalsOptions {
	_options.ProductID = productID
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListProductApprovalsOptions) SetHeaders(param map[string]string) *ListProductApprovalsOptions {
	options.Headers = param
	return options
}

// ListProductApprovalsResponse : ListProductApprovalsResponse struct
type ListProductApprovalsResponse struct {
	Approvals []Resource `json:"approvals,omitempty"`
}

// UnmarshalListProductApprovalsResponse unmarshals an instance of ListProductApprovalsResponse from the specified map of raw messages.
func UnmarshalListProductApprovalsResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ListProductApprovalsResponse)
	err = core.UnmarshalModel(m, "approvals", &obj.Approvals, UnmarshalResource)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ListProductsOptions : The ListProducts options.
type ListProductsOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListProductsOptions : Instantiate ListProductsOptions
func (*PartnerCenterSellV1) NewListProductsOptions() *ListProductsOptions {
	return &ListProductsOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *ListProductsOptions) SetHeaders(param map[string]string) *ListProductsOptions {
	options.Headers = param
	return options
}

// ListProductsResponse : ListProductsResponse struct
type ListProductsResponse struct {
	Errors []Error `json:"errors,omitempty"`

	Products []ProductDetails `json:"products,omitempty"`
}

// UnmarshalListProductsResponse unmarshals an instance of ListProductsResponse from the specified map of raw messages.
func UnmarshalListProductsResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ListProductsResponse)
	err = core.UnmarshalModel(m, "errors", &obj.Errors, UnmarshalError)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "products", &obj.Products, UnmarshalProductDetails)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ListSupportChangeRequestReviewsOptions : The ListSupportChangeRequestReviews options.
type ListSupportChangeRequestReviewsOptions struct {
	// The unique ID of the product. This ID can be obtained by calling the list products method and also can be found in
	// Partner Center.
	ProductID *strfmt.UUID `json:"productId" validate:"required"`

	// The resource ID of the change request. This ID can be obtained by getting the offering and finding the current
	// change request on it.
	ChangeRequestID *string `json:"changeRequestId" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListSupportChangeRequestReviewsOptions : Instantiate ListSupportChangeRequestReviewsOptions
func (*PartnerCenterSellV1) NewListSupportChangeRequestReviewsOptions(productID *strfmt.UUID, changeRequestID string) *ListSupportChangeRequestReviewsOptions {
	return &ListSupportChangeRequestReviewsOptions{
		ProductID: productID,
		ChangeRequestID: core.StringPtr(changeRequestID),
	}
}

// SetProductID : Allow user to set ProductID
func (_options *ListSupportChangeRequestReviewsOptions) SetProductID(productID *strfmt.UUID) *ListSupportChangeRequestReviewsOptions {
	_options.ProductID = productID
	return _options
}

// SetChangeRequestID : Allow user to set ChangeRequestID
func (_options *ListSupportChangeRequestReviewsOptions) SetChangeRequestID(changeRequestID string) *ListSupportChangeRequestReviewsOptions {
	_options.ChangeRequestID = core.StringPtr(changeRequestID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListSupportChangeRequestReviewsOptions) SetHeaders(param map[string]string) *ListSupportChangeRequestReviewsOptions {
	options.Headers = param
	return options
}

// ListSupportChangeRequestsOptions : The ListSupportChangeRequests options.
type ListSupportChangeRequestsOptions struct {
	// The unique ID of the product. This ID can be obtained by calling the list products method and also can be found in
	// Partner Center.
	ProductID *strfmt.UUID `json:"productId" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListSupportChangeRequestsOptions : Instantiate ListSupportChangeRequestsOptions
func (*PartnerCenterSellV1) NewListSupportChangeRequestsOptions(productID *strfmt.UUID) *ListSupportChangeRequestsOptions {
	return &ListSupportChangeRequestsOptions{
		ProductID: productID,
	}
}

// SetProductID : Allow user to set ProductID
func (_options *ListSupportChangeRequestsOptions) SetProductID(productID *strfmt.UUID) *ListSupportChangeRequestsOptions {
	_options.ProductID = productID
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListSupportChangeRequestsOptions) SetHeaders(param map[string]string) *ListSupportChangeRequestsOptions {
	options.Headers = param
	return options
}

// ListSupportChangeRequestsResponse : ListSupportChangeRequestsResponse struct
type ListSupportChangeRequestsResponse struct {
	Changes []ChangeRequest `json:"changes,omitempty"`
}

// UnmarshalListSupportChangeRequestsResponse unmarshals an instance of ListSupportChangeRequestsResponse from the specified map of raw messages.
func UnmarshalListSupportChangeRequestsResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ListSupportChangeRequestsResponse)
	err = core.UnmarshalModel(m, "changes", &obj.Changes, UnmarshalChangeRequest)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// MediaSection : MediaSection struct
type MediaSection struct {
	// Provide a brief explanation that indicates what the media illustrates. This caption is displayed in the catalog.
	Caption *string `json:"caption" validate:"required"`

	// The brief explanation for your images and videos in translation.
	CaptionI18n interface{} `json:"caption_i18n,omitempty"`

	// The reduced-size version of your images and videos.
	Thumbnail *string `json:"thumbnail,omitempty"`

	// The type of the media.
	Type *string `json:"type" validate:"required"`

	// The URL that links to the media that shows off the product.
	URL *string `json:"url" validate:"required"`
}

// Constants associated with the MediaSection.Type property.
// The type of the media.
const (
	MediaSection_Type_Image = "image"
	MediaSection_Type_VideoMp4 = "video/mp4"
	MediaSection_Type_VideoWebm = "video/webm"
	MediaSection_Type_Youtube = "youtube"
)

// UnmarshalMediaSection unmarshals an instance of MediaSection from the specified map of raw messages.
func UnmarshalMediaSection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(MediaSection)
	err = core.UnmarshalPrimitive(m, "caption", &obj.Caption)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "caption_i18n", &obj.CaptionI18n)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "thumbnail", &obj.Thumbnail)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// MediaSectionInput : MediaSectionInput struct
type MediaSectionInput struct {
	// Provide a brief explanation that indicates what the media illustrates. This caption is displayed in the catalog.
	Caption *string `json:"caption" validate:"required"`

	// The reduced-size version of your images and videos.
	Thumbnail *string `json:"thumbnail,omitempty"`

	// The type of the media.
	Type *string `json:"type" validate:"required"`

	// The URL that links to the media that shows off the product.
	URL *string `json:"url" validate:"required"`
}

// Constants associated with the MediaSectionInput.Type property.
// The type of the media.
const (
	MediaSectionInput_Type_Image = "image"
	MediaSectionInput_Type_VideoMp4 = "video/mp4"
	MediaSectionInput_Type_VideoWebm = "video/webm"
	MediaSectionInput_Type_Youtube = "youtube"
)

// NewMediaSectionInput : Instantiate MediaSectionInput (Generic Model Constructor)
func (*PartnerCenterSellV1) NewMediaSectionInput(caption string, typeVar string, url string) (_model *MediaSectionInput, err error) {
	_model = &MediaSectionInput{
		Caption: core.StringPtr(caption),
		Type: core.StringPtr(typeVar),
		URL: core.StringPtr(url),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalMediaSectionInput unmarshals an instance of MediaSectionInput from the specified map of raw messages.
func UnmarshalMediaSectionInput(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(MediaSectionInput)
	err = core.UnmarshalPrimitive(m, "caption", &obj.Caption)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "thumbnail", &obj.Thumbnail)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// MergeSupportChangeRequestOptions : The MergeSupportChangeRequest options.
type MergeSupportChangeRequestOptions struct {
	// The unique ID of the product. This ID can be obtained by calling the list products method and also can be found in
	// Partner Center.
	ProductID *strfmt.UUID `json:"productId" validate:"required"`

	// The resource ID of the change request. This ID can be obtained by getting the offering and finding the current
	// change request on it.
	ChangeRequestID *string `json:"changeRequestId" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewMergeSupportChangeRequestOptions : Instantiate MergeSupportChangeRequestOptions
func (*PartnerCenterSellV1) NewMergeSupportChangeRequestOptions(productID *strfmt.UUID, changeRequestID string) *MergeSupportChangeRequestOptions {
	return &MergeSupportChangeRequestOptions{
		ProductID: productID,
		ChangeRequestID: core.StringPtr(changeRequestID),
	}
}

// SetProductID : Allow user to set ProductID
func (_options *MergeSupportChangeRequestOptions) SetProductID(productID *strfmt.UUID) *MergeSupportChangeRequestOptions {
	_options.ProductID = productID
	return _options
}

// SetChangeRequestID : Allow user to set ChangeRequestID
func (_options *MergeSupportChangeRequestOptions) SetChangeRequestID(changeRequestID string) *MergeSupportChangeRequestOptions {
	_options.ChangeRequestID = core.StringPtr(changeRequestID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *MergeSupportChangeRequestOptions) SetHeaders(param map[string]string) *MergeSupportChangeRequestOptions {
	options.Headers = param
	return options
}

// ProductDetails : The details of the product.
type ProductDetails struct {
	// The unique ID for the account in which the product is being onboarded.
	AccountID *string `json:"accountId,omitempty"`

	// The time when the new product was created in standard ISO 8601 format.
	CreatedAt *string `json:"createdAt,omitempty"`

	// The ID that uniquely identifies the product in Partner Center. This ID can be found on the Dashboard tab in Partner
	// Center.
	ID *string `json:"id,omitempty"`

	// The confirmation that your company is authorized to use all materials.
	MaterialAgreement *bool `json:"materialAgreement,omitempty"`

	// The type of the product that you want to onboard to IBM Cloud.
	ProductType *string `json:"productType,omitempty"`

	// The name of the product that you are onboarding. This name is displayed to users when you publish your product in
	// the catalog.
	ProductName *string `json:"productName,omitempty"`

	// The time when the new product was published to the IBM Cloud catalog in standard ISO 8601 format.
	PublishedAt *string `json:"publishedAt,omitempty"`

	// The tax assessment for your product.
	TaxAssessment *string `json:"taxAssessment,omitempty"`

	// The time when the product was updated in standard ISO 8601 format.
	UpdatedAt *string `json:"updatedAt,omitempty"`

	ChangeRequests []ChangeRequest `json:"changeRequests,omitempty"`
}

// Constants associated with the ProductDetails.ProductType property.
// The type of the product that you want to onboard to IBM Cloud.
const (
	ProductDetails_ProductType_Module = "MODULE"
	ProductDetails_ProductType_Service = "SERVICE"
	ProductDetails_ProductType_Software = "SOFTWARE"
	ProductDetails_ProductType_Solution = "SOLUTION"
)

// Constants associated with the ProductDetails.TaxAssessment property.
// The tax assessment for your product.
const (
	ProductDetails_TaxAssessment_Iaas = "IAAS"
	ProductDetails_TaxAssessment_Paas = "PAAS"
	ProductDetails_TaxAssessment_Saas = "SAAS"
	ProductDetails_TaxAssessment_Software = "SOFTWARE"
)

// UnmarshalProductDetails unmarshals an instance of ProductDetails from the specified map of raw messages.
func UnmarshalProductDetails(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ProductDetails)
	err = core.UnmarshalPrimitive(m, "accountId", &obj.AccountID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "createdAt", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "materialAgreement", &obj.MaterialAgreement)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "productType", &obj.ProductType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "productName", &obj.ProductName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "publishedAt", &obj.PublishedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "taxAssessment", &obj.TaxAssessment)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updatedAt", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "changeRequests", &obj.ChangeRequests, UnmarshalChangeRequest)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PublishProductOptions : The PublishProduct options.
type PublishProductOptions struct {
	// The unique ID of the product. This ID can be obtained by calling the list products method and also can be found in
	// Partner Center.
	ProductID *strfmt.UUID `json:"productId" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPublishProductOptions : Instantiate PublishProductOptions
func (*PartnerCenterSellV1) NewPublishProductOptions(productID *strfmt.UUID) *PublishProductOptions {
	return &PublishProductOptions{
		ProductID: productID,
	}
}

// SetProductID : Allow user to set ProductID
func (_options *PublishProductOptions) SetProductID(productID *strfmt.UUID) *PublishProductOptions {
	_options.ProductID = productID
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PublishProductOptions) SetHeaders(param map[string]string) *PublishProductOptions {
	options.Headers = param
	return options
}

// RequestCatalogApprovalOptions : The RequestCatalogApproval options.
type RequestCatalogApprovalOptions struct {
	// The unique ID of the product. This ID can be obtained by calling the list products method and also can be found in
	// Partner Center.
	ProductID *strfmt.UUID `json:"productId" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewRequestCatalogApprovalOptions : Instantiate RequestCatalogApprovalOptions
func (*PartnerCenterSellV1) NewRequestCatalogApprovalOptions(productID *strfmt.UUID) *RequestCatalogApprovalOptions {
	return &RequestCatalogApprovalOptions{
		ProductID: productID,
	}
}

// SetProductID : Allow user to set ProductID
func (_options *RequestCatalogApprovalOptions) SetProductID(productID *strfmt.UUID) *RequestCatalogApprovalOptions {
	_options.ProductID = productID
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *RequestCatalogApprovalOptions) SetHeaders(param map[string]string) *RequestCatalogApprovalOptions {
	options.Headers = param
	return options
}

// RequestProductApprovalOptions : The RequestProductApproval options.
type RequestProductApprovalOptions struct {
	// The unique ID of the product. This ID can be obtained by calling the list products method and also can be found in
	// Partner Center.
	ProductID *strfmt.UUID `json:"productId" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewRequestProductApprovalOptions : Instantiate RequestProductApprovalOptions
func (*PartnerCenterSellV1) NewRequestProductApprovalOptions(productID *strfmt.UUID) *RequestProductApprovalOptions {
	return &RequestProductApprovalOptions{
		ProductID: productID,
	}
}

// SetProductID : Allow user to set ProductID
func (_options *RequestProductApprovalOptions) SetProductID(productID *strfmt.UUID) *RequestProductApprovalOptions {
	_options.ProductID = productID
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *RequestProductApprovalOptions) SetHeaders(param map[string]string) *RequestProductApprovalOptions {
	options.Headers = param
	return options
}

// RequestSupportApprovalOptions : The RequestSupportApproval options.
type RequestSupportApprovalOptions struct {
	// The unique ID of the product. This ID can be obtained by calling the list products method and also can be found in
	// Partner Center.
	ProductID *strfmt.UUID `json:"productId" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewRequestSupportApprovalOptions : Instantiate RequestSupportApprovalOptions
func (*PartnerCenterSellV1) NewRequestSupportApprovalOptions(productID *strfmt.UUID) *RequestSupportApprovalOptions {
	return &RequestSupportApprovalOptions{
		ProductID: productID,
	}
}

// SetProductID : Allow user to set ProductID
func (_options *RequestSupportApprovalOptions) SetProductID(productID *strfmt.UUID) *RequestSupportApprovalOptions {
	_options.ProductID = productID
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *RequestSupportApprovalOptions) SetHeaders(param map[string]string) *RequestSupportApprovalOptions {
	options.Headers = param
	return options
}

// RequestSupportChangeRequestReviewOptions : The RequestSupportChangeRequestReview options.
type RequestSupportChangeRequestReviewOptions struct {
	// The unique ID of the product. This ID can be obtained by calling the list products method and also can be found in
	// Partner Center.
	ProductID *strfmt.UUID `json:"productId" validate:"required"`

	// The resource ID of the change request. This ID can be obtained by getting the offering and finding the current
	// change request on it.
	ChangeRequestID *string `json:"changeRequestId" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewRequestSupportChangeRequestReviewOptions : Instantiate RequestSupportChangeRequestReviewOptions
func (*PartnerCenterSellV1) NewRequestSupportChangeRequestReviewOptions(productID *strfmt.UUID, changeRequestID string) *RequestSupportChangeRequestReviewOptions {
	return &RequestSupportChangeRequestReviewOptions{
		ProductID: productID,
		ChangeRequestID: core.StringPtr(changeRequestID),
	}
}

// SetProductID : Allow user to set ProductID
func (_options *RequestSupportChangeRequestReviewOptions) SetProductID(productID *strfmt.UUID) *RequestSupportChangeRequestReviewOptions {
	_options.ProductID = productID
	return _options
}

// SetChangeRequestID : Allow user to set ChangeRequestID
func (_options *RequestSupportChangeRequestReviewOptions) SetChangeRequestID(changeRequestID string) *RequestSupportChangeRequestReviewOptions {
	_options.ChangeRequestID = core.StringPtr(changeRequestID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *RequestSupportChangeRequestReviewOptions) SetHeaders(param map[string]string) *RequestSupportChangeRequestReviewOptions {
	options.Headers = param
	return options
}

// Resource : The details of the catalog listing approval request.
type Resource struct {
	// Shows the details of the approval.
	History []HistoryItem `json:"history,omitempty"`

	// The ID that uniquely identifies the product in Partner Center. This ID can be found on the Dashboard tab in Partner
	// Center.
	ID *string `json:"id" validate:"required"`

	// The events after requesting an approval.
	NextEvents []string `json:"nextEvents,omitempty"`

	// The state of the approval.
	State *State `json:"state" validate:"required"`
}

// UnmarshalResource unmarshals an instance of Resource from the specified map of raw messages.
func UnmarshalResource(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Resource)
	err = core.UnmarshalModel(m, "history", &obj.History, UnmarshalHistoryItem)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "nextEvents", &obj.NextEvents)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "state", &obj.State, UnmarshalState)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RestoreProductOptions : The RestoreProduct options.
type RestoreProductOptions struct {
	// The unique ID of the product. This ID can be obtained by calling the list products method and also can be found in
	// Partner Center.
	ProductID *strfmt.UUID `json:"productId" validate:"required"`

	// The reason why you want to restore your deprecated product.
	Reason *string `json:"reason" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewRestoreProductOptions : Instantiate RestoreProductOptions
func (*PartnerCenterSellV1) NewRestoreProductOptions(productID *strfmt.UUID, reason string) *RestoreProductOptions {
	return &RestoreProductOptions{
		ProductID: productID,
		Reason: core.StringPtr(reason),
	}
}

// SetProductID : Allow user to set ProductID
func (_options *RestoreProductOptions) SetProductID(productID *strfmt.UUID) *RestoreProductOptions {
	_options.ProductID = productID
	return _options
}

// SetReason : Allow user to set Reason
func (_options *RestoreProductOptions) SetReason(reason string) *RestoreProductOptions {
	_options.Reason = core.StringPtr(reason)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *RestoreProductOptions) SetHeaders(param map[string]string) *RestoreProductOptions {
	options.Headers = param
	return options
}

// State : The state of the approval.
type State struct {
	// The name of the approval state.
	Name *string `json:"name" validate:"required"`
}

// Constants associated with the State.Name property.
// The name of the approval state.
const (
	State_Name_Deprecated = "deprecated"
	State_Name_Pendingapproval = "pendingApproval"
	State_Name_Published = "published"
	State_Name_Suspended = "suspended"
	State_Name_Waitingfordeprecation = "waitingForDeprecation"
	State_Name_Waitingfordeprecationaftersuspension = "waitingForDeprecationAfterSuspension"
	State_Name_Waitingforpublish = "waitingForPublish"
	State_Name_Waitingforrequestforreview = "waitingForRequestForReview"
)

// UnmarshalState unmarshals an instance of State from the specified map of raw messages.
func UnmarshalState(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(State)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Support : Provide details about how customers can get help when they are using your product.
type Support struct {
	// The locations where your support team is providing support from.
	Locations []string `json:"locations,omitempty"`

	// Provide details about how and when customers can get in touch with your support team.
	Process *string `json:"process,omitempty"`

	// Translated strings for the support process describing how and when customers can get in touch with your support
	// team.
	ProcessI18n interface{} `json:"process_i18n,omitempty"`

	// Provide details for the available options for getting support. The details that you provide are displayed on your
	// product details page in the catalog.
	SupportDetails []SupportDetails `json:"support_details,omitempty"`

	// The details about your support escalation process. The details that you provide are displayed on your product
	// details page in the catalog.
	SupportEscalation *SupportEscalation `json:"support_escalation,omitempty"`

	// The provider type for support of your product.
	SupportType *string `json:"support_type,omitempty"`

	// The support site URL where users can go to get help, answer their questions, or ask experts and the community for
	// help.
	URL *string `json:"url,omitempty"`
}

// Constants associated with the Support.SupportType property.
// The provider type for support of your product.
const (
	Support_SupportType_Community = "community"
	Support_SupportType_ThirdParty = "third-party"
)

// UnmarshalSupport unmarshals an instance of Support from the specified map of raw messages.
func UnmarshalSupport(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Support)
	err = core.UnmarshalPrimitive(m, "locations", &obj.Locations)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "process", &obj.Process)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "process_i18n", &obj.ProcessI18n)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "support_details", &obj.SupportDetails, UnmarshalSupportDetails)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "support_escalation", &obj.SupportEscalation, UnmarshalSupportEscalation)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "support_type", &obj.SupportType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SupportDetails : Provide details about the available options for getting support. The details that you provide are displayed on your
// product details page in the catalog.
type SupportDetails struct {
	// The details about the availability of your support service. At minimum, your support service must be available 8
	// hours a day, Monday through Friday.
	Availability *SupportDetailsAvailability `json:"availability,omitempty"`

	// Provide your support contact information. Don't include details with personal information, for example personal
	// emails.
	Contact *string `json:"contact,omitempty"`

	// The minimum number of hours that it takes to update your customers about a support case.
	ResponseWaitTime *SupportResponseTimes `json:"response_wait_time,omitempty"`

	// Provide information about how your customers can get support.
	Type *string `json:"type,omitempty"`
}

// Constants associated with the SupportDetails.Type property.
// Provide information about how your customers can get support.
const (
	SupportDetails_Type_Chat = "chat"
	SupportDetails_Type_Email = "email"
	SupportDetails_Type_Other = "other"
	SupportDetails_Type_Phone = "phone"
	SupportDetails_Type_Slack = "slack"
)

// UnmarshalSupportDetails unmarshals an instance of SupportDetails from the specified map of raw messages.
func UnmarshalSupportDetails(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SupportDetails)
	err = core.UnmarshalModel(m, "availability", &obj.Availability, UnmarshalSupportDetailsAvailability)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "contact", &obj.Contact)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "response_wait_time", &obj.ResponseWaitTime, UnmarshalSupportResponseTimes)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SupportDetailsAvailability : The details about the availability of your support service. At minimum, your support service must be available 8
// hours a day, Monday through Friday.
type SupportDetailsAvailability struct {
	// Support is available at any time.
	AlwaysAvailable *bool `json:"always_available,omitempty"`

	// The times when your support service is available for your customers.
	Times []SupportDetailsAvailabilityTimes `json:"times,omitempty"`

	// The timezone in which provided support is available.
	Timezone *string `json:"timezone,omitempty"`
}

// UnmarshalSupportDetailsAvailability unmarshals an instance of SupportDetailsAvailability from the specified map of raw messages.
func UnmarshalSupportDetailsAvailability(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SupportDetailsAvailability)
	err = core.UnmarshalPrimitive(m, "always_available", &obj.AlwaysAvailable)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "times", &obj.Times, UnmarshalSupportDetailsAvailabilityTimes)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "timezone", &obj.Timezone)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SupportDetailsAvailabilityTimes : The details about the availability of product support. At minimum, your support service must be available 8 hours a
// day, Monday through Friday.
type SupportDetailsAvailabilityTimes struct {
	// The days when your support service is available throughout the week. The seven days of the week are defined as
	// numbers from 1 to 7. If your support service is available on Mondays and Wednesdays, enter numbers 1 and 3.
	Day *int64 `json:"day,omitempty"`

	// The time in `hh:mm` format when support ends each day when your support coverage is listed as available.
	EndTime *string `json:"end_time,omitempty"`

	// The time in `hh:mm` format when support starts each day when your support coverage is listed as available.
	StartTime *string `json:"start_time,omitempty"`
}

// UnmarshalSupportDetailsAvailabilityTimes unmarshals an instance of SupportDetailsAvailabilityTimes from the specified map of raw messages.
func UnmarshalSupportDetailsAvailabilityTimes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SupportDetailsAvailabilityTimes)
	err = core.UnmarshalPrimitive(m, "day", &obj.Day)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "end_time", &obj.EndTime)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "start_time", &obj.StartTime)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SupportEscalation : The details about your support escalation process. The details that you provide are displayed on your product details
// page in the catalog.
type SupportEscalation struct {
	// The direct contact for IBM Cloud Support leaders to communicate with the support leaders of your product. This
	// contact information is not displayed on the product details page in the catalog.
	Contact *string `json:"contact,omitempty"`

	// The number of hours that your customers need to wait before escalating a case.
	EscalationWaitTime *SupportEscalationTimes `json:"escalation_wait_time,omitempty"`

	// The minimum number of hours that it takes to update your customers about a support case.
	ResponseWaitTime *SupportResponseTimes `json:"response_wait_time,omitempty"`
}

// UnmarshalSupportEscalation unmarshals an instance of SupportEscalation from the specified map of raw messages.
func UnmarshalSupportEscalation(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SupportEscalation)
	err = core.UnmarshalPrimitive(m, "contact", &obj.Contact)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "escalation_wait_time", &obj.EscalationWaitTime, UnmarshalSupportEscalationTimes)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "response_wait_time", &obj.ResponseWaitTime, UnmarshalSupportResponseTimes)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SupportEscalationTimes : The number of hours that your customers need to wait before escalating a case.
type SupportEscalationTimes struct {
	Type *string `json:"type,omitempty"`

	// The amount of hours.
	Value *int64 `json:"value,omitempty"`
}

// Constants associated with the SupportEscalationTimes.Type property.
const (
	SupportEscalationTimes_Type_Hour = "hour"
)

// UnmarshalSupportEscalationTimes unmarshals an instance of SupportEscalationTimes from the specified map of raw messages.
func UnmarshalSupportEscalationTimes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SupportEscalationTimes)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SupportResponseTimes : The minimum number of hours that it takes to update your customers about a support case.
type SupportResponseTimes struct {
	Type *string `json:"type,omitempty"`

	// The amount of hours.
	Value *int64 `json:"value,omitempty"`
}

// Constants associated with the SupportResponseTimes.Type property.
const (
	SupportResponseTimes_Type_Hour = "hour"
)

// UnmarshalSupportResponseTimes unmarshals an instance of SupportResponseTimes from the specified map of raw messages.
func UnmarshalSupportResponseTimes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SupportResponseTimes)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SuspendProductOptions : The SuspendProduct options.
type SuspendProductOptions struct {
	// The unique ID of the product. This ID can be obtained by calling the list products method and also can be found in
	// Partner Center.
	ProductID *strfmt.UUID `json:"productId" validate:"required"`

	// The reason why you want to suspend your published product.
	Reason *string `json:"reason" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewSuspendProductOptions : Instantiate SuspendProductOptions
func (*PartnerCenterSellV1) NewSuspendProductOptions(productID *strfmt.UUID, reason string) *SuspendProductOptions {
	return &SuspendProductOptions{
		ProductID: productID,
		Reason: core.StringPtr(reason),
	}
}

// SetProductID : Allow user to set ProductID
func (_options *SuspendProductOptions) SetProductID(productID *strfmt.UUID) *SuspendProductOptions {
	_options.ProductID = productID
	return _options
}

// SetReason : Allow user to set Reason
func (_options *SuspendProductOptions) SetReason(reason string) *SuspendProductOptions {
	_options.Reason = core.StringPtr(reason)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *SuspendProductOptions) SetHeaders(param map[string]string) *SuspendProductOptions {
	options.Headers = param
	return options
}

// UpdateCatalogOptions : The UpdateCatalog options.
type UpdateCatalogOptions struct {
	// The unique ID of the product. This ID can be obtained by calling the list products method and also can be found in
	// Partner Center.
	ProductID *strfmt.UUID `json:"productId" validate:"required"`

	// The ID of the private catalog where your products are created.
	CatalogID *string `json:"catalogId,omitempty"`

	// The description of the product.
	Description *string `json:"description,omitempty"`

	// The URL for your company or product logo.
	IconURL *string `json:"iconUrl,omitempty"`

	// The key search terms that are associated with your product.
	Keywords []string `json:"keywords,omitempty"`

	// The pricing model for your product.
	PricingModel *string `json:"pricingModel,omitempty"`

	// A list of values that are used to categorize products in the catalog. By using the Catalogs management CLI plug-in,
	// run the `ibmcloud catalog offering category-options` CLI command to list all possible values.
	Category *string `json:"category,omitempty"`

	ProviderType []string `json:"providerType,omitempty"`

	// The name of the product.
	Label *string `json:"label,omitempty"`

	// The name of the product.
	Name *string `json:"name,omitempty"`

	// The name of your company.
	Provider *string `json:"provider,omitempty"`

	// The keywords and phrases that are associated with your product.
	Tags []string `json:"tags,omitempty"`

	// The link to the warranted product documentation.
	DocumentationURL *string `json:"documentationUrl,omitempty"`

	// The attributes of the product that differentiate it in the market.
	Highlights []HighlightSectionInput `json:"highlights,omitempty"`

	// The description about the details of the product. You can use markdown syntax to provide this description.
	LongDescription *string `json:"longDescription,omitempty"`

	// The images or videos that show off the product.
	Media []MediaSectionInput `json:"media,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the UpdateCatalogOptions.PricingModel property.
// The pricing model for your product.
const (
	UpdateCatalogOptions_PricingModel_Byol = "byol"
	UpdateCatalogOptions_PricingModel_Free = "free"
)

// Constants associated with the UpdateCatalogOptions.ProviderType property.
const (
	UpdateCatalogOptions_ProviderType_IbmCommunity = "ibm_community"
	UpdateCatalogOptions_ProviderType_IbmThirdParty = "ibm_third_party"
)

// NewUpdateCatalogOptions : Instantiate UpdateCatalogOptions
func (*PartnerCenterSellV1) NewUpdateCatalogOptions(productID *strfmt.UUID) *UpdateCatalogOptions {
	return &UpdateCatalogOptions{
		ProductID: productID,
	}
}

// SetProductID : Allow user to set ProductID
func (_options *UpdateCatalogOptions) SetProductID(productID *strfmt.UUID) *UpdateCatalogOptions {
	_options.ProductID = productID
	return _options
}

// SetCatalogID : Allow user to set CatalogID
func (_options *UpdateCatalogOptions) SetCatalogID(catalogID string) *UpdateCatalogOptions {
	_options.CatalogID = core.StringPtr(catalogID)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *UpdateCatalogOptions) SetDescription(description string) *UpdateCatalogOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetIconURL : Allow user to set IconURL
func (_options *UpdateCatalogOptions) SetIconURL(iconURL string) *UpdateCatalogOptions {
	_options.IconURL = core.StringPtr(iconURL)
	return _options
}

// SetKeywords : Allow user to set Keywords
func (_options *UpdateCatalogOptions) SetKeywords(keywords []string) *UpdateCatalogOptions {
	_options.Keywords = keywords
	return _options
}

// SetPricingModel : Allow user to set PricingModel
func (_options *UpdateCatalogOptions) SetPricingModel(pricingModel string) *UpdateCatalogOptions {
	_options.PricingModel = core.StringPtr(pricingModel)
	return _options
}

// SetCategory : Allow user to set Category
func (_options *UpdateCatalogOptions) SetCategory(category string) *UpdateCatalogOptions {
	_options.Category = core.StringPtr(category)
	return _options
}

// SetProviderType : Allow user to set ProviderType
func (_options *UpdateCatalogOptions) SetProviderType(providerType []string) *UpdateCatalogOptions {
	_options.ProviderType = providerType
	return _options
}

// SetLabel : Allow user to set Label
func (_options *UpdateCatalogOptions) SetLabel(label string) *UpdateCatalogOptions {
	_options.Label = core.StringPtr(label)
	return _options
}

// SetName : Allow user to set Name
func (_options *UpdateCatalogOptions) SetName(name string) *UpdateCatalogOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetProvider : Allow user to set Provider
func (_options *UpdateCatalogOptions) SetProvider(provider string) *UpdateCatalogOptions {
	_options.Provider = core.StringPtr(provider)
	return _options
}

// SetTags : Allow user to set Tags
func (_options *UpdateCatalogOptions) SetTags(tags []string) *UpdateCatalogOptions {
	_options.Tags = tags
	return _options
}

// SetDocumentationURL : Allow user to set DocumentationURL
func (_options *UpdateCatalogOptions) SetDocumentationURL(documentationURL string) *UpdateCatalogOptions {
	_options.DocumentationURL = core.StringPtr(documentationURL)
	return _options
}

// SetHighlights : Allow user to set Highlights
func (_options *UpdateCatalogOptions) SetHighlights(highlights []HighlightSectionInput) *UpdateCatalogOptions {
	_options.Highlights = highlights
	return _options
}

// SetLongDescription : Allow user to set LongDescription
func (_options *UpdateCatalogOptions) SetLongDescription(longDescription string) *UpdateCatalogOptions {
	_options.LongDescription = core.StringPtr(longDescription)
	return _options
}

// SetMedia : Allow user to set Media
func (_options *UpdateCatalogOptions) SetMedia(media []MediaSectionInput) *UpdateCatalogOptions {
	_options.Media = media
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateCatalogOptions) SetHeaders(param map[string]string) *UpdateCatalogOptions {
	options.Headers = param
	return options
}

// UpdatePlanOptions : The UpdatePlan options.
type UpdatePlanOptions struct {
	// The unique ID of the product. This ID can be obtained by calling the list products method and also can be found in
	// Partner Center.
	ProductID *strfmt.UUID `json:"productId" validate:"required"`

	// The resource ID of the pricing plan. This ID can be obtained by listing pricing plans.
	PricingPlanID *string `json:"pricingPlanId" validate:"required,ne="`

	// The description of the pricing model.
	Description *string `json:"description" validate:"required"`

	// The name of the pricing plan.
	Label *string `json:"label" validate:"required"`

	// The type of the pricing plan.
	Type *string `json:"type" validate:"required"`

	// The URL to where your customers can purchase the license that is required to use your product.
	URL *string `json:"url" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the UpdatePlanOptions.Type property.
// The type of the pricing plan.
const (
	UpdatePlanOptions_Type_Byol = "byol"
)

// NewUpdatePlanOptions : Instantiate UpdatePlanOptions
func (*PartnerCenterSellV1) NewUpdatePlanOptions(productID *strfmt.UUID, pricingPlanID string, description string, label string, typeVar string, url string) *UpdatePlanOptions {
	return &UpdatePlanOptions{
		ProductID: productID,
		PricingPlanID: core.StringPtr(pricingPlanID),
		Description: core.StringPtr(description),
		Label: core.StringPtr(label),
		Type: core.StringPtr(typeVar),
		URL: core.StringPtr(url),
	}
}

// SetProductID : Allow user to set ProductID
func (_options *UpdatePlanOptions) SetProductID(productID *strfmt.UUID) *UpdatePlanOptions {
	_options.ProductID = productID
	return _options
}

// SetPricingPlanID : Allow user to set PricingPlanID
func (_options *UpdatePlanOptions) SetPricingPlanID(pricingPlanID string) *UpdatePlanOptions {
	_options.PricingPlanID = core.StringPtr(pricingPlanID)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *UpdatePlanOptions) SetDescription(description string) *UpdatePlanOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetLabel : Allow user to set Label
func (_options *UpdatePlanOptions) SetLabel(label string) *UpdatePlanOptions {
	_options.Label = core.StringPtr(label)
	return _options
}

// SetType : Allow user to set Type
func (_options *UpdatePlanOptions) SetType(typeVar string) *UpdatePlanOptions {
	_options.Type = core.StringPtr(typeVar)
	return _options
}

// SetURL : Allow user to set URL
func (_options *UpdatePlanOptions) SetURL(url string) *UpdatePlanOptions {
	_options.URL = core.StringPtr(url)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdatePlanOptions) SetHeaders(param map[string]string) *UpdatePlanOptions {
	options.Headers = param
	return options
}

// UpdateProductOptions : The UpdateProduct options.
type UpdateProductOptions struct {
	// The unique ID of the product. This ID can be obtained by calling the list products method and also can be found in
	// Partner Center.
	ProductID *strfmt.UUID `json:"productId" validate:"required"`

	// The confirmation that your company is authorized to use all materials.
	MaterialAgreement *bool `json:"materialAgreement,omitempty"`

	// The name of the product that you are onboarding. This name is displayed to users when you publish your product in
	// the catalog.
	ProductName *string `json:"productName,omitempty"`

	// The tax assessment for your product.
	TaxAssessment *string `json:"taxAssessment,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the UpdateProductOptions.TaxAssessment property.
// The tax assessment for your product.
const (
	UpdateProductOptions_TaxAssessment_Software = "SOFTWARE"
)

// NewUpdateProductOptions : Instantiate UpdateProductOptions
func (*PartnerCenterSellV1) NewUpdateProductOptions(productID *strfmt.UUID) *UpdateProductOptions {
	return &UpdateProductOptions{
		ProductID: productID,
	}
}

// SetProductID : Allow user to set ProductID
func (_options *UpdateProductOptions) SetProductID(productID *strfmt.UUID) *UpdateProductOptions {
	_options.ProductID = productID
	return _options
}

// SetMaterialAgreement : Allow user to set MaterialAgreement
func (_options *UpdateProductOptions) SetMaterialAgreement(materialAgreement bool) *UpdateProductOptions {
	_options.MaterialAgreement = core.BoolPtr(materialAgreement)
	return _options
}

// SetProductName : Allow user to set ProductName
func (_options *UpdateProductOptions) SetProductName(productName string) *UpdateProductOptions {
	_options.ProductName = core.StringPtr(productName)
	return _options
}

// SetTaxAssessment : Allow user to set TaxAssessment
func (_options *UpdateProductOptions) SetTaxAssessment(taxAssessment string) *UpdateProductOptions {
	_options.TaxAssessment = core.StringPtr(taxAssessment)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateProductOptions) SetHeaders(param map[string]string) *UpdateProductOptions {
	options.Headers = param
	return options
}

// UpdateSupportChangeRequestOptions : The UpdateSupportChangeRequest options.
type UpdateSupportChangeRequestOptions struct {
	// The unique ID of the product. This ID can be obtained by calling the list products method and also can be found in
	// Partner Center.
	ProductID *strfmt.UUID `json:"productId" validate:"required"`

	// The resource ID of the change request. This ID can be obtained by getting the offering and finding the current
	// change request on it.
	ChangeRequestID *string `json:"changeRequestId" validate:"required,ne="`

	// Provide details about how customers can get help when they are using your product.
	Change *Support `json:"change" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateSupportChangeRequestOptions : Instantiate UpdateSupportChangeRequestOptions
func (*PartnerCenterSellV1) NewUpdateSupportChangeRequestOptions(productID *strfmt.UUID, changeRequestID string, change *Support) *UpdateSupportChangeRequestOptions {
	return &UpdateSupportChangeRequestOptions{
		ProductID: productID,
		ChangeRequestID: core.StringPtr(changeRequestID),
		Change: change,
	}
}

// SetProductID : Allow user to set ProductID
func (_options *UpdateSupportChangeRequestOptions) SetProductID(productID *strfmt.UUID) *UpdateSupportChangeRequestOptions {
	_options.ProductID = productID
	return _options
}

// SetChangeRequestID : Allow user to set ChangeRequestID
func (_options *UpdateSupportChangeRequestOptions) SetChangeRequestID(changeRequestID string) *UpdateSupportChangeRequestOptions {
	_options.ChangeRequestID = core.StringPtr(changeRequestID)
	return _options
}

// SetChange : Allow user to set Change
func (_options *UpdateSupportChangeRequestOptions) SetChange(change *Support) *UpdateSupportChangeRequestOptions {
	_options.Change = change
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateSupportChangeRequestOptions) SetHeaders(param map[string]string) *UpdateSupportChangeRequestOptions {
	options.Headers = param
	return options
}

// UpdateSupportOptions : The UpdateSupport options.
type UpdateSupportOptions struct {
	// The unique ID of the product. This ID can be obtained by calling the list products method and also can be found in
	// Partner Center.
	ProductID *strfmt.UUID `json:"productId" validate:"required"`

	// The direct contact for IBM Cloud Support leaders to communicate with the support leader of your product. This
	// contact information is not displayed on the product detail page in the catalog.
	EscalationContacts []EscalationContactsUpdate `json:"escalationContacts,omitempty"`

	// The locations where support is provided from.
	Locations []string `json:"locations,omitempty"`

	// Provide details about the available options for getting support. The details that you provide are displayed on your
	// product details page in the catalog.
	SupportDetails []SupportDetails `json:"support_details,omitempty"`

	// The details about your support escalation process. The details that you provide are displayed on your product
	// details page in the catalog.
	SupportEscalation *SupportEscalation `json:"support_escalation,omitempty"`

	// The provider type for support of your product.
	SupportType *string `json:"support_type,omitempty"`

	// The support site URL where users can go to get help, answer their questions, or ask experts and the community for
	// help.
	URL *string `json:"url,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the UpdateSupportOptions.SupportType property.
// The provider type for support of your product.
const (
	UpdateSupportOptions_SupportType_Community = "community"
	UpdateSupportOptions_SupportType_ThirdParty = "third-party"
)

// NewUpdateSupportOptions : Instantiate UpdateSupportOptions
func (*PartnerCenterSellV1) NewUpdateSupportOptions(productID *strfmt.UUID) *UpdateSupportOptions {
	return &UpdateSupportOptions{
		ProductID: productID,
	}
}

// SetProductID : Allow user to set ProductID
func (_options *UpdateSupportOptions) SetProductID(productID *strfmt.UUID) *UpdateSupportOptions {
	_options.ProductID = productID
	return _options
}

// SetEscalationContacts : Allow user to set EscalationContacts
func (_options *UpdateSupportOptions) SetEscalationContacts(escalationContacts []EscalationContactsUpdate) *UpdateSupportOptions {
	_options.EscalationContacts = escalationContacts
	return _options
}

// SetLocations : Allow user to set Locations
func (_options *UpdateSupportOptions) SetLocations(locations []string) *UpdateSupportOptions {
	_options.Locations = locations
	return _options
}

// SetSupportDetails : Allow user to set SupportDetails
func (_options *UpdateSupportOptions) SetSupportDetails(supportDetails []SupportDetails) *UpdateSupportOptions {
	_options.SupportDetails = supportDetails
	return _options
}

// SetSupportEscalation : Allow user to set SupportEscalation
func (_options *UpdateSupportOptions) SetSupportEscalation(supportEscalation *SupportEscalation) *UpdateSupportOptions {
	_options.SupportEscalation = supportEscalation
	return _options
}

// SetSupportType : Allow user to set SupportType
func (_options *UpdateSupportOptions) SetSupportType(supportType string) *UpdateSupportOptions {
	_options.SupportType = core.StringPtr(supportType)
	return _options
}

// SetURL : Allow user to set URL
func (_options *UpdateSupportOptions) SetURL(url string) *UpdateSupportOptions {
	_options.URL = core.StringPtr(url)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateSupportOptions) SetHeaders(param map[string]string) *UpdateSupportOptions {
	options.Headers = param
	return options
}
